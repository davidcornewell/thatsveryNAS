(function (jQuery, stream, fs) {
	'use strict';

	jQuery = jQuery && jQuery.hasOwnProperty('default') ? jQuery['default'] : jQuery;
	stream = stream && stream.hasOwnProperty('default') ? stream['default'] : stream;
	fs = fs && fs.hasOwnProperty('default') ? fs['default'] : fs;

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var bignumber = createCommonjsModule(function (module) {
	(function (globalObject) {

	/*
	 *      bignumber.js v8.1.1
	 *      A JavaScript library for arbitrary-precision arithmetic.
	 *      https://github.com/MikeMcl/bignumber.js
	 *      Copyright (c) 2019 Michael Mclaughlin <M8ch88l@gmail.com>
	 *      MIT Licensed.
	 *
	 *      BigNumber.prototype methods     |  BigNumber methods
	 *                                      |
	 *      absoluteValue            abs    |  clone
	 *      comparedTo                      |  config               set
	 *      decimalPlaces            dp     |      DECIMAL_PLACES
	 *      dividedBy                div    |      ROUNDING_MODE
	 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
	 *      exponentiatedBy          pow    |      RANGE
	 *      integerValue                    |      CRYPTO
	 *      isEqualTo                eq     |      MODULO_MODE
	 *      isFinite                        |      POW_PRECISION
	 *      isGreaterThan            gt     |      FORMAT
	 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
	 *      isInteger                       |  isBigNumber
	 *      isLessThan               lt     |  maximum              max
	 *      isLessThanOrEqualTo      lte    |  minimum              min
	 *      isNaN                           |  random
	 *      isNegative                      |  sum
	 *      isPositive                      |
	 *      isZero                          |
	 *      minus                           |
	 *      modulo                   mod    |
	 *      multipliedBy             times  |
	 *      negated                         |
	 *      plus                            |
	 *      precision                sd     |
	 *      shiftedBy                       |
	 *      squareRoot               sqrt   |
	 *      toExponential                   |
	 *      toFixed                         |
	 *      toFormat                        |
	 *      toFraction                      |
	 *      toJSON                          |
	 *      toNumber                        |
	 *      toPrecision                     |
	 *      toString                        |
	 *      valueOf                         |
	 *
	 */


	  var BigNumber,
	    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
	    hasSymbol = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol',

	    mathceil = Math.ceil,
	    mathfloor = Math.floor,

	    bignumberError = '[BigNumber Error] ',
	    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

	    BASE = 1e14,
	    LOG_BASE = 14,
	    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
	    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
	    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
	    SQRT_BASE = 1e7,

	    // EDITABLE
	    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
	    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
	    MAX = 1E9;                                   // 0 to MAX_INT32


	  /*
	   * Create and return a BigNumber constructor.
	   */
	  function clone(configObject) {
	    var div, convertBase, parseNumeric,
	      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
	      ONE = new BigNumber(1),


	      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


	      // The default values below must be integers within the inclusive ranges stated.
	      // The values can also be changed at run-time using BigNumber.set.

	      // The maximum number of decimal places for operations involving division.
	      DECIMAL_PLACES = 20,                     // 0 to MAX

	      // The rounding mode used when rounding to the above decimal places, and when using
	      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
	      // UP         0 Away from zero.
	      // DOWN       1 Towards zero.
	      // CEIL       2 Towards +Infinity.
	      // FLOOR      3 Towards -Infinity.
	      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
	      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
	      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
	      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
	      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
	      ROUNDING_MODE = 4,                       // 0 to 8

	      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

	      // The exponent value at and beneath which toString returns exponential notation.
	      // Number type: -7
	      TO_EXP_NEG = -7,                         // 0 to -MAX

	      // The exponent value at and above which toString returns exponential notation.
	      // Number type: 21
	      TO_EXP_POS = 21,                         // 0 to MAX

	      // RANGE : [MIN_EXP, MAX_EXP]

	      // The minimum exponent value, beneath which underflow to zero occurs.
	      // Number type: -324  (5e-324)
	      MIN_EXP = -1e7,                          // -1 to -MAX

	      // The maximum exponent value, above which overflow to Infinity occurs.
	      // Number type:  308  (1.7976931348623157e+308)
	      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
	      MAX_EXP = 1e7,                           // 1 to MAX

	      // Whether to use cryptographically-secure random number generation, if available.
	      CRYPTO = false,                          // true or false

	      // The modulo mode used when calculating the modulus: a mod n.
	      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
	      // The remainder (r) is calculated as: r = a - n * q.
	      //
	      // UP        0 The remainder is positive if the dividend is negative, else is negative.
	      // DOWN      1 The remainder has the same sign as the dividend.
	      //             This modulo mode is commonly known as 'truncated division' and is
	      //             equivalent to (a % n) in JavaScript.
	      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
	      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
	      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
	      //             The remainder is always positive.
	      //
	      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
	      // modes are commonly used for the modulus operation.
	      // Although the other rounding modes can also be used, they may not give useful results.
	      MODULO_MODE = 1,                         // 0 to 9

	      // The maximum number of significant digits of the result of the exponentiatedBy operation.
	      // If POW_PRECISION is 0, there will be unlimited significant digits.
	      POW_PRECISION = 0,                    // 0 to MAX

	      // The format specification used by the BigNumber.prototype.toFormat method.
	      FORMAT = {
	        prefix: '',
	        groupSize: 3,
	        secondaryGroupSize: 0,
	        groupSeparator: ',',
	        decimalSeparator: '.',
	        fractionGroupSize: 0,
	        fractionGroupSeparator: '\xA0',      // non-breaking space
	        suffix: ''
	      },

	      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
	      // '-', '.', whitespace, or repeated character.
	      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
	      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


	    //------------------------------------------------------------------------------------------


	    // CONSTRUCTOR


	    /*
	     * The BigNumber constructor and exported function.
	     * Create and return a new instance of a BigNumber object.
	     *
	     * v {number|string|BigNumber} A numeric value.
	     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
	     */
	    function BigNumber(v, b) {
	      var alphabet, c, caseChanged, e, i, isNum, len, str,
	        x = this;

	      // Enable constructor call without `new`.
	      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

	      if (b == null) {

	        if (v && v._isBigNumber === true) {
	          x.s = v.s;

	          if (!v.c || v.e > MAX_EXP) {
	            x.c = x.e = null;
	          } else if (v.e < MIN_EXP) {
	            x.c = [x.e = 0];
	          } else {
	            x.e = v.e;
	            x.c = v.c.slice();
	          }

	          return;
	        }

	        if ((isNum = typeof v == 'number') && v * 0 == 0) {

	          // Use `1 / n` to handle minus zero also.
	          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

	          // Fast path for integers, where n < 2147483648 (2**31).
	          if (v === ~~v) {
	            for (e = 0, i = v; i >= 10; i /= 10, e++);

	            if (e > MAX_EXP) {
	              x.c = x.e = null;
	            } else {
	              x.e = e;
	              x.c = [v];
	            }

	            return;
	          }

	          str = String(v);
	        } else {

	          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

	          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
	        }

	        // Decimal point?
	        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

	        // Exponential form?
	        if ((i = str.search(/e/i)) > 0) {

	          // Determine exponent.
	          if (e < 0) e = i;
	          e += +str.slice(i + 1);
	          str = str.substring(0, i);
	        } else if (e < 0) {

	          // Integer.
	          e = str.length;
	        }

	      } else {

	        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
	        intCheck(b, 2, ALPHABET.length, 'Base');

	        // Allow exponential notation to be used with base 10 argument, while
	        // also rounding to DECIMAL_PLACES as with other bases.
	        if (b == 10) {
	          x = new BigNumber(v);
	          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
	        }

	        str = String(v);

	        if (isNum = typeof v == 'number') {

	          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
	          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

	          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

	          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
	          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
	            throw Error
	             (tooManyDigits + v);
	          }
	        } else {
	          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
	        }

	        alphabet = ALPHABET.slice(0, b);
	        e = i = 0;

	        // Check that str is a valid base b number.
	        // Don't use RegExp, so alphabet can contain special characters.
	        for (len = str.length; i < len; i++) {
	          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
	            if (c == '.') {

	              // If '.' is not the first character and it has not be found before.
	              if (i > e) {
	                e = len;
	                continue;
	              }
	            } else if (!caseChanged) {

	              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
	              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
	                  str == str.toLowerCase() && (str = str.toUpperCase())) {
	                caseChanged = true;
	                i = -1;
	                e = 0;
	                continue;
	              }
	            }

	            return parseNumeric(x, String(v), isNum, b);
	          }
	        }

	        // Prevent later check for length on converted number.
	        isNum = false;
	        str = convertBase(str, b, 10, x.s);

	        // Decimal point?
	        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
	        else e = str.length;
	      }

	      // Determine leading zeros.
	      for (i = 0; str.charCodeAt(i) === 48; i++);

	      // Determine trailing zeros.
	      for (len = str.length; str.charCodeAt(--len) === 48;);

	      if (str = str.slice(i, ++len)) {
	        len -= i;

	        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
	        if (isNum && BigNumber.DEBUG &&
	          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
	            throw Error
	             (tooManyDigits + (x.s * v));
	        }

	         // Overflow?
	        if ((e = e - i - 1) > MAX_EXP) {

	          // Infinity.
	          x.c = x.e = null;

	        // Underflow?
	        } else if (e < MIN_EXP) {

	          // Zero.
	          x.c = [x.e = 0];
	        } else {
	          x.e = e;
	          x.c = [];

	          // Transform base

	          // e is the base 10 exponent.
	          // i is where to slice str to get the first element of the coefficient array.
	          i = (e + 1) % LOG_BASE;
	          if (e < 0) i += LOG_BASE;  // i < 1

	          if (i < len) {
	            if (i) x.c.push(+str.slice(0, i));

	            for (len -= LOG_BASE; i < len;) {
	              x.c.push(+str.slice(i, i += LOG_BASE));
	            }

	            i = LOG_BASE - (str = str.slice(i)).length;
	          } else {
	            i -= len;
	          }

	          for (; i--; str += '0');
	          x.c.push(+str);
	        }
	      } else {

	        // Zero.
	        x.c = [x.e = 0];
	      }
	    }


	    // CONSTRUCTOR PROPERTIES


	    BigNumber.clone = clone;

	    BigNumber.ROUND_UP = 0;
	    BigNumber.ROUND_DOWN = 1;
	    BigNumber.ROUND_CEIL = 2;
	    BigNumber.ROUND_FLOOR = 3;
	    BigNumber.ROUND_HALF_UP = 4;
	    BigNumber.ROUND_HALF_DOWN = 5;
	    BigNumber.ROUND_HALF_EVEN = 6;
	    BigNumber.ROUND_HALF_CEIL = 7;
	    BigNumber.ROUND_HALF_FLOOR = 8;
	    BigNumber.EUCLID = 9;


	    /*
	     * Configure infrequently-changing library-wide settings.
	     *
	     * Accept an object with the following optional properties (if the value of a property is
	     * a number, it must be an integer within the inclusive range stated):
	     *
	     *   DECIMAL_PLACES   {number}           0 to MAX
	     *   ROUNDING_MODE    {number}           0 to 8
	     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
	     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
	     *   CRYPTO           {boolean}          true or false
	     *   MODULO_MODE      {number}           0 to 9
	     *   POW_PRECISION       {number}           0 to MAX
	     *   ALPHABET         {string}           A string of two or more unique characters which does
	     *                                       not contain '.'.
	     *   FORMAT           {object}           An object with some of the following properties:
	     *     prefix                 {string}
	     *     groupSize              {number}
	     *     secondaryGroupSize     {number}
	     *     groupSeparator         {string}
	     *     decimalSeparator       {string}
	     *     fractionGroupSize      {number}
	     *     fractionGroupSeparator {string}
	     *     suffix                 {string}
	     *
	     * (The values assigned to the above FORMAT object properties are not checked for validity.)
	     *
	     * E.g.
	     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
	     *
	     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
	     *
	     * Return an object with the properties current values.
	     */
	    BigNumber.config = BigNumber.set = function (obj) {
	      var p, v;

	      if (obj != null) {

	        if (typeof obj == 'object') {

	          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
	          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
	          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
	            v = obj[p];
	            intCheck(v, 0, MAX, p);
	            DECIMAL_PLACES = v;
	          }

	          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
	          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
	          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
	            v = obj[p];
	            intCheck(v, 0, 8, p);
	            ROUNDING_MODE = v;
	          }

	          // EXPONENTIAL_AT {number|number[]}
	          // Integer, -MAX to MAX inclusive or
	          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
	          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
	          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
	            v = obj[p];
	            if (v && v.pop) {
	              intCheck(v[0], -MAX, 0, p);
	              intCheck(v[1], 0, MAX, p);
	              TO_EXP_NEG = v[0];
	              TO_EXP_POS = v[1];
	            } else {
	              intCheck(v, -MAX, MAX, p);
	              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
	            }
	          }

	          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
	          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
	          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
	          if (obj.hasOwnProperty(p = 'RANGE')) {
	            v = obj[p];
	            if (v && v.pop) {
	              intCheck(v[0], -MAX, -1, p);
	              intCheck(v[1], 1, MAX, p);
	              MIN_EXP = v[0];
	              MAX_EXP = v[1];
	            } else {
	              intCheck(v, -MAX, MAX, p);
	              if (v) {
	                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
	              } else {
	                throw Error
	                 (bignumberError + p + ' cannot be zero: ' + v);
	              }
	            }
	          }

	          // CRYPTO {boolean} true or false.
	          // '[BigNumber Error] CRYPTO not true or false: {v}'
	          // '[BigNumber Error] crypto unavailable'
	          if (obj.hasOwnProperty(p = 'CRYPTO')) {
	            v = obj[p];
	            if (v === !!v) {
	              if (v) {
	                if (typeof crypto != 'undefined' && crypto &&
	                 (crypto.getRandomValues || crypto.randomBytes)) {
	                  CRYPTO = v;
	                } else {
	                  CRYPTO = !v;
	                  throw Error
	                   (bignumberError + 'crypto unavailable');
	                }
	              } else {
	                CRYPTO = v;
	              }
	            } else {
	              throw Error
	               (bignumberError + p + ' not true or false: ' + v);
	            }
	          }

	          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
	          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
	          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
	            v = obj[p];
	            intCheck(v, 0, 9, p);
	            MODULO_MODE = v;
	          }

	          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
	          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
	          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
	            v = obj[p];
	            intCheck(v, 0, MAX, p);
	            POW_PRECISION = v;
	          }

	          // FORMAT {object}
	          // '[BigNumber Error] FORMAT not an object: {v}'
	          if (obj.hasOwnProperty(p = 'FORMAT')) {
	            v = obj[p];
	            if (typeof v == 'object') FORMAT = v;
	            else throw Error
	             (bignumberError + p + ' not an object: ' + v);
	          }

	          // ALPHABET {string}
	          // '[BigNumber Error] ALPHABET invalid: {v}'
	          if (obj.hasOwnProperty(p = 'ALPHABET')) {
	            v = obj[p];

	            // Disallow if only one character,
	            // or if it contains '+', '-', '.', whitespace, or a repeated character.
	            if (typeof v == 'string' && !/^.$|[+-.\s]|(.).*\1/.test(v)) {
	              ALPHABET = v;
	            } else {
	              throw Error
	               (bignumberError + p + ' invalid: ' + v);
	            }
	          }

	        } else {

	          // '[BigNumber Error] Object expected: {v}'
	          throw Error
	           (bignumberError + 'Object expected: ' + obj);
	        }
	      }

	      return {
	        DECIMAL_PLACES: DECIMAL_PLACES,
	        ROUNDING_MODE: ROUNDING_MODE,
	        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
	        RANGE: [MIN_EXP, MAX_EXP],
	        CRYPTO: CRYPTO,
	        MODULO_MODE: MODULO_MODE,
	        POW_PRECISION: POW_PRECISION,
	        FORMAT: FORMAT,
	        ALPHABET: ALPHABET
	      };
	    };


	    /*
	     * Return true if v is a BigNumber instance, otherwise return false.
	     *
	     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
	     *
	     * v {any}
	     *
	     * '[BigNumber Error] Invalid BigNumber: {v}'
	     */
	    BigNumber.isBigNumber = function (v) {
	      if (!v || v._isBigNumber !== true) return false;
	      if (!BigNumber.DEBUG) return true;

	      var i, n,
	        c = v.c,
	        e = v.e,
	        s = v.s;

	      out: if ({}.toString.call(c) == '[object Array]') {

	        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

	          // If the first element is zero, the BigNumber value must be zero.
	          if (c[0] === 0) {
	            if (e === 0 && c.length === 1) return true;
	            break out;
	          }

	          // Calculate number of digits that c[0] should have, based on the exponent.
	          i = (e + 1) % LOG_BASE;
	          if (i < 1) i += LOG_BASE;

	          // Calculate number of digits of c[0].
	          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
	          if (String(c[0]).length == i) {

	            for (i = 0; i < c.length; i++) {
	              n = c[i];
	              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
	            }

	            // Last element cannot be zero, unless it is the only element.
	            if (n !== 0) return true;
	          }
	        }

	      // Infinity/NaN
	      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
	        return true;
	      }

	      throw Error
	        (bignumberError + 'Invalid BigNumber: ' + v);
	    };


	    /*
	     * Return a new BigNumber whose value is the maximum of the arguments.
	     *
	     * arguments {number|string|BigNumber}
	     */
	    BigNumber.maximum = BigNumber.max = function () {
	      return maxOrMin(arguments, P.lt);
	    };


	    /*
	     * Return a new BigNumber whose value is the minimum of the arguments.
	     *
	     * arguments {number|string|BigNumber}
	     */
	    BigNumber.minimum = BigNumber.min = function () {
	      return maxOrMin(arguments, P.gt);
	    };


	    /*
	     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
	     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
	     * zeros are produced).
	     *
	     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	     *
	     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
	     * '[BigNumber Error] crypto unavailable'
	     */
	    BigNumber.random = (function () {
	      var pow2_53 = 0x20000000000000;

	      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
	      // Check if Math.random() produces more than 32 bits of randomness.
	      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
	      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
	      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
	       ? function () { return mathfloor(Math.random() * pow2_53); }
	       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
	         (Math.random() * 0x800000 | 0); };

	      return function (dp) {
	        var a, b, e, k, v,
	          i = 0,
	          c = [],
	          rand = new BigNumber(ONE);

	        if (dp == null) dp = DECIMAL_PLACES;
	        else intCheck(dp, 0, MAX);

	        k = mathceil(dp / LOG_BASE);

	        if (CRYPTO) {

	          // Browsers supporting crypto.getRandomValues.
	          if (crypto.getRandomValues) {

	            a = crypto.getRandomValues(new Uint32Array(k *= 2));

	            for (; i < k;) {

	              // 53 bits:
	              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
	              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
	              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
	              //                                     11111 11111111 11111111
	              // 0x20000 is 2^21.
	              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

	              // Rejection sampling:
	              // 0 <= v < 9007199254740992
	              // Probability that v >= 9e15, is
	              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
	              if (v >= 9e15) {
	                b = crypto.getRandomValues(new Uint32Array(2));
	                a[i] = b[0];
	                a[i + 1] = b[1];
	              } else {

	                // 0 <= v <= 8999999999999999
	                // 0 <= (v % 1e14) <= 99999999999999
	                c.push(v % 1e14);
	                i += 2;
	              }
	            }
	            i = k / 2;

	          // Node.js supporting crypto.randomBytes.
	          } else if (crypto.randomBytes) {

	            // buffer
	            a = crypto.randomBytes(k *= 7);

	            for (; i < k;) {

	              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
	              // 0x100000000 is 2^32, 0x1000000 is 2^24
	              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
	              // 0 <= v < 9007199254740992
	              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
	                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
	                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

	              if (v >= 9e15) {
	                crypto.randomBytes(7).copy(a, i);
	              } else {

	                // 0 <= (v % 1e14) <= 99999999999999
	                c.push(v % 1e14);
	                i += 7;
	              }
	            }
	            i = k / 7;
	          } else {
	            CRYPTO = false;
	            throw Error
	             (bignumberError + 'crypto unavailable');
	          }
	        }

	        // Use Math.random.
	        if (!CRYPTO) {

	          for (; i < k;) {
	            v = random53bitInt();
	            if (v < 9e15) c[i++] = v % 1e14;
	          }
	        }

	        k = c[--i];
	        dp %= LOG_BASE;

	        // Convert trailing digits to zeros according to dp.
	        if (k && dp) {
	          v = POWS_TEN[LOG_BASE - dp];
	          c[i] = mathfloor(k / v) * v;
	        }

	        // Remove trailing elements which are zero.
	        for (; c[i] === 0; c.pop(), i--);

	        // Zero?
	        if (i < 0) {
	          c = [e = 0];
	        } else {

	          // Remove leading elements which are zero and adjust exponent accordingly.
	          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

	          // Count the digits of the first element of c to determine leading zeros, and...
	          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

	          // adjust the exponent accordingly.
	          if (i < LOG_BASE) e -= LOG_BASE - i;
	        }

	        rand.e = e;
	        rand.c = c;
	        return rand;
	      };
	    })();


	    /*
	     * Return a BigNumber whose value is the sum of the arguments.
	     *
	     * arguments {number|string|BigNumber}
	     */
	    BigNumber.sum = function () {
	      var i = 1,
	        args = arguments,
	        sum = new BigNumber(args[0]);
	      for (; i < args.length;) sum = sum.plus(args[i++]);
	      return sum;
	    };


	    // PRIVATE FUNCTIONS


	    // Called by BigNumber and BigNumber.prototype.toString.
	    convertBase = (function () {
	      var decimal = '0123456789';

	      /*
	       * Convert string of baseIn to an array of numbers of baseOut.
	       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
	       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
	       */
	      function toBaseOut(str, baseIn, baseOut, alphabet) {
	        var j,
	          arr = [0],
	          arrL,
	          i = 0,
	          len = str.length;

	        for (; i < len;) {
	          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

	          arr[0] += alphabet.indexOf(str.charAt(i++));

	          for (j = 0; j < arr.length; j++) {

	            if (arr[j] > baseOut - 1) {
	              if (arr[j + 1] == null) arr[j + 1] = 0;
	              arr[j + 1] += arr[j] / baseOut | 0;
	              arr[j] %= baseOut;
	            }
	          }
	        }

	        return arr.reverse();
	      }

	      // Convert a numeric string of baseIn to a numeric string of baseOut.
	      // If the caller is toString, we are converting from base 10 to baseOut.
	      // If the caller is BigNumber, we are converting from baseIn to base 10.
	      return function (str, baseIn, baseOut, sign, callerIsToString) {
	        var alphabet, d, e, k, r, x, xc, y,
	          i = str.indexOf('.'),
	          dp = DECIMAL_PLACES,
	          rm = ROUNDING_MODE;

	        // Non-integer.
	        if (i >= 0) {
	          k = POW_PRECISION;

	          // Unlimited precision.
	          POW_PRECISION = 0;
	          str = str.replace('.', '');
	          y = new BigNumber(baseIn);
	          x = y.pow(str.length - i);
	          POW_PRECISION = k;

	          // Convert str as if an integer, then restore the fraction part by dividing the
	          // result by its base raised to a power.

	          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
	           10, baseOut, decimal);
	          y.e = y.c.length;
	        }

	        // Convert the number as integer.

	        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
	         ? (alphabet = ALPHABET, decimal)
	         : (alphabet = decimal, ALPHABET));

	        // xc now represents str as an integer and converted to baseOut. e is the exponent.
	        e = k = xc.length;

	        // Remove trailing zeros.
	        for (; xc[--k] == 0; xc.pop());

	        // Zero?
	        if (!xc[0]) return alphabet.charAt(0);

	        // Does str represent an integer? If so, no need for the division.
	        if (i < 0) {
	          --e;
	        } else {
	          x.c = xc;
	          x.e = e;

	          // The sign is needed for correct rounding.
	          x.s = sign;
	          x = div(x, y, dp, rm, baseOut);
	          xc = x.c;
	          r = x.r;
	          e = x.e;
	        }

	        // xc now represents str converted to baseOut.

	        // THe index of the rounding digit.
	        d = e + dp + 1;

	        // The rounding digit: the digit to the right of the digit that may be rounded up.
	        i = xc[d];

	        // Look at the rounding digits and mode to determine whether to round up.

	        k = baseOut / 2;
	        r = r || d < 0 || xc[d + 1] != null;

	        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
	              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
	               rm == (x.s < 0 ? 8 : 7));

	        // If the index of the rounding digit is not greater than zero, or xc represents
	        // zero, then the result of the base conversion is zero or, if rounding up, a value
	        // such as 0.00001.
	        if (d < 1 || !xc[0]) {

	          // 1^-dp or 0
	          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
	        } else {

	          // Truncate xc to the required number of decimal places.
	          xc.length = d;

	          // Round up?
	          if (r) {

	            // Rounding up may mean the previous digit has to be rounded up and so on.
	            for (--baseOut; ++xc[--d] > baseOut;) {
	              xc[d] = 0;

	              if (!d) {
	                ++e;
	                xc = [1].concat(xc);
	              }
	            }
	          }

	          // Determine trailing zeros.
	          for (k = xc.length; !xc[--k];);

	          // E.g. [4, 11, 15] becomes 4bf.
	          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

	          // Add leading zeros, decimal point and trailing zeros as required.
	          str = toFixedPoint(str, e, alphabet.charAt(0));
	        }

	        // The caller will add the sign.
	        return str;
	      };
	    })();


	    // Perform division in the specified base. Called by div and convertBase.
	    div = (function () {

	      // Assume non-zero x and k.
	      function multiply(x, k, base) {
	        var m, temp, xlo, xhi,
	          carry = 0,
	          i = x.length,
	          klo = k % SQRT_BASE,
	          khi = k / SQRT_BASE | 0;

	        for (x = x.slice(); i--;) {
	          xlo = x[i] % SQRT_BASE;
	          xhi = x[i] / SQRT_BASE | 0;
	          m = khi * xlo + xhi * klo;
	          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
	          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
	          x[i] = temp % base;
	        }

	        if (carry) x = [carry].concat(x);

	        return x;
	      }

	      function compare(a, b, aL, bL) {
	        var i, cmp;

	        if (aL != bL) {
	          cmp = aL > bL ? 1 : -1;
	        } else {

	          for (i = cmp = 0; i < aL; i++) {

	            if (a[i] != b[i]) {
	              cmp = a[i] > b[i] ? 1 : -1;
	              break;
	            }
	          }
	        }

	        return cmp;
	      }

	      function subtract(a, b, aL, base) {
	        var i = 0;

	        // Subtract b from a.
	        for (; aL--;) {
	          a[aL] -= i;
	          i = a[aL] < b[aL] ? 1 : 0;
	          a[aL] = i * base + a[aL] - b[aL];
	        }

	        // Remove leading zeros.
	        for (; !a[0] && a.length > 1; a.splice(0, 1));
	      }

	      // x: dividend, y: divisor.
	      return function (x, y, dp, rm, base) {
	        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
	          yL, yz,
	          s = x.s == y.s ? 1 : -1,
	          xc = x.c,
	          yc = y.c;

	        // Either NaN, Infinity or 0?
	        if (!xc || !xc[0] || !yc || !yc[0]) {

	          return new BigNumber(

	           // Return NaN if either NaN, or both Infinity or 0.
	           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

	            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
	            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
	         );
	        }

	        q = new BigNumber(s);
	        qc = q.c = [];
	        e = x.e - y.e;
	        s = dp + e + 1;

	        if (!base) {
	          base = BASE;
	          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
	          s = s / LOG_BASE | 0;
	        }

	        // Result exponent may be one less then the current value of e.
	        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
	        for (i = 0; yc[i] == (xc[i] || 0); i++);

	        if (yc[i] > (xc[i] || 0)) e--;

	        if (s < 0) {
	          qc.push(1);
	          more = true;
	        } else {
	          xL = xc.length;
	          yL = yc.length;
	          i = 0;
	          s += 2;

	          // Normalise xc and yc so highest order digit of yc is >= base / 2.

	          n = mathfloor(base / (yc[0] + 1));

	          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
	          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
	          if (n > 1) {
	            yc = multiply(yc, n, base);
	            xc = multiply(xc, n, base);
	            yL = yc.length;
	            xL = xc.length;
	          }

	          xi = yL;
	          rem = xc.slice(0, yL);
	          remL = rem.length;

	          // Add zeros to make remainder as long as divisor.
	          for (; remL < yL; rem[remL++] = 0);
	          yz = yc.slice();
	          yz = [0].concat(yz);
	          yc0 = yc[0];
	          if (yc[1] >= base / 2) yc0++;
	          // Not necessary, but to prevent trial digit n > base, when using base 3.
	          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

	          do {
	            n = 0;

	            // Compare divisor and remainder.
	            cmp = compare(yc, rem, yL, remL);

	            // If divisor < remainder.
	            if (cmp < 0) {

	              // Calculate trial digit, n.

	              rem0 = rem[0];
	              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

	              // n is how many times the divisor goes into the current remainder.
	              n = mathfloor(rem0 / yc0);

	              //  Algorithm:
	              //  product = divisor multiplied by trial digit (n).
	              //  Compare product and remainder.
	              //  If product is greater than remainder:
	              //    Subtract divisor from product, decrement trial digit.
	              //  Subtract product from remainder.
	              //  If product was less than remainder at the last compare:
	              //    Compare new remainder and divisor.
	              //    If remainder is greater than divisor:
	              //      Subtract divisor from remainder, increment trial digit.

	              if (n > 1) {

	                // n may be > base only when base is 3.
	                if (n >= base) n = base - 1;

	                // product = divisor * trial digit.
	                prod = multiply(yc, n, base);
	                prodL = prod.length;
	                remL = rem.length;

	                // Compare product and remainder.
	                // If product > remainder then trial digit n too high.
	                // n is 1 too high about 5% of the time, and is not known to have
	                // ever been more than 1 too high.
	                while (compare(prod, rem, prodL, remL) == 1) {
	                  n--;

	                  // Subtract divisor from product.
	                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
	                  prodL = prod.length;
	                  cmp = 1;
	                }
	              } else {

	                // n is 0 or 1, cmp is -1.
	                // If n is 0, there is no need to compare yc and rem again below,
	                // so change cmp to 1 to avoid it.
	                // If n is 1, leave cmp as -1, so yc and rem are compared again.
	                if (n == 0) {

	                  // divisor < remainder, so n must be at least 1.
	                  cmp = n = 1;
	                }

	                // product = divisor
	                prod = yc.slice();
	                prodL = prod.length;
	              }

	              if (prodL < remL) prod = [0].concat(prod);

	              // Subtract product from remainder.
	              subtract(rem, prod, remL, base);
	              remL = rem.length;

	               // If product was < remainder.
	              if (cmp == -1) {

	                // Compare divisor and new remainder.
	                // If divisor < new remainder, subtract divisor from remainder.
	                // Trial digit n too low.
	                // n is 1 too low about 5% of the time, and very rarely 2 too low.
	                while (compare(yc, rem, yL, remL) < 1) {
	                  n++;

	                  // Subtract divisor from remainder.
	                  subtract(rem, yL < remL ? yz : yc, remL, base);
	                  remL = rem.length;
	                }
	              }
	            } else if (cmp === 0) {
	              n++;
	              rem = [0];
	            } // else cmp === 1 and n will be 0

	            // Add the next digit, n, to the result array.
	            qc[i++] = n;

	            // Update the remainder.
	            if (rem[0]) {
	              rem[remL++] = xc[xi] || 0;
	            } else {
	              rem = [xc[xi]];
	              remL = 1;
	            }
	          } while ((xi++ < xL || rem[0] != null) && s--);

	          more = rem[0] != null;

	          // Leading zero?
	          if (!qc[0]) qc.splice(0, 1);
	        }

	        if (base == BASE) {

	          // To calculate q.e, first get the number of digits of qc[0].
	          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

	          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

	        // Caller is convertBase.
	        } else {
	          q.e = e;
	          q.r = +more;
	        }

	        return q;
	      };
	    })();


	    /*
	     * Return a string representing the value of BigNumber n in fixed-point or exponential
	     * notation rounded to the specified decimal places or significant digits.
	     *
	     * n: a BigNumber.
	     * i: the index of the last digit required (i.e. the digit that may be rounded up).
	     * rm: the rounding mode.
	     * id: 1 (toExponential) or 2 (toPrecision).
	     */
	    function format(n, i, rm, id) {
	      var c0, e, ne, len, str;

	      if (rm == null) rm = ROUNDING_MODE;
	      else intCheck(rm, 0, 8);

	      if (!n.c) return n.toString();

	      c0 = n.c[0];
	      ne = n.e;

	      if (i == null) {
	        str = coeffToString(n.c);
	        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
	         ? toExponential(str, ne)
	         : toFixedPoint(str, ne, '0');
	      } else {
	        n = round(new BigNumber(n), i, rm);

	        // n.e may have changed if the value was rounded up.
	        e = n.e;

	        str = coeffToString(n.c);
	        len = str.length;

	        // toPrecision returns exponential notation if the number of significant digits
	        // specified is less than the number of digits necessary to represent the integer
	        // part of the value in fixed-point notation.

	        // Exponential notation.
	        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

	          // Append zeros?
	          for (; len < i; str += '0', len++);
	          str = toExponential(str, e);

	        // Fixed-point notation.
	        } else {
	          i -= ne;
	          str = toFixedPoint(str, e, '0');

	          // Append zeros?
	          if (e + 1 > len) {
	            if (--i > 0) for (str += '.'; i--; str += '0');
	          } else {
	            i += e - len;
	            if (i > 0) {
	              if (e + 1 == len) str += '.';
	              for (; i--; str += '0');
	            }
	          }
	        }
	      }

	      return n.s < 0 && c0 ? '-' + str : str;
	    }


	    // Handle BigNumber.max and BigNumber.min.
	    function maxOrMin(args, method) {
	      var n,
	        i = 1,
	        m = new BigNumber(args[0]);

	      for (; i < args.length; i++) {
	        n = new BigNumber(args[i]);

	        // If any number is NaN, return NaN.
	        if (!n.s) {
	          m = n;
	          break;
	        } else if (method.call(m, n)) {
	          m = n;
	        }
	      }

	      return m;
	    }


	    /*
	     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
	     * Called by minus, plus and times.
	     */
	    function normalise(n, c, e) {
	      var i = 1,
	        j = c.length;

	       // Remove trailing zeros.
	      for (; !c[--j]; c.pop());

	      // Calculate the base 10 exponent. First get the number of digits of c[0].
	      for (j = c[0]; j >= 10; j /= 10, i++);

	      // Overflow?
	      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

	        // Infinity.
	        n.c = n.e = null;

	      // Underflow?
	      } else if (e < MIN_EXP) {

	        // Zero.
	        n.c = [n.e = 0];
	      } else {
	        n.e = e;
	        n.c = c;
	      }

	      return n;
	    }


	    // Handle values that fail the validity test in BigNumber.
	    parseNumeric = (function () {
	      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
	        dotAfter = /^([^.]+)\.$/,
	        dotBefore = /^\.([^.]+)$/,
	        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
	        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

	      return function (x, str, isNum, b) {
	        var base,
	          s = isNum ? str : str.replace(whitespaceOrPlus, '');

	        // No exception on ±Infinity or NaN.
	        if (isInfinityOrNaN.test(s)) {
	          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
	        } else {
	          if (!isNum) {

	            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
	            s = s.replace(basePrefix, function (m, p1, p2) {
	              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
	              return !b || b == base ? p1 : m;
	            });

	            if (b) {
	              base = b;

	              // E.g. '1.' to '1', '.1' to '0.1'
	              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
	            }

	            if (str != s) return new BigNumber(s, base);
	          }

	          // '[BigNumber Error] Not a number: {n}'
	          // '[BigNumber Error] Not a base {b} number: {n}'
	          if (BigNumber.DEBUG) {
	            throw Error
	              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
	          }

	          // NaN
	          x.s = null;
	        }

	        x.c = x.e = null;
	      }
	    })();


	    /*
	     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
	     * If r is truthy, it is known that there are more digits after the rounding digit.
	     */
	    function round(x, sd, rm, r) {
	      var d, i, j, k, n, ni, rd,
	        xc = x.c,
	        pows10 = POWS_TEN;

	      // if x is not Infinity or NaN...
	      if (xc) {

	        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
	        // n is a base 1e14 number, the value of the element of array x.c containing rd.
	        // ni is the index of n within x.c.
	        // d is the number of digits of n.
	        // i is the index of rd within n including leading zeros.
	        // j is the actual index of rd within n (if < 0, rd is a leading zero).
	        out: {

	          // Get the number of digits of the first element of xc.
	          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
	          i = sd - d;

	          // If the rounding digit is in the first element of xc...
	          if (i < 0) {
	            i += LOG_BASE;
	            j = sd;
	            n = xc[ni = 0];

	            // Get the rounding digit at index j of n.
	            rd = n / pows10[d - j - 1] % 10 | 0;
	          } else {
	            ni = mathceil((i + 1) / LOG_BASE);

	            if (ni >= xc.length) {

	              if (r) {

	                // Needed by sqrt.
	                for (; xc.length <= ni; xc.push(0));
	                n = rd = 0;
	                d = 1;
	                i %= LOG_BASE;
	                j = i - LOG_BASE + 1;
	              } else {
	                break out;
	              }
	            } else {
	              n = k = xc[ni];

	              // Get the number of digits of n.
	              for (d = 1; k >= 10; k /= 10, d++);

	              // Get the index of rd within n.
	              i %= LOG_BASE;

	              // Get the index of rd within n, adjusted for leading zeros.
	              // The number of leading zeros of n is given by LOG_BASE - d.
	              j = i - LOG_BASE + d;

	              // Get the rounding digit at index j of n.
	              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
	            }
	          }

	          r = r || sd < 0 ||

	          // Are there any non-zero digits after the rounding digit?
	          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
	          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
	           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

	          r = rm < 4
	           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
	           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

	            // Check whether the digit to the left of the rounding digit is odd.
	            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
	             rm == (x.s < 0 ? 8 : 7));

	          if (sd < 1 || !xc[0]) {
	            xc.length = 0;

	            if (r) {

	              // Convert sd to decimal places.
	              sd -= x.e + 1;

	              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
	              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
	              x.e = -sd || 0;
	            } else {

	              // Zero.
	              xc[0] = x.e = 0;
	            }

	            return x;
	          }

	          // Remove excess digits.
	          if (i == 0) {
	            xc.length = ni;
	            k = 1;
	            ni--;
	          } else {
	            xc.length = ni + 1;
	            k = pows10[LOG_BASE - i];

	            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
	            // j > 0 means i > number of leading zeros of n.
	            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
	          }

	          // Round up?
	          if (r) {

	            for (; ;) {

	              // If the digit to be rounded up is in the first element of xc...
	              if (ni == 0) {

	                // i will be the length of xc[0] before k is added.
	                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
	                j = xc[0] += k;
	                for (k = 1; j >= 10; j /= 10, k++);

	                // if i != k the length has increased.
	                if (i != k) {
	                  x.e++;
	                  if (xc[0] == BASE) xc[0] = 1;
	                }

	                break;
	              } else {
	                xc[ni] += k;
	                if (xc[ni] != BASE) break;
	                xc[ni--] = 0;
	                k = 1;
	              }
	            }
	          }

	          // Remove trailing zeros.
	          for (i = xc.length; xc[--i] === 0; xc.pop());
	        }

	        // Overflow? Infinity.
	        if (x.e > MAX_EXP) {
	          x.c = x.e = null;

	        // Underflow? Zero.
	        } else if (x.e < MIN_EXP) {
	          x.c = [x.e = 0];
	        }
	      }

	      return x;
	    }


	    function valueOf(n) {
	      var str,
	        e = n.e;

	      if (e === null) return n.toString();

	      str = coeffToString(n.c);

	      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
	        ? toExponential(str, e)
	        : toFixedPoint(str, e, '0');

	      return n.s < 0 ? '-' + str : str;
	    }


	    // PROTOTYPE/INSTANCE METHODS


	    /*
	     * Return a new BigNumber whose value is the absolute value of this BigNumber.
	     */
	    P.absoluteValue = P.abs = function () {
	      var x = new BigNumber(this);
	      if (x.s < 0) x.s = 1;
	      return x;
	    };


	    /*
	     * Return
	     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
	     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
	     *   0 if they have the same value,
	     *   or null if the value of either is NaN.
	     */
	    P.comparedTo = function (y, b) {
	      return compare(this, new BigNumber(y, b));
	    };


	    /*
	     * If dp is undefined or null or true or false, return the number of decimal places of the
	     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
	     *
	     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
	     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
	     * ROUNDING_MODE if rm is omitted.
	     *
	     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
	     */
	    P.decimalPlaces = P.dp = function (dp, rm) {
	      var c, n, v,
	        x = this;

	      if (dp != null) {
	        intCheck(dp, 0, MAX);
	        if (rm == null) rm = ROUNDING_MODE;
	        else intCheck(rm, 0, 8);

	        return round(new BigNumber(x), dp + x.e + 1, rm);
	      }

	      if (!(c = x.c)) return null;
	      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

	      // Subtract the number of trailing zeros of the last number.
	      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
	      if (n < 0) n = 0;

	      return n;
	    };


	    /*
	     *  n / 0 = I
	     *  n / N = N
	     *  n / I = 0
	     *  0 / n = 0
	     *  0 / 0 = N
	     *  0 / N = N
	     *  0 / I = 0
	     *  N / n = N
	     *  N / 0 = N
	     *  N / N = N
	     *  N / I = N
	     *  I / n = I
	     *  I / 0 = I
	     *  I / N = N
	     *  I / I = N
	     *
	     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
	     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
	     */
	    P.dividedBy = P.div = function (y, b) {
	      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
	    };


	    /*
	     * Return a new BigNumber whose value is the integer part of dividing the value of this
	     * BigNumber by the value of BigNumber(y, b).
	     */
	    P.dividedToIntegerBy = P.idiv = function (y, b) {
	      return div(this, new BigNumber(y, b), 0, 1);
	    };


	    /*
	     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
	     *
	     * If m is present, return the result modulo m.
	     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
	     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
	     *
	     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
	     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
	     *
	     * n {number|string|BigNumber} The exponent. An integer.
	     * [m] {number|string|BigNumber} The modulus.
	     *
	     * '[BigNumber Error] Exponent not an integer: {n}'
	     */
	    P.exponentiatedBy = P.pow = function (n, m) {
	      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
	        x = this;

	      n = new BigNumber(n);

	      // Allow NaN and ±Infinity, but not other non-integers.
	      if (n.c && !n.isInteger()) {
	        throw Error
	          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
	      }

	      if (m != null) m = new BigNumber(m);

	      // Exponent of MAX_SAFE_INTEGER is 15.
	      nIsBig = n.e > 14;

	      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
	      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

	        // The sign of the result of pow when x is negative depends on the evenness of n.
	        // If +n overflows to ±Infinity, the evenness of n would be not be known.
	        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
	        return m ? y.mod(m) : y;
	      }

	      nIsNeg = n.s < 0;

	      if (m) {

	        // x % m returns NaN if abs(m) is zero, or m is NaN.
	        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

	        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

	        if (isModExp) x = x.mod(m);

	      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
	      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
	      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
	        // [1, 240000000]
	        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
	        // [80000000000000]  [99999750000000]
	        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

	        // If x is negative and n is odd, k = -0, else k = 0.
	        k = x.s < 0 && isOdd(n) ? -0 : 0;

	        // If x >= 1, k = ±Infinity.
	        if (x.e > -1) k = 1 / k;

	        // If n is negative return ±0, else return ±Infinity.
	        return new BigNumber(nIsNeg ? 1 / k : k);

	      } else if (POW_PRECISION) {

	        // Truncating each coefficient array to a length of k after each multiplication
	        // equates to truncating significant digits to POW_PRECISION + [28, 41],
	        // i.e. there will be a minimum of 28 guard digits retained.
	        k = mathceil(POW_PRECISION / LOG_BASE + 2);
	      }

	      if (nIsBig) {
	        half = new BigNumber(0.5);
	        if (nIsNeg) n.s = 1;
	        nIsOdd = isOdd(n);
	      } else {
	        i = Math.abs(+valueOf(n));
	        nIsOdd = i % 2;
	      }

	      y = new BigNumber(ONE);

	      // Performs 54 loop iterations for n of 9007199254740991.
	      for (; ;) {

	        if (nIsOdd) {
	          y = y.times(x);
	          if (!y.c) break;

	          if (k) {
	            if (y.c.length > k) y.c.length = k;
	          } else if (isModExp) {
	            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
	          }
	        }

	        if (i) {
	          i = mathfloor(i / 2);
	          if (i === 0) break;
	          nIsOdd = i % 2;
	        } else {
	          n = n.times(half);
	          round(n, n.e + 1, 1);

	          if (n.e > 14) {
	            nIsOdd = isOdd(n);
	          } else {
	            i = +valueOf(n);
	            if (i === 0) break;
	            nIsOdd = i % 2;
	          }
	        }

	        x = x.times(x);

	        if (k) {
	          if (x.c && x.c.length > k) x.c.length = k;
	        } else if (isModExp) {
	          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
	        }
	      }

	      if (isModExp) return y;
	      if (nIsNeg) y = ONE.div(y);

	      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
	    };


	    /*
	     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
	     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
	     *
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
	     */
	    P.integerValue = function (rm) {
	      var n = new BigNumber(this);
	      if (rm == null) rm = ROUNDING_MODE;
	      else intCheck(rm, 0, 8);
	      return round(n, n.e + 1, rm);
	    };


	    /*
	     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
	     * otherwise return false.
	     */
	    P.isEqualTo = P.eq = function (y, b) {
	      return compare(this, new BigNumber(y, b)) === 0;
	    };


	    /*
	     * Return true if the value of this BigNumber is a finite number, otherwise return false.
	     */
	    P.isFinite = function () {
	      return !!this.c;
	    };


	    /*
	     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
	     * otherwise return false.
	     */
	    P.isGreaterThan = P.gt = function (y, b) {
	      return compare(this, new BigNumber(y, b)) > 0;
	    };


	    /*
	     * Return true if the value of this BigNumber is greater than or equal to the value of
	     * BigNumber(y, b), otherwise return false.
	     */
	    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
	      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

	    };


	    /*
	     * Return true if the value of this BigNumber is an integer, otherwise return false.
	     */
	    P.isInteger = function () {
	      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
	    };


	    /*
	     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
	     * otherwise return false.
	     */
	    P.isLessThan = P.lt = function (y, b) {
	      return compare(this, new BigNumber(y, b)) < 0;
	    };


	    /*
	     * Return true if the value of this BigNumber is less than or equal to the value of
	     * BigNumber(y, b), otherwise return false.
	     */
	    P.isLessThanOrEqualTo = P.lte = function (y, b) {
	      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
	    };


	    /*
	     * Return true if the value of this BigNumber is NaN, otherwise return false.
	     */
	    P.isNaN = function () {
	      return !this.s;
	    };


	    /*
	     * Return true if the value of this BigNumber is negative, otherwise return false.
	     */
	    P.isNegative = function () {
	      return this.s < 0;
	    };


	    /*
	     * Return true if the value of this BigNumber is positive, otherwise return false.
	     */
	    P.isPositive = function () {
	      return this.s > 0;
	    };


	    /*
	     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
	     */
	    P.isZero = function () {
	      return !!this.c && this.c[0] == 0;
	    };


	    /*
	     *  n - 0 = n
	     *  n - N = N
	     *  n - I = -I
	     *  0 - n = -n
	     *  0 - 0 = 0
	     *  0 - N = N
	     *  0 - I = -I
	     *  N - n = N
	     *  N - 0 = N
	     *  N - N = N
	     *  N - I = N
	     *  I - n = I
	     *  I - 0 = I
	     *  I - N = N
	     *  I - I = N
	     *
	     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
	     * BigNumber(y, b).
	     */
	    P.minus = function (y, b) {
	      var i, j, t, xLTy,
	        x = this,
	        a = x.s;

	      y = new BigNumber(y, b);
	      b = y.s;

	      // Either NaN?
	      if (!a || !b) return new BigNumber(NaN);

	      // Signs differ?
	      if (a != b) {
	        y.s = -b;
	        return x.plus(y);
	      }

	      var xe = x.e / LOG_BASE,
	        ye = y.e / LOG_BASE,
	        xc = x.c,
	        yc = y.c;

	      if (!xe || !ye) {

	        // Either Infinity?
	        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

	        // Either zero?
	        if (!xc[0] || !yc[0]) {

	          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
	          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

	           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
	           ROUNDING_MODE == 3 ? -0 : 0);
	        }
	      }

	      xe = bitFloor(xe);
	      ye = bitFloor(ye);
	      xc = xc.slice();

	      // Determine which is the bigger number.
	      if (a = xe - ye) {

	        if (xLTy = a < 0) {
	          a = -a;
	          t = xc;
	        } else {
	          ye = xe;
	          t = yc;
	        }

	        t.reverse();

	        // Prepend zeros to equalise exponents.
	        for (b = a; b--; t.push(0));
	        t.reverse();
	      } else {

	        // Exponents equal. Check digit by digit.
	        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

	        for (a = b = 0; b < j; b++) {

	          if (xc[b] != yc[b]) {
	            xLTy = xc[b] < yc[b];
	            break;
	          }
	        }
	      }

	      // x < y? Point xc to the array of the bigger number.
	      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

	      b = (j = yc.length) - (i = xc.length);

	      // Append zeros to xc if shorter.
	      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
	      if (b > 0) for (; b--; xc[i++] = 0);
	      b = BASE - 1;

	      // Subtract yc from xc.
	      for (; j > a;) {

	        if (xc[--j] < yc[j]) {
	          for (i = j; i && !xc[--i]; xc[i] = b);
	          --xc[i];
	          xc[j] += BASE;
	        }

	        xc[j] -= yc[j];
	      }

	      // Remove leading zeros and adjust exponent accordingly.
	      for (; xc[0] == 0; xc.splice(0, 1), --ye);

	      // Zero?
	      if (!xc[0]) {

	        // Following IEEE 754 (2008) 6.3,
	        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
	        y.s = ROUNDING_MODE == 3 ? -1 : 1;
	        y.c = [y.e = 0];
	        return y;
	      }

	      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
	      // for finite x and y.
	      return normalise(y, xc, ye);
	    };


	    /*
	     *   n % 0 =  N
	     *   n % N =  N
	     *   n % I =  n
	     *   0 % n =  0
	     *  -0 % n = -0
	     *   0 % 0 =  N
	     *   0 % N =  N
	     *   0 % I =  0
	     *   N % n =  N
	     *   N % 0 =  N
	     *   N % N =  N
	     *   N % I =  N
	     *   I % n =  N
	     *   I % 0 =  N
	     *   I % N =  N
	     *   I % I =  N
	     *
	     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
	     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
	     */
	    P.modulo = P.mod = function (y, b) {
	      var q, s,
	        x = this;

	      y = new BigNumber(y, b);

	      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
	      if (!x.c || !y.s || y.c && !y.c[0]) {
	        return new BigNumber(NaN);

	      // Return x if y is Infinity or x is zero.
	      } else if (!y.c || x.c && !x.c[0]) {
	        return new BigNumber(x);
	      }

	      if (MODULO_MODE == 9) {

	        // Euclidian division: q = sign(y) * floor(x / abs(y))
	        // r = x - qy    where  0 <= r < abs(y)
	        s = y.s;
	        y.s = 1;
	        q = div(x, y, 0, 3);
	        y.s = s;
	        q.s *= s;
	      } else {
	        q = div(x, y, 0, MODULO_MODE);
	      }

	      y = x.minus(q.times(y));

	      // To match JavaScript %, ensure sign of zero is sign of dividend.
	      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

	      return y;
	    };


	    /*
	     *  n * 0 = 0
	     *  n * N = N
	     *  n * I = I
	     *  0 * n = 0
	     *  0 * 0 = 0
	     *  0 * N = N
	     *  0 * I = N
	     *  N * n = N
	     *  N * 0 = N
	     *  N * N = N
	     *  N * I = N
	     *  I * n = I
	     *  I * 0 = N
	     *  I * N = N
	     *  I * I = I
	     *
	     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
	     * of BigNumber(y, b).
	     */
	    P.multipliedBy = P.times = function (y, b) {
	      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
	        base, sqrtBase,
	        x = this,
	        xc = x.c,
	        yc = (y = new BigNumber(y, b)).c;

	      // Either NaN, ±Infinity or ±0?
	      if (!xc || !yc || !xc[0] || !yc[0]) {

	        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
	        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
	          y.c = y.e = y.s = null;
	        } else {
	          y.s *= x.s;

	          // Return ±Infinity if either is ±Infinity.
	          if (!xc || !yc) {
	            y.c = y.e = null;

	          // Return ±0 if either is ±0.
	          } else {
	            y.c = [0];
	            y.e = 0;
	          }
	        }

	        return y;
	      }

	      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
	      y.s *= x.s;
	      xcL = xc.length;
	      ycL = yc.length;

	      // Ensure xc points to longer array and xcL to its length.
	      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

	      // Initialise the result array with zeros.
	      for (i = xcL + ycL, zc = []; i--; zc.push(0));

	      base = BASE;
	      sqrtBase = SQRT_BASE;

	      for (i = ycL; --i >= 0;) {
	        c = 0;
	        ylo = yc[i] % sqrtBase;
	        yhi = yc[i] / sqrtBase | 0;

	        for (k = xcL, j = i + k; j > i;) {
	          xlo = xc[--k] % sqrtBase;
	          xhi = xc[k] / sqrtBase | 0;
	          m = yhi * xlo + xhi * ylo;
	          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
	          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
	          zc[j--] = xlo % base;
	        }

	        zc[j] = c;
	      }

	      if (c) {
	        ++e;
	      } else {
	        zc.splice(0, 1);
	      }

	      return normalise(y, zc, e);
	    };


	    /*
	     * Return a new BigNumber whose value is the value of this BigNumber negated,
	     * i.e. multiplied by -1.
	     */
	    P.negated = function () {
	      var x = new BigNumber(this);
	      x.s = -x.s || null;
	      return x;
	    };


	    /*
	     *  n + 0 = n
	     *  n + N = N
	     *  n + I = I
	     *  0 + n = n
	     *  0 + 0 = 0
	     *  0 + N = N
	     *  0 + I = I
	     *  N + n = N
	     *  N + 0 = N
	     *  N + N = N
	     *  N + I = N
	     *  I + n = I
	     *  I + 0 = I
	     *  I + N = N
	     *  I + I = I
	     *
	     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
	     * BigNumber(y, b).
	     */
	    P.plus = function (y, b) {
	      var t,
	        x = this,
	        a = x.s;

	      y = new BigNumber(y, b);
	      b = y.s;

	      // Either NaN?
	      if (!a || !b) return new BigNumber(NaN);

	      // Signs differ?
	       if (a != b) {
	        y.s = -b;
	        return x.minus(y);
	      }

	      var xe = x.e / LOG_BASE,
	        ye = y.e / LOG_BASE,
	        xc = x.c,
	        yc = y.c;

	      if (!xe || !ye) {

	        // Return ±Infinity if either ±Infinity.
	        if (!xc || !yc) return new BigNumber(a / 0);

	        // Either zero?
	        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
	        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
	      }

	      xe = bitFloor(xe);
	      ye = bitFloor(ye);
	      xc = xc.slice();

	      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
	      if (a = xe - ye) {
	        if (a > 0) {
	          ye = xe;
	          t = yc;
	        } else {
	          a = -a;
	          t = xc;
	        }

	        t.reverse();
	        for (; a--; t.push(0));
	        t.reverse();
	      }

	      a = xc.length;
	      b = yc.length;

	      // Point xc to the longer array, and b to the shorter length.
	      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

	      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
	      for (a = 0; b;) {
	        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
	        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
	      }

	      if (a) {
	        xc = [a].concat(xc);
	        ++ye;
	      }

	      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
	      // ye = MAX_EXP + 1 possible
	      return normalise(y, xc, ye);
	    };


	    /*
	     * If sd is undefined or null or true or false, return the number of significant digits of
	     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
	     * If sd is true include integer-part trailing zeros in the count.
	     *
	     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
	     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
	     * ROUNDING_MODE if rm is omitted.
	     *
	     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
	     *                     boolean: whether to count integer-part trailing zeros: true or false.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
	     */
	    P.precision = P.sd = function (sd, rm) {
	      var c, n, v,
	        x = this;

	      if (sd != null && sd !== !!sd) {
	        intCheck(sd, 1, MAX);
	        if (rm == null) rm = ROUNDING_MODE;
	        else intCheck(rm, 0, 8);

	        return round(new BigNumber(x), sd, rm);
	      }

	      if (!(c = x.c)) return null;
	      v = c.length - 1;
	      n = v * LOG_BASE + 1;

	      if (v = c[v]) {

	        // Subtract the number of trailing zeros of the last element.
	        for (; v % 10 == 0; v /= 10, n--);

	        // Add the number of digits of the first element.
	        for (v = c[0]; v >= 10; v /= 10, n++);
	      }

	      if (sd && x.e + 1 > n) n = x.e + 1;

	      return n;
	    };


	    /*
	     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
	     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
	     *
	     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
	     *
	     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
	     */
	    P.shiftedBy = function (k) {
	      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
	      return this.times('1e' + k);
	    };


	    /*
	     *  sqrt(-n) =  N
	     *  sqrt(N) =  N
	     *  sqrt(-I) =  N
	     *  sqrt(I) =  I
	     *  sqrt(0) =  0
	     *  sqrt(-0) = -0
	     *
	     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
	     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
	     */
	    P.squareRoot = P.sqrt = function () {
	      var m, n, r, rep, t,
	        x = this,
	        c = x.c,
	        s = x.s,
	        e = x.e,
	        dp = DECIMAL_PLACES + 4,
	        half = new BigNumber('0.5');

	      // Negative/NaN/Infinity/zero?
	      if (s !== 1 || !c || !c[0]) {
	        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
	      }

	      // Initial estimate.
	      s = Math.sqrt(+valueOf(x));

	      // Math.sqrt underflow/overflow?
	      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
	      if (s == 0 || s == 1 / 0) {
	        n = coeffToString(c);
	        if ((n.length + e) % 2 == 0) n += '0';
	        s = Math.sqrt(+n);
	        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

	        if (s == 1 / 0) {
	          n = '1e' + e;
	        } else {
	          n = s.toExponential();
	          n = n.slice(0, n.indexOf('e') + 1) + e;
	        }

	        r = new BigNumber(n);
	      } else {
	        r = new BigNumber(s + '');
	      }

	      // Check for zero.
	      // r could be zero if MIN_EXP is changed after the this value was created.
	      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
	      // coeffToString to throw.
	      if (r.c[0]) {
	        e = r.e;
	        s = e + dp;
	        if (s < 3) s = 0;

	        // Newton-Raphson iteration.
	        for (; ;) {
	          t = r;
	          r = half.times(t.plus(div(x, t, dp, 1)));

	          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

	            // The exponent of r may here be one less than the final result exponent,
	            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
	            // are indexed correctly.
	            if (r.e < e) --s;
	            n = n.slice(s - 3, s + 1);

	            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
	            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
	            // iteration.
	            if (n == '9999' || !rep && n == '4999') {

	              // On the first iteration only, check to see if rounding up gives the
	              // exact result as the nines may infinitely repeat.
	              if (!rep) {
	                round(t, t.e + DECIMAL_PLACES + 2, 0);

	                if (t.times(t).eq(x)) {
	                  r = t;
	                  break;
	                }
	              }

	              dp += 4;
	              s += 4;
	              rep = 1;
	            } else {

	              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
	              // result. If not, then there are further digits and m will be truthy.
	              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

	                // Truncate to the first rounding digit.
	                round(r, r.e + DECIMAL_PLACES + 2, 1);
	                m = !r.times(r).eq(x);
	              }

	              break;
	            }
	          }
	        }
	      }

	      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
	    };


	    /*
	     * Return a string representing the value of this BigNumber in exponential notation and
	     * rounded using ROUNDING_MODE to dp fixed decimal places.
	     *
	     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
	     */
	    P.toExponential = function (dp, rm) {
	      if (dp != null) {
	        intCheck(dp, 0, MAX);
	        dp++;
	      }
	      return format(this, dp, rm, 1);
	    };


	    /*
	     * Return a string representing the value of this BigNumber in fixed-point notation rounding
	     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
	     *
	     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
	     * but e.g. (-0.00001).toFixed(0) is '-0'.
	     *
	     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
	     */
	    P.toFixed = function (dp, rm) {
	      if (dp != null) {
	        intCheck(dp, 0, MAX);
	        dp = dp + this.e + 1;
	      }
	      return format(this, dp, rm);
	    };


	    /*
	     * Return a string representing the value of this BigNumber in fixed-point notation rounded
	     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
	     * of the format or FORMAT object (see BigNumber.set).
	     *
	     * The formatting object may contain some or all of the properties shown below.
	     *
	     * FORMAT = {
	     *   prefix: '',
	     *   groupSize: 3,
	     *   secondaryGroupSize: 0,
	     *   groupSeparator: ',',
	     *   decimalSeparator: '.',
	     *   fractionGroupSize: 0,
	     *   fractionGroupSeparator: '\xA0',      // non-breaking space
	     *   suffix: ''
	     * };
	     *
	     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     * [format] {object} Formatting options. See FORMAT pbject above.
	     *
	     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
	     * '[BigNumber Error] Argument not an object: {format}'
	     */
	    P.toFormat = function (dp, rm, format) {
	      var str,
	        x = this;

	      if (format == null) {
	        if (dp != null && rm && typeof rm == 'object') {
	          format = rm;
	          rm = null;
	        } else if (dp && typeof dp == 'object') {
	          format = dp;
	          dp = rm = null;
	        } else {
	          format = FORMAT;
	        }
	      } else if (typeof format != 'object') {
	        throw Error
	          (bignumberError + 'Argument not an object: ' + format);
	      }

	      str = x.toFixed(dp, rm);

	      if (x.c) {
	        var i,
	          arr = str.split('.'),
	          g1 = +format.groupSize,
	          g2 = +format.secondaryGroupSize,
	          groupSeparator = format.groupSeparator || '',
	          intPart = arr[0],
	          fractionPart = arr[1],
	          isNeg = x.s < 0,
	          intDigits = isNeg ? intPart.slice(1) : intPart,
	          len = intDigits.length;

	        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

	        if (g1 > 0 && len > 0) {
	          i = len % g1 || g1;
	          intPart = intDigits.substr(0, i);
	          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
	          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
	          if (isNeg) intPart = '-' + intPart;
	        }

	        str = fractionPart
	         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
	          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
	           '$&' + (format.fractionGroupSeparator || ''))
	          : fractionPart)
	         : intPart;
	      }

	      return (format.prefix || '') + str + (format.suffix || '');
	    };


	    /*
	     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
	     * fraction with an integer numerator and an integer denominator.
	     * The denominator will be a positive non-zero value less than or equal to the specified
	     * maximum denominator. If a maximum denominator is not specified, the denominator will be
	     * the lowest value necessary to represent the number exactly.
	     *
	     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
	     *
	     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
	     */
	    P.toFraction = function (md) {
	      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
	        x = this,
	        xc = x.c;

	      if (md != null) {
	        n = new BigNumber(md);

	        // Throw if md is less than one or is not an integer, unless it is Infinity.
	        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
	          throw Error
	            (bignumberError + 'Argument ' +
	              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
	        }
	      }

	      if (!xc) return new BigNumber(x);

	      d = new BigNumber(ONE);
	      n1 = d0 = new BigNumber(ONE);
	      d1 = n0 = new BigNumber(ONE);
	      s = coeffToString(xc);

	      // Determine initial denominator.
	      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
	      e = d.e = s.length - x.e - 1;
	      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
	      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

	      exp = MAX_EXP;
	      MAX_EXP = 1 / 0;
	      n = new BigNumber(s);

	      // n0 = d1 = 0
	      n0.c[0] = 0;

	      for (; ;)  {
	        q = div(n, d, 0, 1);
	        d2 = d0.plus(q.times(d1));
	        if (d2.comparedTo(md) == 1) break;
	        d0 = d1;
	        d1 = d2;
	        n1 = n0.plus(q.times(d2 = n1));
	        n0 = d2;
	        d = n.minus(q.times(d2 = d));
	        n = d2;
	      }

	      d2 = div(md.minus(d0), d1, 0, 1);
	      n0 = n0.plus(d2.times(n1));
	      d0 = d0.plus(d2.times(d1));
	      n0.s = n1.s = x.s;
	      e = e * 2;

	      // Determine which fraction is closer to x, n0/d0 or n1/d1
	      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
	          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

	      MAX_EXP = exp;

	      return r;
	    };


	    /*
	     * Return the value of this BigNumber converted to a number primitive.
	     */
	    P.toNumber = function () {
	      return +valueOf(this);
	    };


	    /*
	     * Return a string representing the value of this BigNumber rounded to sd significant digits
	     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
	     * necessary to represent the integer part of the value in fixed-point notation, then use
	     * exponential notation.
	     *
	     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
	     */
	    P.toPrecision = function (sd, rm) {
	      if (sd != null) intCheck(sd, 1, MAX);
	      return format(this, sd, rm, 2);
	    };


	    /*
	     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
	     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
	     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
	     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
	     * TO_EXP_NEG, return exponential notation.
	     *
	     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
	     *
	     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
	     */
	    P.toString = function (b) {
	      var str,
	        n = this,
	        s = n.s,
	        e = n.e;

	      // Infinity or NaN?
	      if (e === null) {
	        if (s) {
	          str = 'Infinity';
	          if (s < 0) str = '-' + str;
	        } else {
	          str = 'NaN';
	        }
	      } else {
	        if (b == null) {
	          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
	           ? toExponential(coeffToString(n.c), e)
	           : toFixedPoint(coeffToString(n.c), e, '0');
	        } else if (b === 10) {
	          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
	          str = toFixedPoint(coeffToString(n.c), n.e, '0');
	        } else {
	          intCheck(b, 2, ALPHABET.length, 'Base');
	          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
	        }

	        if (s < 0 && n.c[0]) str = '-' + str;
	      }

	      return str;
	    };


	    /*
	     * Return as toString, but do not accept a base argument, and include the minus sign for
	     * negative zero.
	     */
	    P.valueOf = P.toJSON = function () {
	      return valueOf(this);
	    };


	    P._isBigNumber = true;

	    if (hasSymbol) {
	      P[Symbol.toStringTag] = 'BigNumber';

	      // Node.js v10.12.0+
	      P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;
	    }

	    if (configObject != null) BigNumber.set(configObject);

	    return BigNumber;
	  }


	  // PRIVATE HELPER FUNCTIONS

	  // These functions don't need access to variables,
	  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


	  function bitFloor(n) {
	    var i = n | 0;
	    return n > 0 || n === i ? i : i - 1;
	  }


	  // Return a coefficient array as a string of base 10 digits.
	  function coeffToString(a) {
	    var s, z,
	      i = 1,
	      j = a.length,
	      r = a[0] + '';

	    for (; i < j;) {
	      s = a[i++] + '';
	      z = LOG_BASE - s.length;
	      for (; z--; s = '0' + s);
	      r += s;
	    }

	    // Determine trailing zeros.
	    for (j = r.length; r.charCodeAt(--j) === 48;);

	    return r.slice(0, j + 1 || 1);
	  }


	  // Compare the value of BigNumbers x and y.
	  function compare(x, y) {
	    var a, b,
	      xc = x.c,
	      yc = y.c,
	      i = x.s,
	      j = y.s,
	      k = x.e,
	      l = y.e;

	    // Either NaN?
	    if (!i || !j) return null;

	    a = xc && !xc[0];
	    b = yc && !yc[0];

	    // Either zero?
	    if (a || b) return a ? b ? 0 : -j : i;

	    // Signs differ?
	    if (i != j) return i;

	    a = i < 0;
	    b = k == l;

	    // Either Infinity?
	    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

	    // Compare exponents.
	    if (!b) return k > l ^ a ? 1 : -1;

	    j = (k = xc.length) < (l = yc.length) ? k : l;

	    // Compare digit by digit.
	    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

	    // Compare lengths.
	    return k == l ? 0 : k > l ^ a ? 1 : -1;
	  }


	  /*
	   * Check that n is a primitive number, an integer, and in range, otherwise throw.
	   */
	  function intCheck(n, min, max, name) {
	    if (n < min || n > max || n !== mathfloor(n)) {
	      throw Error
	       (bignumberError + (name || 'Argument') + (typeof n == 'number'
	         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
	         : ' not a primitive number: ') + String(n));
	    }
	  }


	  // Assumes finite n.
	  function isOdd(n) {
	    var k = n.c.length - 1;
	    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
	  }


	  function toExponential(str, e) {
	    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
	     (e < 0 ? 'e' : 'e+') + e;
	  }


	  function toFixedPoint(str, e, z) {
	    var len, zs;

	    // Negative exponent?
	    if (e < 0) {

	      // Prepend zeros.
	      for (zs = z + '.'; ++e; zs += z);
	      str = zs + str;

	    // Positive exponent
	    } else {
	      len = str.length;

	      // Append zeros.
	      if (++e > len) {
	        for (zs = z, e -= len; --e; zs += z);
	        str += zs;
	      } else if (e < len) {
	        str = str.slice(0, e) + '.' + str.slice(e);
	      }
	    }

	    return str;
	  }


	  // EXPORT


	  BigNumber = clone();
	  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

	  // AMD.
	  if ( module.exports) {
	    module.exports = BigNumber;

	  // Browser.
	  } else {
	    if (!globalObject) {
	      globalObject = typeof self != 'undefined' && self ? self : window;
	    }

	    globalObject.BigNumber = BigNumber;
	  }
	})(commonjsGlobal);
	});

	var numeral = createCommonjsModule(function (module) {
	/*! @preserve
	 * numeral.js
	 * version : 2.0.6
	 * author : Adam Draper
	 * license : MIT
	 * http://adamwdraper.github.com/Numeral-js/
	 */

	(function (global, factory) {
	    if ( module.exports) {
	        module.exports = factory();
	    } else {
	        global.numeral = factory();
	    }
	}(commonjsGlobal, function () {
	    /************************************
	        Variables
	    ************************************/

	    var numeral,
	        _,
	        VERSION = '2.0.6',
	        formats = {},
	        locales = {},
	        defaults = {
	            currentLocale: 'en',
	            zeroFormat: null,
	            nullFormat: null,
	            defaultFormat: '0,0',
	            scalePercentBy100: true
	        },
	        options = {
	            currentLocale: defaults.currentLocale,
	            zeroFormat: defaults.zeroFormat,
	            nullFormat: defaults.nullFormat,
	            defaultFormat: defaults.defaultFormat,
	            scalePercentBy100: defaults.scalePercentBy100
	        };


	    /************************************
	        Constructors
	    ************************************/

	    // Numeral prototype object
	    function Numeral(input, number) {
	        this._input = input;

	        this._value = number;
	    }

	    numeral = function(input) {
	        var value,
	            kind,
	            unformatFunction,
	            regexp;

	        if (numeral.isNumeral(input)) {
	            value = input.value();
	        } else if (input === 0 || typeof input === 'undefined') {
	            value = 0;
	        } else if (input === null || _.isNaN(input)) {
	            value = null;
	        } else if (typeof input === 'string') {
	            if (options.zeroFormat && input === options.zeroFormat) {
	                value = 0;
	            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {
	                value = null;
	            } else {
	                for (kind in formats) {
	                    regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;

	                    if (regexp && input.match(regexp)) {
	                        unformatFunction = formats[kind].unformat;

	                        break;
	                    }
	                }

	                unformatFunction = unformatFunction || numeral._.stringToNumber;

	                value = unformatFunction(input);
	            }
	        } else {
	            value = Number(input)|| null;
	        }

	        return new Numeral(input, value);
	    };

	    // version number
	    numeral.version = VERSION;

	    // compare numeral object
	    numeral.isNumeral = function(obj) {
	        return obj instanceof Numeral;
	    };

	    // helper functions
	    numeral._ = _ = {
	        // formats numbers separators, decimals places, signs, abbreviations
	        numberToFormat: function(value, format, roundingFunction) {
	            var locale = locales[numeral.options.currentLocale],
	                negP = false,
	                optDec = false,
	                leadingCount = 0,
	                abbr = '',
	                trillion = 1000000000000,
	                billion = 1000000000,
	                million = 1000000,
	                thousand = 1000,
	                decimal = '',
	                neg = false,
	                abbrForce, // force abbreviation
	                abs,
	                int,
	                precision,
	                signed,
	                thousands,
	                output;

	            // make sure we never format a null value
	            value = value || 0;

	            abs = Math.abs(value);

	            // see if we should use parentheses for negative number or if we should prefix with a sign
	            // if both are present we default to parentheses
	            if (numeral._.includes(format, '(')) {
	                negP = true;
	                format = format.replace(/[\(|\)]/g, '');
	            } else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {
	                signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;
	                format = format.replace(/[\+|\-]/g, '');
	            }

	            // see if abbreviation is wanted
	            if (numeral._.includes(format, 'a')) {
	                abbrForce = format.match(/a(k|m|b|t)?/);

	                abbrForce = abbrForce ? abbrForce[1] : false;

	                // check for space before abbreviation
	                if (numeral._.includes(format, ' a')) {
	                    abbr = ' ';
	                }

	                format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');

	                if (abs >= trillion && !abbrForce || abbrForce === 't') {
	                    // trillion
	                    abbr += locale.abbreviations.trillion;
	                    value = value / trillion;
	                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === 'b') {
	                    // billion
	                    abbr += locale.abbreviations.billion;
	                    value = value / billion;
	                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === 'm') {
	                    // million
	                    abbr += locale.abbreviations.million;
	                    value = value / million;
	                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === 'k') {
	                    // thousand
	                    abbr += locale.abbreviations.thousand;
	                    value = value / thousand;
	                }
	            }

	            // check for optional decimals
	            if (numeral._.includes(format, '[.]')) {
	                optDec = true;
	                format = format.replace('[.]', '.');
	            }

	            // break number and format
	            int = value.toString().split('.')[0];
	            precision = format.split('.')[1];
	            thousands = format.indexOf(',');
	            leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;

	            if (precision) {
	                if (numeral._.includes(precision, '[')) {
	                    precision = precision.replace(']', '');
	                    precision = precision.split('[');
	                    decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
	                } else {
	                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);
	                }

	                int = decimal.split('.')[0];

	                if (numeral._.includes(decimal, '.')) {
	                    decimal = locale.delimiters.decimal + decimal.split('.')[1];
	                } else {
	                    decimal = '';
	                }

	                if (optDec && Number(decimal.slice(1)) === 0) {
	                    decimal = '';
	                }
	            } else {
	                int = numeral._.toFixed(value, 0, roundingFunction);
	            }

	            // check abbreviation again after rounding
	            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {
	                int = String(Number(int) / 1000);

	                switch (abbr) {
	                    case locale.abbreviations.thousand:
	                        abbr = locale.abbreviations.million;
	                        break;
	                    case locale.abbreviations.million:
	                        abbr = locale.abbreviations.billion;
	                        break;
	                    case locale.abbreviations.billion:
	                        abbr = locale.abbreviations.trillion;
	                        break;
	                }
	            }


	            // format number
	            if (numeral._.includes(int, '-')) {
	                int = int.slice(1);
	                neg = true;
	            }

	            if (int.length < leadingCount) {
	                for (var i = leadingCount - int.length; i > 0; i--) {
	                    int = '0' + int;
	                }
	            }

	            if (thousands > -1) {
	                int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + locale.delimiters.thousands);
	            }

	            if (format.indexOf('.') === 0) {
	                int = '';
	            }

	            output = int + decimal + (abbr ? abbr : '');

	            if (negP) {
	                output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');
	            } else {
	                if (signed >= 0) {
	                    output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');
	                } else if (neg) {
	                    output = '-' + output;
	                }
	            }

	            return output;
	        },
	        // unformats numbers separators, decimals places, signs, abbreviations
	        stringToNumber: function(string) {
	            var locale = locales[options.currentLocale],
	                stringOriginal = string,
	                abbreviations = {
	                    thousand: 3,
	                    million: 6,
	                    billion: 9,
	                    trillion: 12
	                },
	                abbreviation,
	                value,
	                regexp;

	            if (options.zeroFormat && string === options.zeroFormat) {
	                value = 0;
	            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {
	                value = null;
	            } else {
	                value = 1;

	                if (locale.delimiters.decimal !== '.') {
	                    string = string.replace(/\./g, '').replace(locale.delimiters.decimal, '.');
	                }

	                for (abbreviation in abbreviations) {
	                    regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\)|(\\' + locale.currency.symbol + ')?(?:\\))?)?$');

	                    if (stringOriginal.match(regexp)) {
	                        value *= Math.pow(10, abbreviations[abbreviation]);
	                        break;
	                    }
	                }

	                // check for negative number
	                value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;

	                // remove non numbers
	                string = string.replace(/[^0-9\.]+/g, '');

	                value *= Number(string);
	            }

	            return value;
	        },
	        isNaN: function(value) {
	            return typeof value === 'number' && isNaN(value);
	        },
	        includes: function(string, search) {
	            return string.indexOf(search) !== -1;
	        },
	        insert: function(string, subString, start) {
	            return string.slice(0, start) + subString + string.slice(start);
	        },
	        reduce: function(array, callback /*, initialValue*/) {
	            if (this === null) {
	                throw new TypeError('Array.prototype.reduce called on null or undefined');
	            }

	            if (typeof callback !== 'function') {
	                throw new TypeError(callback + ' is not a function');
	            }

	            var t = Object(array),
	                len = t.length >>> 0,
	                k = 0,
	                value;

	            if (arguments.length === 3) {
	                value = arguments[2];
	            } else {
	                while (k < len && !(k in t)) {
	                    k++;
	                }

	                if (k >= len) {
	                    throw new TypeError('Reduce of empty array with no initial value');
	                }

	                value = t[k++];
	            }
	            for (; k < len; k++) {
	                if (k in t) {
	                    value = callback(value, t[k], k, t);
	                }
	            }
	            return value;
	        },
	        /**
	         * Computes the multiplier necessary to make x >= 1,
	         * effectively eliminating miscalculations caused by
	         * finite precision.
	         */
	        multiplier: function (x) {
	            var parts = x.toString().split('.');

	            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
	        },
	        /**
	         * Given a variable number of arguments, returns the maximum
	         * multiplier that must be used to normalize an operation involving
	         * all of them.
	         */
	        correctionFactor: function () {
	            var args = Array.prototype.slice.call(arguments);

	            return args.reduce(function(accum, next) {
	                var mn = _.multiplier(next);
	                return accum > mn ? accum : mn;
	            }, 1);
	        },
	        /**
	         * Implementation of toFixed() that treats floats more like decimals
	         *
	         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
	         * problems for accounting- and finance-related software.
	         */
	        toFixed: function(value, maxDecimals, roundingFunction, optionals) {
	            var splitValue = value.toString().split('.'),
	                minDecimals = maxDecimals - (optionals || 0),
	                boundedPrecision,
	                optionalsRegExp,
	                power,
	                output;

	            // Use the smallest precision value possible to avoid errors from floating point representation
	            if (splitValue.length === 2) {
	              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
	            } else {
	              boundedPrecision = minDecimals;
	            }

	            power = Math.pow(10, boundedPrecision);

	            // Multiply up by precision, round accurately, then divide and use native toFixed():
	            output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);

	            if (optionals > maxDecimals - boundedPrecision) {
	                optionalsRegExp = new RegExp('\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');
	                output = output.replace(optionalsRegExp, '');
	            }

	            return output;
	        }
	    };

	    // avaliable options
	    numeral.options = options;

	    // avaliable formats
	    numeral.formats = formats;

	    // avaliable formats
	    numeral.locales = locales;

	    // This function sets the current locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    numeral.locale = function(key) {
	        if (key) {
	            options.currentLocale = key.toLowerCase();
	        }

	        return options.currentLocale;
	    };

	    // This function provides access to the loaded locale data.  If
	    // no arguments are passed in, it will simply return the current
	    // global locale object.
	    numeral.localeData = function(key) {
	        if (!key) {
	            return locales[options.currentLocale];
	        }

	        key = key.toLowerCase();

	        if (!locales[key]) {
	            throw new Error('Unknown locale : ' + key);
	        }

	        return locales[key];
	    };

	    numeral.reset = function() {
	        for (var property in defaults) {
	            options[property] = defaults[property];
	        }
	    };

	    numeral.zeroFormat = function(format) {
	        options.zeroFormat = typeof(format) === 'string' ? format : null;
	    };

	    numeral.nullFormat = function (format) {
	        options.nullFormat = typeof(format) === 'string' ? format : null;
	    };

	    numeral.defaultFormat = function(format) {
	        options.defaultFormat = typeof(format) === 'string' ? format : '0.0';
	    };

	    numeral.register = function(type, name, format) {
	        name = name.toLowerCase();

	        if (this[type + 's'][name]) {
	            throw new TypeError(name + ' ' + type + ' already registered.');
	        }

	        this[type + 's'][name] = format;

	        return format;
	    };


	    numeral.validate = function(val, culture) {
	        var _decimalSep,
	            _thousandSep,
	            _currSymbol,
	            _valArray,
	            _abbrObj,
	            _thousandRegEx,
	            localeData,
	            temp;

	        //coerce val to string
	        if (typeof val !== 'string') {
	            val += '';

	            if (console.warn) {
	                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
	            }
	        }

	        //trim whitespaces from either sides
	        val = val.trim();

	        //if val is just digits return true
	        if (!!val.match(/^\d+$/)) {
	            return true;
	        }

	        //if val is empty return false
	        if (val === '') {
	            return false;
	        }

	        //get the decimal and thousands separator from numeral.localeData
	        try {
	            //check if the culture is understood by numeral. if not, default it to current locale
	            localeData = numeral.localeData(culture);
	        } catch (e) {
	            localeData = numeral.localeData(numeral.locale());
	        }

	        //setup the delimiters and currency symbol based on culture/locale
	        _currSymbol = localeData.currency.symbol;
	        _abbrObj = localeData.abbreviations;
	        _decimalSep = localeData.delimiters.decimal;
	        if (localeData.delimiters.thousands === '.') {
	            _thousandSep = '\\.';
	        } else {
	            _thousandSep = localeData.delimiters.thousands;
	        }

	        // validating currency symbol
	        temp = val.match(/^[^\d]+/);
	        if (temp !== null) {
	            val = val.substr(1);
	            if (temp[0] !== _currSymbol) {
	                return false;
	            }
	        }

	        //validating abbreviation symbol
	        temp = val.match(/[^\d]+$/);
	        if (temp !== null) {
	            val = val.slice(0, -1);
	            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
	                return false;
	            }
	        }

	        _thousandRegEx = new RegExp(_thousandSep + '{2}');

	        if (!val.match(/[^\d.,]/g)) {
	            _valArray = val.split(_decimalSep);
	            if (_valArray.length > 2) {
	                return false;
	            } else {
	                if (_valArray.length < 2) {
	                    return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx));
	                } else {
	                    if (_valArray[0].length === 1) {
	                        return ( !! _valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
	                    } else {
	                        return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
	                    }
	                }
	            }
	        }

	        return false;
	    };


	    /************************************
	        Numeral Prototype
	    ************************************/

	    numeral.fn = Numeral.prototype = {
	        clone: function() {
	            return numeral(this);
	        },
	        format: function(inputString, roundingFunction) {
	            var value = this._value,
	                format = inputString || options.defaultFormat,
	                kind,
	                output,
	                formatFunction;

	            // make sure we have a roundingFunction
	            roundingFunction = roundingFunction || Math.round;

	            // format based on value
	            if (value === 0 && options.zeroFormat !== null) {
	                output = options.zeroFormat;
	            } else if (value === null && options.nullFormat !== null) {
	                output = options.nullFormat;
	            } else {
	                for (kind in formats) {
	                    if (format.match(formats[kind].regexps.format)) {
	                        formatFunction = formats[kind].format;

	                        break;
	                    }
	                }

	                formatFunction = formatFunction || numeral._.numberToFormat;

	                output = formatFunction(value, format, roundingFunction);
	            }

	            return output;
	        },
	        value: function() {
	            return this._value;
	        },
	        input: function() {
	            return this._input;
	        },
	        set: function(value) {
	            this._value = Number(value);

	            return this;
	        },
	        add: function(value) {
	            var corrFactor = _.correctionFactor.call(null, this._value, value);

	            function cback(accum, curr, currI, O) {
	                return accum + Math.round(corrFactor * curr);
	            }

	            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;

	            return this;
	        },
	        subtract: function(value) {
	            var corrFactor = _.correctionFactor.call(null, this._value, value);

	            function cback(accum, curr, currI, O) {
	                return accum - Math.round(corrFactor * curr);
	            }

	            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;

	            return this;
	        },
	        multiply: function(value) {
	            function cback(accum, curr, currI, O) {
	                var corrFactor = _.correctionFactor(accum, curr);
	                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
	            }

	            this._value = _.reduce([this._value, value], cback, 1);

	            return this;
	        },
	        divide: function(value) {
	            function cback(accum, curr, currI, O) {
	                var corrFactor = _.correctionFactor(accum, curr);
	                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
	            }

	            this._value = _.reduce([this._value, value], cback);

	            return this;
	        },
	        difference: function(value) {
	            return Math.abs(numeral(this._value).subtract(value).value());
	        }
	    };

	    /************************************
	        Default Locale && Format
	    ************************************/

	    numeral.register('locale', 'en', {
	        delimiters: {
	            thousands: ',',
	            decimal: '.'
	        },
	        abbreviations: {
	            thousand: 'k',
	            million: 'm',
	            billion: 'b',
	            trillion: 't'
	        },
	        ordinal: function(number) {
	            var b = number % 10;
	            return (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	        },
	        currency: {
	            symbol: '$'
	        }
	    });

	    

	(function() {
	        numeral.register('format', 'bps', {
	            regexps: {
	                format: /(BPS)/,
	                unformat: /(BPS)/
	            },
	            format: function(value, format, roundingFunction) {
	                var space = numeral._.includes(format, ' BPS') ? ' ' : '',
	                    output;

	                value = value * 10000;

	                // check for space before BPS
	                format = format.replace(/\s?BPS/, '');

	                output = numeral._.numberToFormat(value, format, roundingFunction);

	                if (numeral._.includes(output, ')')) {
	                    output = output.split('');

	                    output.splice(-1, 0, space + 'BPS');

	                    output = output.join('');
	                } else {
	                    output = output + space + 'BPS';
	                }

	                return output;
	            },
	            unformat: function(string) {
	                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);
	            }
	        });
	})();


	(function() {
	        var decimal = {
	            base: 1000,
	            suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
	        },
	        binary = {
	            base: 1024,
	            suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
	        };

	    var allSuffixes =  decimal.suffixes.concat(binary.suffixes.filter(function (item) {
	            return decimal.suffixes.indexOf(item) < 0;
	        }));
	        var unformatRegex = allSuffixes.join('|');
	        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)
	        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';

	    numeral.register('format', 'bytes', {
	        regexps: {
	            format: /([0\s]i?b)/,
	            unformat: new RegExp(unformatRegex)
	        },
	        format: function(value, format, roundingFunction) {
	            var output,
	                bytes = numeral._.includes(format, 'ib') ? binary : decimal,
	                suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '',
	                power,
	                min,
	                max;

	            // check for space before
	            format = format.replace(/\s?i?b/, '');

	            for (power = 0; power <= bytes.suffixes.length; power++) {
	                min = Math.pow(bytes.base, power);
	                max = Math.pow(bytes.base, power + 1);

	                if (value === null || value === 0 || value >= min && value < max) {
	                    suffix += bytes.suffixes[power];

	                    if (min > 0) {
	                        value = value / min;
	                    }

	                    break;
	                }
	            }

	            output = numeral._.numberToFormat(value, format, roundingFunction);

	            return output + suffix;
	        },
	        unformat: function(string) {
	            var value = numeral._.stringToNumber(string),
	                power,
	                bytesMultiplier;

	            if (value) {
	                for (power = decimal.suffixes.length - 1; power >= 0; power--) {
	                    if (numeral._.includes(string, decimal.suffixes[power])) {
	                        bytesMultiplier = Math.pow(decimal.base, power);

	                        break;
	                    }

	                    if (numeral._.includes(string, binary.suffixes[power])) {
	                        bytesMultiplier = Math.pow(binary.base, power);

	                        break;
	                    }
	                }

	                value *= (bytesMultiplier || 1);
	            }

	            return value;
	        }
	    });
	})();


	(function() {
	        numeral.register('format', 'currency', {
	        regexps: {
	            format: /(\$)/
	        },
	        format: function(value, format, roundingFunction) {
	            var locale = numeral.locales[numeral.options.currentLocale],
	                symbols = {
	                    before: format.match(/^([\+|\-|\(|\s|\$]*)/)[0],
	                    after: format.match(/([\+|\-|\)|\s|\$]*)$/)[0]
	                },
	                output,
	                symbol,
	                i;

	            // strip format of spaces and $
	            format = format.replace(/\s?\$\s?/, '');

	            // format the number
	            output = numeral._.numberToFormat(value, format, roundingFunction);

	            // update the before and after based on value
	            if (value >= 0) {
	                symbols.before = symbols.before.replace(/[\-\(]/, '');
	                symbols.after = symbols.after.replace(/[\-\)]/, '');
	            } else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {
	                symbols.before = '-' + symbols.before;
	            }

	            // loop through each before symbol
	            for (i = 0; i < symbols.before.length; i++) {
	                symbol = symbols.before[i];

	                switch (symbol) {
	                    case '$':
	                        output = numeral._.insert(output, locale.currency.symbol, i);
	                        break;
	                    case ' ':
	                        output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);
	                        break;
	                }
	            }

	            // loop through each after symbol
	            for (i = symbols.after.length - 1; i >= 0; i--) {
	                symbol = symbols.after[i];

	                switch (symbol) {
	                    case '$':
	                        output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));
	                        break;
	                    case ' ':
	                        output = i === symbols.after.length - 1 ? output + ' ' : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));
	                        break;
	                }
	            }


	            return output;
	        }
	    });
	})();


	(function() {
	        numeral.register('format', 'exponential', {
	        regexps: {
	            format: /(e\+|e-)/,
	            unformat: /(e\+|e-)/
	        },
	        format: function(value, format, roundingFunction) {
	            var output,
	                exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0',
	                parts = exponential.split('e');

	            format = format.replace(/e[\+|\-]{1}0/, '');

	            output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);

	            return output + 'e' + parts[1];
	        },
	        unformat: function(string) {
	            var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'),
	                value = Number(parts[0]),
	                power = Number(parts[1]);

	            power = numeral._.includes(string, 'e-') ? power *= -1 : power;

	            function cback(accum, curr, currI, O) {
	                var corrFactor = numeral._.correctionFactor(accum, curr),
	                    num = (accum * corrFactor) * (curr * corrFactor) / (corrFactor * corrFactor);
	                return num;
	            }

	            return numeral._.reduce([value, Math.pow(10, power)], cback, 1);
	        }
	    });
	})();


	(function() {
	        numeral.register('format', 'ordinal', {
	        regexps: {
	            format: /(o)/
	        },
	        format: function(value, format, roundingFunction) {
	            var locale = numeral.locales[numeral.options.currentLocale],
	                output,
	                ordinal = numeral._.includes(format, ' o') ? ' ' : '';

	            // check for space before
	            format = format.replace(/\s?o/, '');

	            ordinal += locale.ordinal(value);

	            output = numeral._.numberToFormat(value, format, roundingFunction);

	            return output + ordinal;
	        }
	    });
	})();


	(function() {
	        numeral.register('format', 'percentage', {
	        regexps: {
	            format: /(%)/,
	            unformat: /(%)/
	        },
	        format: function(value, format, roundingFunction) {
	            var space = numeral._.includes(format, ' %') ? ' ' : '',
	                output;

	            if (numeral.options.scalePercentBy100) {
	                value = value * 100;
	            }

	            // check for space before %
	            format = format.replace(/\s?\%/, '');

	            output = numeral._.numberToFormat(value, format, roundingFunction);

	            if (numeral._.includes(output, ')')) {
	                output = output.split('');

	                output.splice(-1, 0, space + '%');

	                output = output.join('');
	            } else {
	                output = output + space + '%';
	            }

	            return output;
	        },
	        unformat: function(string) {
	            var number = numeral._.stringToNumber(string);
	            if (numeral.options.scalePercentBy100) {
	                return number * 0.01;
	            }
	            return number;
	        }
	    });
	})();


	(function() {
	        numeral.register('format', 'time', {
	        regexps: {
	            format: /(:)/,
	            unformat: /(:)/
	        },
	        format: function(value, format, roundingFunction) {
	            var hours = Math.floor(value / 60 / 60),
	                minutes = Math.floor((value - (hours * 60 * 60)) / 60),
	                seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));

	            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
	        },
	        unformat: function(string) {
	            var timeArray = string.split(':'),
	                seconds = 0;

	            // turn hours and minutes into seconds and add them all up
	            if (timeArray.length === 3) {
	                // hours
	                seconds = seconds + (Number(timeArray[0]) * 60 * 60);
	                // minutes
	                seconds = seconds + (Number(timeArray[1]) * 60);
	                // seconds
	                seconds = seconds + Number(timeArray[2]);
	            } else if (timeArray.length === 2) {
	                // minutes
	                seconds = seconds + (Number(timeArray[0]) * 60);
	                // seconds
	                seconds = seconds + Number(timeArray[1]);
	            }
	            return Number(seconds);
	        }
	    });
	})();

	return numeral;
	}));
	});

	var moment = createCommonjsModule(function (module, exports) {
	(function (global, factory) {
	     module.exports = factory() ;
	}(commonjsGlobal, (function () {
	    var hookCallback;

	    function hooks () {
	        return hookCallback.apply(null, arguments);
	    }

	    // This is done to register the method called with moment()
	    // without creating circular dependencies.
	    function setHookCallback (callback) {
	        hookCallback = callback;
	    }

	    function isArray(input) {
	        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	    }

	    function isObject(input) {
	        // IE8 will treat undefined and null as object if it wasn't for
	        // input != null
	        return input != null && Object.prototype.toString.call(input) === '[object Object]';
	    }

	    function isObjectEmpty(obj) {
	        if (Object.getOwnPropertyNames) {
	            return (Object.getOwnPropertyNames(obj).length === 0);
	        } else {
	            var k;
	            for (k in obj) {
	                if (obj.hasOwnProperty(k)) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }

	    function isUndefined(input) {
	        return input === void 0;
	    }

	    function isNumber(input) {
	        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
	    }

	    function isDate(input) {
	        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	    }

	    function map(arr, fn) {
	        var res = [], i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }

	    function hasOwnProp(a, b) {
	        return Object.prototype.hasOwnProperty.call(a, b);
	    }

	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }

	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }

	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }

	        return a;
	    }

	    function createUTC (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, true).utc();
	    }

	    function defaultParsingFlags() {
	        // We need to deep clone this object.
	        return {
	            empty           : false,
	            unusedTokens    : [],
	            unusedInput     : [],
	            overflow        : -2,
	            charsLeftOver   : 0,
	            nullInput       : false,
	            invalidMonth    : null,
	            invalidFormat   : false,
	            userInvalidated : false,
	            iso             : false,
	            parsedDateParts : [],
	            meridiem        : null,
	            rfc2822         : false,
	            weekdayMismatch : false
	        };
	    }

	    function getParsingFlags(m) {
	        if (m._pf == null) {
	            m._pf = defaultParsingFlags();
	        }
	        return m._pf;
	    }

	    var some;
	    if (Array.prototype.some) {
	        some = Array.prototype.some;
	    } else {
	        some = function (fun) {
	            var t = Object(this);
	            var len = t.length >>> 0;

	            for (var i = 0; i < len; i++) {
	                if (i in t && fun.call(this, t[i], i, t)) {
	                    return true;
	                }
	            }

	            return false;
	        };
	    }

	    function isValid(m) {
	        if (m._isValid == null) {
	            var flags = getParsingFlags(m);
	            var parsedParts = some.call(flags.parsedDateParts, function (i) {
	                return i != null;
	            });
	            var isNowValid = !isNaN(m._d.getTime()) &&
	                flags.overflow < 0 &&
	                !flags.empty &&
	                !flags.invalidMonth &&
	                !flags.invalidWeekday &&
	                !flags.weekdayMismatch &&
	                !flags.nullInput &&
	                !flags.invalidFormat &&
	                !flags.userInvalidated &&
	                (!flags.meridiem || (flags.meridiem && parsedParts));

	            if (m._strict) {
	                isNowValid = isNowValid &&
	                    flags.charsLeftOver === 0 &&
	                    flags.unusedTokens.length === 0 &&
	                    flags.bigHour === undefined;
	            }

	            if (Object.isFrozen == null || !Object.isFrozen(m)) {
	                m._isValid = isNowValid;
	            }
	            else {
	                return isNowValid;
	            }
	        }
	        return m._isValid;
	    }

	    function createInvalid (flags) {
	        var m = createUTC(NaN);
	        if (flags != null) {
	            extend(getParsingFlags(m), flags);
	        }
	        else {
	            getParsingFlags(m).userInvalidated = true;
	        }

	        return m;
	    }

	    // Plugins that add properties should also add the key here (null value),
	    // so we can properly clone ourselves.
	    var momentProperties = hooks.momentProperties = [];

	    function copyConfig(to, from) {
	        var i, prop, val;

	        if (!isUndefined(from._isAMomentObject)) {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (!isUndefined(from._i)) {
	            to._i = from._i;
	        }
	        if (!isUndefined(from._f)) {
	            to._f = from._f;
	        }
	        if (!isUndefined(from._l)) {
	            to._l = from._l;
	        }
	        if (!isUndefined(from._strict)) {
	            to._strict = from._strict;
	        }
	        if (!isUndefined(from._tzm)) {
	            to._tzm = from._tzm;
	        }
	        if (!isUndefined(from._isUTC)) {
	            to._isUTC = from._isUTC;
	        }
	        if (!isUndefined(from._offset)) {
	            to._offset = from._offset;
	        }
	        if (!isUndefined(from._pf)) {
	            to._pf = getParsingFlags(from);
	        }
	        if (!isUndefined(from._locale)) {
	            to._locale = from._locale;
	        }

	        if (momentProperties.length > 0) {
	            for (i = 0; i < momentProperties.length; i++) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (!isUndefined(val)) {
	                    to[prop] = val;
	                }
	            }
	        }

	        return to;
	    }

	    var updateInProgress = false;

	    // Moment prototype object
	    function Moment(config) {
	        copyConfig(this, config);
	        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	        if (!this.isValid()) {
	            this._d = new Date(NaN);
	        }
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            hooks.updateOffset(this);
	            updateInProgress = false;
	        }
	    }

	    function isMoment (obj) {
	        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	    }

	    function absFloor (number) {
	        if (number < 0) {
	            // -0 -> 0
	            return Math.ceil(number) || 0;
	        } else {
	            return Math.floor(number);
	        }
	    }

	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;

	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            value = absFloor(coercedNumber);
	        }

	        return value;
	    }

	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }

	    function warn(msg) {
	        if (hooks.suppressDeprecationWarnings === false &&
	                (typeof console !==  'undefined') && console.warn) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }

	    function deprecate(msg, fn) {
	        var firstTime = true;

	        return extend(function () {
	            if (hooks.deprecationHandler != null) {
	                hooks.deprecationHandler(null, msg);
	            }
	            if (firstTime) {
	                var args = [];
	                var arg;
	                for (var i = 0; i < arguments.length; i++) {
	                    arg = '';
	                    if (typeof arguments[i] === 'object') {
	                        arg += '\n[' + i + '] ';
	                        for (var key in arguments[0]) {
	                            arg += key + ': ' + arguments[0][key] + ', ';
	                        }
	                        arg = arg.slice(0, -2); // Remove trailing comma and space
	                    } else {
	                        arg = arguments[i];
	                    }
	                    args.push(arg);
	                }
	                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }

	    var deprecations = {};

	    function deprecateSimple(name, msg) {
	        if (hooks.deprecationHandler != null) {
	            hooks.deprecationHandler(name, msg);
	        }
	        if (!deprecations[name]) {
	            warn(msg);
	            deprecations[name] = true;
	        }
	    }

	    hooks.suppressDeprecationWarnings = false;
	    hooks.deprecationHandler = null;

	    function isFunction(input) {
	        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	    }

	    function set (config) {
	        var prop, i;
	        for (i in config) {
	            prop = config[i];
	            if (isFunction(prop)) {
	                this[i] = prop;
	            } else {
	                this['_' + i] = prop;
	            }
	        }
	        this._config = config;
	        // Lenient ordinal parsing accepts just a number in addition to
	        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
	        // TODO: Remove "ordinalParse" fallback in next major release.
	        this._dayOfMonthOrdinalParseLenient = new RegExp(
	            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
	                '|' + (/\d{1,2}/).source);
	    }

	    function mergeConfigs(parentConfig, childConfig) {
	        var res = extend({}, parentConfig), prop;
	        for (prop in childConfig) {
	            if (hasOwnProp(childConfig, prop)) {
	                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                    res[prop] = {};
	                    extend(res[prop], parentConfig[prop]);
	                    extend(res[prop], childConfig[prop]);
	                } else if (childConfig[prop] != null) {
	                    res[prop] = childConfig[prop];
	                } else {
	                    delete res[prop];
	                }
	            }
	        }
	        for (prop in parentConfig) {
	            if (hasOwnProp(parentConfig, prop) &&
	                    !hasOwnProp(childConfig, prop) &&
	                    isObject(parentConfig[prop])) {
	                // make sure changes to properties don't modify parent config
	                res[prop] = extend({}, res[prop]);
	            }
	        }
	        return res;
	    }

	    function Locale(config) {
	        if (config != null) {
	            this.set(config);
	        }
	    }

	    var keys;

	    if (Object.keys) {
	        keys = Object.keys;
	    } else {
	        keys = function (obj) {
	            var i, res = [];
	            for (i in obj) {
	                if (hasOwnProp(obj, i)) {
	                    res.push(i);
	                }
	            }
	            return res;
	        };
	    }

	    var defaultCalendar = {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    };

	    function calendar (key, mom, now) {
	        var output = this._calendar[key] || this._calendar['sameElse'];
	        return isFunction(output) ? output.call(mom, now) : output;
	    }

	    var defaultLongDateFormat = {
	        LTS  : 'h:mm:ss A',
	        LT   : 'h:mm A',
	        L    : 'MM/DD/YYYY',
	        LL   : 'MMMM D, YYYY',
	        LLL  : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    };

	    function longDateFormat (key) {
	        var format = this._longDateFormat[key],
	            formatUpper = this._longDateFormat[key.toUpperCase()];

	        if (format || !formatUpper) {
	            return format;
	        }

	        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	            return val.slice(1);
	        });

	        return this._longDateFormat[key];
	    }

	    var defaultInvalidDate = 'Invalid date';

	    function invalidDate () {
	        return this._invalidDate;
	    }

	    var defaultOrdinal = '%d';
	    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

	    function ordinal (number) {
	        return this._ordinal.replace('%d', number);
	    }

	    var defaultRelativeTime = {
	        future : 'in %s',
	        past   : '%s ago',
	        s  : 'a few seconds',
	        ss : '%d seconds',
	        m  : 'a minute',
	        mm : '%d minutes',
	        h  : 'an hour',
	        hh : '%d hours',
	        d  : 'a day',
	        dd : '%d days',
	        M  : 'a month',
	        MM : '%d months',
	        y  : 'a year',
	        yy : '%d years'
	    };

	    function relativeTime (number, withoutSuffix, string, isFuture) {
	        var output = this._relativeTime[string];
	        return (isFunction(output)) ?
	            output(number, withoutSuffix, string, isFuture) :
	            output.replace(/%d/i, number);
	    }

	    function pastFuture (diff, output) {
	        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	    }

	    var aliases = {};

	    function addUnitAlias (unit, shorthand) {
	        var lowerCase = unit.toLowerCase();
	        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	    }

	    function normalizeUnits(units) {
	        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	    }

	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;

	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }

	        return normalizedInput;
	    }

	    var priorities = {};

	    function addUnitPriority(unit, priority) {
	        priorities[unit] = priority;
	    }

	    function getPrioritizedUnits(unitsObj) {
	        var units = [];
	        for (var u in unitsObj) {
	            units.push({unit: u, priority: priorities[u]});
	        }
	        units.sort(function (a, b) {
	            return a.priority - b.priority;
	        });
	        return units;
	    }

	    function zeroFill(number, targetLength, forceSign) {
	        var absNumber = '' + Math.abs(number),
	            zerosToFill = targetLength - absNumber.length,
	            sign = number >= 0;
	        return (sign ? (forceSign ? '+' : '') : '-') +
	            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	    }

	    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	    var formatFunctions = {};

	    var formatTokenFunctions = {};

	    // token:    'M'
	    // padded:   ['MM', 2]
	    // ordinal:  'Mo'
	    // callback: function () { this.month() + 1 }
	    function addFormatToken (token, padded, ordinal, callback) {
	        var func = callback;
	        if (typeof callback === 'string') {
	            func = function () {
	                return this[callback]();
	            };
	        }
	        if (token) {
	            formatTokenFunctions[token] = func;
	        }
	        if (padded) {
	            formatTokenFunctions[padded[0]] = function () {
	                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	            };
	        }
	        if (ordinal) {
	            formatTokenFunctions[ordinal] = function () {
	                return this.localeData().ordinal(func.apply(this, arguments), token);
	            };
	        }
	    }

	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }

	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;

	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }

	        return function (mom) {
	            var output = '', i;
	            for (i = 0; i < length; i++) {
	                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }

	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }

	        format = expandFormat(format, m.localeData());
	        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

	        return formatFunctions[format](m);
	    }

	    function expandFormat(format, locale) {
	        var i = 5;

	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }

	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }

	        return format;
	    }

	    var match1         = /\d/;            //       0 - 9
	    var match2         = /\d\d/;          //      00 - 99
	    var match3         = /\d{3}/;         //     000 - 999
	    var match4         = /\d{4}/;         //    0000 - 9999
	    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	    var match1to2      = /\d\d?/;         //       0 - 99
	    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	    var match1to3      = /\d{1,3}/;       //       0 - 999
	    var match1to4      = /\d{1,4}/;       //       0 - 9999
	    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

	    var matchUnsigned  = /\d+/;           //       0 - inf
	    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

	    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

	    // any word (or two) characters or numbers including two/three word month in arabic.
	    // includes scottish gaelic two word and hyphenated months
	    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

	    var regexes = {};

	    function addRegexToken (token, regex, strictRegex) {
	        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	            return (isStrict && strictRegex) ? strictRegex : regex;
	        };
	    }

	    function getParseRegexForToken (token, config) {
	        if (!hasOwnProp(regexes, token)) {
	            return new RegExp(unescapeFormat(token));
	        }

	        return regexes[token](config._strict, config._locale);
	    }

	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function unescapeFormat(s) {
	        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        }));
	    }

	    function regexEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }

	    var tokens = {};

	    function addParseToken (token, callback) {
	        var i, func = callback;
	        if (typeof token === 'string') {
	            token = [token];
	        }
	        if (isNumber(callback)) {
	            func = function (input, array) {
	                array[callback] = toInt(input);
	            };
	        }
	        for (i = 0; i < token.length; i++) {
	            tokens[token[i]] = func;
	        }
	    }

	    function addWeekParseToken (token, callback) {
	        addParseToken(token, function (input, array, config, token) {
	            config._w = config._w || {};
	            callback(input, config._w, config, token);
	        });
	    }

	    function addTimeToArrayFromToken(token, input, config) {
	        if (input != null && hasOwnProp(tokens, token)) {
	            tokens[token](input, config._a, config, token);
	        }
	    }

	    var YEAR = 0;
	    var MONTH = 1;
	    var DATE = 2;
	    var HOUR = 3;
	    var MINUTE = 4;
	    var SECOND = 5;
	    var MILLISECOND = 6;
	    var WEEK = 7;
	    var WEEKDAY = 8;

	    // FORMATTING

	    addFormatToken('Y', 0, 0, function () {
	        var y = this.year();
	        return y <= 9999 ? '' + y : '+' + y;
	    });

	    addFormatToken(0, ['YY', 2], 0, function () {
	        return this.year() % 100;
	    });

	    addFormatToken(0, ['YYYY',   4],       0, 'year');
	    addFormatToken(0, ['YYYYY',  5],       0, 'year');
	    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

	    // ALIASES

	    addUnitAlias('year', 'y');

	    // PRIORITIES

	    addUnitPriority('year', 1);

	    // PARSING

	    addRegexToken('Y',      matchSigned);
	    addRegexToken('YY',     match1to2, match2);
	    addRegexToken('YYYY',   match1to4, match4);
	    addRegexToken('YYYYY',  match1to6, match6);
	    addRegexToken('YYYYYY', match1to6, match6);

	    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	    addParseToken('YYYY', function (input, array) {
	        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	    });
	    addParseToken('YY', function (input, array) {
	        array[YEAR] = hooks.parseTwoDigitYear(input);
	    });
	    addParseToken('Y', function (input, array) {
	        array[YEAR] = parseInt(input, 10);
	    });

	    // HELPERS

	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }

	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }

	    // HOOKS

	    hooks.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };

	    // MOMENTS

	    var getSetYear = makeGetSet('FullYear', true);

	    function getIsLeapYear () {
	        return isLeapYear(this.year());
	    }

	    function makeGetSet (unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                set$1(this, unit, value);
	                hooks.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return get(this, unit);
	            }
	        };
	    }

	    function get (mom, unit) {
	        return mom.isValid() ?
	            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	    }

	    function set$1 (mom, unit, value) {
	        if (mom.isValid() && !isNaN(value)) {
	            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
	                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
	            }
	            else {
	                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	            }
	        }
	    }

	    // MOMENTS

	    function stringGet (units) {
	        units = normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units]();
	        }
	        return this;
	    }


	    function stringSet (units, value) {
	        if (typeof units === 'object') {
	            units = normalizeObjectUnits(units);
	            var prioritized = getPrioritizedUnits(units);
	            for (var i = 0; i < prioritized.length; i++) {
	                this[prioritized[i].unit](units[prioritized[i].unit]);
	            }
	        } else {
	            units = normalizeUnits(units);
	            if (isFunction(this[units])) {
	                return this[units](value);
	            }
	        }
	        return this;
	    }

	    function mod(n, x) {
	        return ((n % x) + x) % x;
	    }

	    var indexOf;

	    if (Array.prototype.indexOf) {
	        indexOf = Array.prototype.indexOf;
	    } else {
	        indexOf = function (o) {
	            // I know
	            var i;
	            for (i = 0; i < this.length; ++i) {
	                if (this[i] === o) {
	                    return i;
	                }
	            }
	            return -1;
	        };
	    }

	    function daysInMonth(year, month) {
	        if (isNaN(year) || isNaN(month)) {
	            return NaN;
	        }
	        var modMonth = mod(month, 12);
	        year += (month - modMonth) / 12;
	        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
	    }

	    // FORMATTING

	    addFormatToken('M', ['MM', 2], 'Mo', function () {
	        return this.month() + 1;
	    });

	    addFormatToken('MMM', 0, 0, function (format) {
	        return this.localeData().monthsShort(this, format);
	    });

	    addFormatToken('MMMM', 0, 0, function (format) {
	        return this.localeData().months(this, format);
	    });

	    // ALIASES

	    addUnitAlias('month', 'M');

	    // PRIORITY

	    addUnitPriority('month', 8);

	    // PARSING

	    addRegexToken('M',    match1to2);
	    addRegexToken('MM',   match1to2, match2);
	    addRegexToken('MMM',  function (isStrict, locale) {
	        return locale.monthsShortRegex(isStrict);
	    });
	    addRegexToken('MMMM', function (isStrict, locale) {
	        return locale.monthsRegex(isStrict);
	    });

	    addParseToken(['M', 'MM'], function (input, array) {
	        array[MONTH] = toInt(input) - 1;
	    });

	    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	        var month = config._locale.monthsParse(input, token, config._strict);
	        // if we didn't find a month name, mark the date as invalid.
	        if (month != null) {
	            array[MONTH] = month;
	        } else {
	            getParsingFlags(config).invalidMonth = input;
	        }
	    });

	    // LOCALES

	    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	    function localeMonths (m, format) {
	        if (!m) {
	            return isArray(this._months) ? this._months :
	                this._months['standalone'];
	        }
	        return isArray(this._months) ? this._months[m.month()] :
	            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
	    }

	    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	    function localeMonthsShort (m, format) {
	        if (!m) {
	            return isArray(this._monthsShort) ? this._monthsShort :
	                this._monthsShort['standalone'];
	        }
	        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	    }

	    function handleStrictParse(monthName, format, strict) {
	        var i, ii, mom, llc = monthName.toLocaleLowerCase();
	        if (!this._monthsParse) {
	            // this is not used
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	            for (i = 0; i < 12; ++i) {
	                mom = createUTC([2000, i]);
	                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
	                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	            }
	        }

	        if (strict) {
	            if (format === 'MMM') {
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._longMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        } else {
	            if (format === 'MMM') {
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._longMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._longMonthsParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        }
	    }

	    function localeMonthsParse (monthName, format, strict) {
	        var i, mom, regex;

	        if (this._monthsParseExact) {
	            return handleStrictParse.call(this, monthName, format, strict);
	        }

	        if (!this._monthsParse) {
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	        }

	        // TODO: add sorting
	        // Sorting makes sure if one month (or abbr) is a prefix of another
	        // see sorting in computeMonthsParse
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = createUTC([2000, i]);
	            if (strict && !this._longMonthsParse[i]) {
	                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	            }
	            if (!strict && !this._monthsParse[i]) {
	                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (!strict && this._monthsParse[i].test(monthName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function setMonth (mom, value) {
	        var dayOfMonth;

	        if (!mom.isValid()) {
	            // No op
	            return mom;
	        }

	        if (typeof value === 'string') {
	            if (/^\d+$/.test(value)) {
	                value = toInt(value);
	            } else {
	                value = mom.localeData().monthsParse(value);
	                // TODO: Another silent failure?
	                if (!isNumber(value)) {
	                    return mom;
	                }
	            }
	        }

	        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }

	    function getSetMonth (value) {
	        if (value != null) {
	            setMonth(this, value);
	            hooks.updateOffset(this, true);
	            return this;
	        } else {
	            return get(this, 'Month');
	        }
	    }

	    function getDaysInMonth () {
	        return daysInMonth(this.year(), this.month());
	    }

	    var defaultMonthsShortRegex = matchWord;
	    function monthsShortRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsShortStrictRegex;
	            } else {
	                return this._monthsShortRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_monthsShortRegex')) {
	                this._monthsShortRegex = defaultMonthsShortRegex;
	            }
	            return this._monthsShortStrictRegex && isStrict ?
	                this._monthsShortStrictRegex : this._monthsShortRegex;
	        }
	    }

	    var defaultMonthsRegex = matchWord;
	    function monthsRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsStrictRegex;
	            } else {
	                return this._monthsRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                this._monthsRegex = defaultMonthsRegex;
	            }
	            return this._monthsStrictRegex && isStrict ?
	                this._monthsStrictRegex : this._monthsRegex;
	        }
	    }

	    function computeMonthsParse () {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }

	        var shortPieces = [], longPieces = [], mixedPieces = [],
	            i, mom;
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = createUTC([2000, i]);
	            shortPieces.push(this.monthsShort(mom, ''));
	            longPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.monthsShort(mom, ''));
	        }
	        // Sorting makes sure if one month (or abbr) is a prefix of another it
	        // will match the longer piece.
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);
	        for (i = 0; i < 12; i++) {
	            shortPieces[i] = regexEscape(shortPieces[i]);
	            longPieces[i] = regexEscape(longPieces[i]);
	        }
	        for (i = 0; i < 24; i++) {
	            mixedPieces[i] = regexEscape(mixedPieces[i]);
	        }

	        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._monthsShortRegex = this._monthsRegex;
	        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	    }

	    function createDate (y, m, d, h, M, s, ms) {
	        // can't just apply() to create a date:
	        // https://stackoverflow.com/q/181348
	        var date;
	        // the date constructor remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0) {
	            // preserve leap years using a full 400 year cycle, then reset
	            date = new Date(y + 400, m, d, h, M, s, ms);
	            if (isFinite(date.getFullYear())) {
	                date.setFullYear(y);
	            }
	        } else {
	            date = new Date(y, m, d, h, M, s, ms);
	        }

	        return date;
	    }

	    function createUTCDate (y) {
	        var date;
	        // the Date.UTC function remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0) {
	            var args = Array.prototype.slice.call(arguments);
	            // preserve leap years using a full 400 year cycle, then reset
	            args[0] = y + 400;
	            date = new Date(Date.UTC.apply(null, args));
	            if (isFinite(date.getUTCFullYear())) {
	                date.setUTCFullYear(y);
	            }
	        } else {
	            date = new Date(Date.UTC.apply(null, arguments));
	        }

	        return date;
	    }

	    // start-of-first-week - start-of-year
	    function firstWeekOffset(year, dow, doy) {
	        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	            fwd = 7 + dow - doy,
	            // first-week day local weekday -- which local weekday is fwd
	            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

	        return -fwdlw + fwd - 1;
	    }

	    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	        var localWeekday = (7 + weekday - dow) % 7,
	            weekOffset = firstWeekOffset(year, dow, doy),
	            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	            resYear, resDayOfYear;

	        if (dayOfYear <= 0) {
	            resYear = year - 1;
	            resDayOfYear = daysInYear(resYear) + dayOfYear;
	        } else if (dayOfYear > daysInYear(year)) {
	            resYear = year + 1;
	            resDayOfYear = dayOfYear - daysInYear(year);
	        } else {
	            resYear = year;
	            resDayOfYear = dayOfYear;
	        }

	        return {
	            year: resYear,
	            dayOfYear: resDayOfYear
	        };
	    }

	    function weekOfYear(mom, dow, doy) {
	        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	            resWeek, resYear;

	        if (week < 1) {
	            resYear = mom.year() - 1;
	            resWeek = week + weeksInYear(resYear, dow, doy);
	        } else if (week > weeksInYear(mom.year(), dow, doy)) {
	            resWeek = week - weeksInYear(mom.year(), dow, doy);
	            resYear = mom.year() + 1;
	        } else {
	            resYear = mom.year();
	            resWeek = week;
	        }

	        return {
	            week: resWeek,
	            year: resYear
	        };
	    }

	    function weeksInYear(year, dow, doy) {
	        var weekOffset = firstWeekOffset(year, dow, doy),
	            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	    }

	    // FORMATTING

	    addFormatToken('w', ['ww', 2], 'wo', 'week');
	    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

	    // ALIASES

	    addUnitAlias('week', 'w');
	    addUnitAlias('isoWeek', 'W');

	    // PRIORITIES

	    addUnitPriority('week', 5);
	    addUnitPriority('isoWeek', 5);

	    // PARSING

	    addRegexToken('w',  match1to2);
	    addRegexToken('ww', match1to2, match2);
	    addRegexToken('W',  match1to2);
	    addRegexToken('WW', match1to2, match2);

	    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	        week[token.substr(0, 1)] = toInt(input);
	    });

	    // HELPERS

	    // LOCALES

	    function localeWeek (mom) {
	        return weekOfYear(mom, this._week.dow, this._week.doy).week;
	    }

	    var defaultLocaleWeek = {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 6th is the first week of the year.
	    };

	    function localeFirstDayOfWeek () {
	        return this._week.dow;
	    }

	    function localeFirstDayOfYear () {
	        return this._week.doy;
	    }

	    // MOMENTS

	    function getSetWeek (input) {
	        var week = this.localeData().week(this);
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    function getSetISOWeek (input) {
	        var week = weekOfYear(this, 1, 4).week;
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    // FORMATTING

	    addFormatToken('d', 0, 'do', 'day');

	    addFormatToken('dd', 0, 0, function (format) {
	        return this.localeData().weekdaysMin(this, format);
	    });

	    addFormatToken('ddd', 0, 0, function (format) {
	        return this.localeData().weekdaysShort(this, format);
	    });

	    addFormatToken('dddd', 0, 0, function (format) {
	        return this.localeData().weekdays(this, format);
	    });

	    addFormatToken('e', 0, 0, 'weekday');
	    addFormatToken('E', 0, 0, 'isoWeekday');

	    // ALIASES

	    addUnitAlias('day', 'd');
	    addUnitAlias('weekday', 'e');
	    addUnitAlias('isoWeekday', 'E');

	    // PRIORITY
	    addUnitPriority('day', 11);
	    addUnitPriority('weekday', 11);
	    addUnitPriority('isoWeekday', 11);

	    // PARSING

	    addRegexToken('d',    match1to2);
	    addRegexToken('e',    match1to2);
	    addRegexToken('E',    match1to2);
	    addRegexToken('dd',   function (isStrict, locale) {
	        return locale.weekdaysMinRegex(isStrict);
	    });
	    addRegexToken('ddd',   function (isStrict, locale) {
	        return locale.weekdaysShortRegex(isStrict);
	    });
	    addRegexToken('dddd',   function (isStrict, locale) {
	        return locale.weekdaysRegex(isStrict);
	    });

	    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	        var weekday = config._locale.weekdaysParse(input, token, config._strict);
	        // if we didn't get a weekday name, mark the date as invalid
	        if (weekday != null) {
	            week.d = weekday;
	        } else {
	            getParsingFlags(config).invalidWeekday = input;
	        }
	    });

	    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	        week[token] = toInt(input);
	    });

	    // HELPERS

	    function parseWeekday(input, locale) {
	        if (typeof input !== 'string') {
	            return input;
	        }

	        if (!isNaN(input)) {
	            return parseInt(input, 10);
	        }

	        input = locale.weekdaysParse(input);
	        if (typeof input === 'number') {
	            return input;
	        }

	        return null;
	    }

	    function parseIsoWeekday(input, locale) {
	        if (typeof input === 'string') {
	            return locale.weekdaysParse(input) % 7 || 7;
	        }
	        return isNaN(input) ? null : input;
	    }

	    // LOCALES
	    function shiftWeekdays (ws, n) {
	        return ws.slice(n, 7).concat(ws.slice(0, n));
	    }

	    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	    function localeWeekdays (m, format) {
	        var weekdays = isArray(this._weekdays) ? this._weekdays :
	            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
	        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
	            : (m) ? weekdays[m.day()] : weekdays;
	    }

	    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	    function localeWeekdaysShort (m) {
	        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
	            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	    }

	    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	    function localeWeekdaysMin (m) {
	        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
	            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	    }

	    function handleStrictParse$1(weekdayName, format, strict) {
	        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._minWeekdaysParse = [];

	            for (i = 0; i < 7; ++i) {
	                mom = createUTC([2000, 1]).day(i);
	                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
	                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
	                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	            }
	        }

	        if (strict) {
	            if (format === 'dddd') {
	                ii = indexOf.call(this._weekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else if (format === 'ddd') {
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        } else {
	            if (format === 'dddd') {
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else if (format === 'ddd') {
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        }
	    }

	    function localeWeekdaysParse (weekdayName, format, strict) {
	        var i, mom, regex;

	        if (this._weekdaysParseExact) {
	            return handleStrictParse$1.call(this, weekdayName, format, strict);
	        }

	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._minWeekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._fullWeekdaysParse = [];
	        }

	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already

	            mom = createUTC([2000, 1]).day(i);
	            if (strict && !this._fullWeekdaysParse[i]) {
	                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
	                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
	                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
	            }
	            if (!this._weekdaysParse[i]) {
	                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function getSetDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	        if (input != null) {
	            input = parseWeekday(input, this.localeData());
	            return this.add(input - day, 'd');
	        } else {
	            return day;
	        }
	    }

	    function getSetLocaleDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	        return input == null ? weekday : this.add(input - weekday, 'd');
	    }

	    function getSetISODayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }

	        // behaves the same as moment#day except
	        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	        // as a setter, sunday should belong to the previous week.

	        if (input != null) {
	            var weekday = parseIsoWeekday(input, this.localeData());
	            return this.day(this.day() % 7 ? weekday : weekday - 7);
	        } else {
	            return this.day() || 7;
	        }
	    }

	    var defaultWeekdaysRegex = matchWord;
	    function weekdaysRegex (isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysStrictRegex;
	            } else {
	                return this._weekdaysRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                this._weekdaysRegex = defaultWeekdaysRegex;
	            }
	            return this._weekdaysStrictRegex && isStrict ?
	                this._weekdaysStrictRegex : this._weekdaysRegex;
	        }
	    }

	    var defaultWeekdaysShortRegex = matchWord;
	    function weekdaysShortRegex (isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysShortStrictRegex;
	            } else {
	                return this._weekdaysShortRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	            }
	            return this._weekdaysShortStrictRegex && isStrict ?
	                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	        }
	    }

	    var defaultWeekdaysMinRegex = matchWord;
	    function weekdaysMinRegex (isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysMinStrictRegex;
	            } else {
	                return this._weekdaysMinRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	            }
	            return this._weekdaysMinStrictRegex && isStrict ?
	                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	        }
	    }


	    function computeWeekdaysParse () {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }

	        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
	            i, mom, minp, shortp, longp;
	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already
	            mom = createUTC([2000, 1]).day(i);
	            minp = this.weekdaysMin(mom, '');
	            shortp = this.weekdaysShort(mom, '');
	            longp = this.weekdays(mom, '');
	            minPieces.push(minp);
	            shortPieces.push(shortp);
	            longPieces.push(longp);
	            mixedPieces.push(minp);
	            mixedPieces.push(shortp);
	            mixedPieces.push(longp);
	        }
	        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	        // will match the longer piece.
	        minPieces.sort(cmpLenRev);
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);
	        for (i = 0; i < 7; i++) {
	            shortPieces[i] = regexEscape(shortPieces[i]);
	            longPieces[i] = regexEscape(longPieces[i]);
	            mixedPieces[i] = regexEscape(mixedPieces[i]);
	        }

	        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._weekdaysShortRegex = this._weekdaysRegex;
	        this._weekdaysMinRegex = this._weekdaysRegex;

	        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
	    }

	    // FORMATTING

	    function hFormat() {
	        return this.hours() % 12 || 12;
	    }

	    function kFormat() {
	        return this.hours() || 24;
	    }

	    addFormatToken('H', ['HH', 2], 0, 'hour');
	    addFormatToken('h', ['hh', 2], 0, hFormat);
	    addFormatToken('k', ['kk', 2], 0, kFormat);

	    addFormatToken('hmm', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	    });

	    addFormatToken('hmmss', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });

	    addFormatToken('Hmm', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2);
	    });

	    addFormatToken('Hmmss', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });

	    function meridiem (token, lowercase) {
	        addFormatToken(token, 0, 0, function () {
	            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	        });
	    }

	    meridiem('a', true);
	    meridiem('A', false);

	    // ALIASES

	    addUnitAlias('hour', 'h');

	    // PRIORITY
	    addUnitPriority('hour', 13);

	    // PARSING

	    function matchMeridiem (isStrict, locale) {
	        return locale._meridiemParse;
	    }

	    addRegexToken('a',  matchMeridiem);
	    addRegexToken('A',  matchMeridiem);
	    addRegexToken('H',  match1to2);
	    addRegexToken('h',  match1to2);
	    addRegexToken('k',  match1to2);
	    addRegexToken('HH', match1to2, match2);
	    addRegexToken('hh', match1to2, match2);
	    addRegexToken('kk', match1to2, match2);

	    addRegexToken('hmm', match3to4);
	    addRegexToken('hmmss', match5to6);
	    addRegexToken('Hmm', match3to4);
	    addRegexToken('Hmmss', match5to6);

	    addParseToken(['H', 'HH'], HOUR);
	    addParseToken(['k', 'kk'], function (input, array, config) {
	        var kInput = toInt(input);
	        array[HOUR] = kInput === 24 ? 0 : kInput;
	    });
	    addParseToken(['a', 'A'], function (input, array, config) {
	        config._isPm = config._locale.isPM(input);
	        config._meridiem = input;
	    });
	    addParseToken(['h', 'hh'], function (input, array, config) {
	        array[HOUR] = toInt(input);
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('Hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	    });
	    addParseToken('Hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	    });

	    // LOCALES

	    function localeIsPM (input) {
	        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	        // Using charAt should be more compatible.
	        return ((input + '').toLowerCase().charAt(0) === 'p');
	    }

	    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	    function localeMeridiem (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'pm' : 'PM';
	        } else {
	            return isLower ? 'am' : 'AM';
	        }
	    }


	    // MOMENTS

	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour they want. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.
	    var getSetHour = makeGetSet('Hours', true);

	    var baseConfig = {
	        calendar: defaultCalendar,
	        longDateFormat: defaultLongDateFormat,
	        invalidDate: defaultInvalidDate,
	        ordinal: defaultOrdinal,
	        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
	        relativeTime: defaultRelativeTime,

	        months: defaultLocaleMonths,
	        monthsShort: defaultLocaleMonthsShort,

	        week: defaultLocaleWeek,

	        weekdays: defaultLocaleWeekdays,
	        weekdaysMin: defaultLocaleWeekdaysMin,
	        weekdaysShort: defaultLocaleWeekdaysShort,

	        meridiemParse: defaultLocaleMeridiemParse
	    };

	    // internal storage for locale config files
	    var locales = {};
	    var localeFamilies = {};
	    var globalLocale;

	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }

	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0, j, next, locale, split;

	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return globalLocale;
	    }

	    function loadLocale(name) {
	        var oldLocale = null;
	        // TODO: Find a better way to register and load all the locales in Node
	        if (!locales[name] && ('object' !== 'undefined') &&
	                module && module.exports) {
	            try {
	                oldLocale = globalLocale._abbr;
	                var aliasedRequire = commonjsRequire;
	                aliasedRequire('./locale/' + name);
	                getSetGlobalLocale(oldLocale);
	            } catch (e) {}
	        }
	        return locales[name];
	    }

	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    function getSetGlobalLocale (key, values) {
	        var data;
	        if (key) {
	            if (isUndefined(values)) {
	                data = getLocale(key);
	            }
	            else {
	                data = defineLocale(key, values);
	            }

	            if (data) {
	                // moment.duration._locale = moment._locale = data;
	                globalLocale = data;
	            }
	            else {
	                if ((typeof console !==  'undefined') && console.warn) {
	                    //warn user if arguments are passed but the locale could not be set
	                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
	                }
	            }
	        }

	        return globalLocale._abbr;
	    }

	    function defineLocale (name, config) {
	        if (config !== null) {
	            var locale, parentConfig = baseConfig;
	            config.abbr = name;
	            if (locales[name] != null) {
	                deprecateSimple('defineLocaleOverride',
	                        'use moment.updateLocale(localeName, config) to change ' +
	                        'an existing locale. moment.defineLocale(localeName, ' +
	                        'config) should only be used for creating a new locale ' +
	                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
	                parentConfig = locales[name]._config;
	            } else if (config.parentLocale != null) {
	                if (locales[config.parentLocale] != null) {
	                    parentConfig = locales[config.parentLocale]._config;
	                } else {
	                    locale = loadLocale(config.parentLocale);
	                    if (locale != null) {
	                        parentConfig = locale._config;
	                    } else {
	                        if (!localeFamilies[config.parentLocale]) {
	                            localeFamilies[config.parentLocale] = [];
	                        }
	                        localeFamilies[config.parentLocale].push({
	                            name: name,
	                            config: config
	                        });
	                        return null;
	                    }
	                }
	            }
	            locales[name] = new Locale(mergeConfigs(parentConfig, config));

	            if (localeFamilies[name]) {
	                localeFamilies[name].forEach(function (x) {
	                    defineLocale(x.name, x.config);
	                });
	            }

	            // backwards compat for now: also set the locale
	            // make sure we set the locale AFTER all child locales have been
	            // created, so we won't end up with the child locale set.
	            getSetGlobalLocale(name);


	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    }

	    function updateLocale(name, config) {
	        if (config != null) {
	            var locale, tmpLocale, parentConfig = baseConfig;
	            // MERGE
	            tmpLocale = loadLocale(name);
	            if (tmpLocale != null) {
	                parentConfig = tmpLocale._config;
	            }
	            config = mergeConfigs(parentConfig, config);
	            locale = new Locale(config);
	            locale.parentLocale = locales[name];
	            locales[name] = locale;

	            // backwards compat for now: also set the locale
	            getSetGlobalLocale(name);
	        } else {
	            // pass null for config to unupdate, useful for tests
	            if (locales[name] != null) {
	                if (locales[name].parentLocale != null) {
	                    locales[name] = locales[name].parentLocale;
	                } else if (locales[name] != null) {
	                    delete locales[name];
	                }
	            }
	        }
	        return locales[name];
	    }

	    // returns locale data
	    function getLocale (key) {
	        var locale;

	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }

	        if (!key) {
	            return globalLocale;
	        }

	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }

	        return chooseLocale(key);
	    }

	    function listLocales() {
	        return keys(locales);
	    }

	    function checkOverflow (m) {
	        var overflow;
	        var a = m._a;

	        if (a && getParsingFlags(m).overflow === -2) {
	            overflow =
	                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;

	            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }
	            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	                overflow = WEEK;
	            }
	            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	                overflow = WEEKDAY;
	            }

	            getParsingFlags(m).overflow = overflow;
	        }

	        return m;
	    }

	    // Pick the first defined of two or three arguments.
	    function defaults(a, b, c) {
	        if (a != null) {
	            return a;
	        }
	        if (b != null) {
	            return b;
	        }
	        return c;
	    }

	    function currentDateArray(config) {
	        // hooks is actually the exported moment object
	        var nowValue = new Date(hooks.now());
	        if (config._useUTC) {
	            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	        }
	        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	    }

	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function configFromArray (config) {
	        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

	        if (config._d) {
	            return;
	        }

	        currentDate = currentDateArray(config);

	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }

	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear != null) {
	            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
	                getParsingFlags(config)._overflowDayOfYear = true;
	            }

	            date = createUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }

	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }

	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }

	        // Check for 24:00:00.000
	        if (config._a[HOUR] === 24 &&
	                config._a[MINUTE] === 0 &&
	                config._a[SECOND] === 0 &&
	                config._a[MILLISECOND] === 0) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }

	        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }

	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }

	        // check for mismatching day of week
	        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
	            getParsingFlags(config).weekdayMismatch = true;
	        }
	    }

	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;

	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
	            week = defaults(w.W, 1);
	            weekday = defaults(w.E, 1);
	            if (weekday < 1 || weekday > 7) {
	                weekdayOverflow = true;
	            }
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;

	            var curWeek = weekOfYear(createLocal(), dow, doy);

	            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

	            // Default to current week.
	            week = defaults(w.w, curWeek.week);

	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < 0 || weekday > 6) {
	                    weekdayOverflow = true;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from beginning of week
	                weekday = w.e + dow;
	                if (w.e < 0 || w.e > 6) {
	                    weekdayOverflow = true;
	                }
	            } else {
	                // default to beginning of week
	                weekday = dow;
	            }
	        }
	        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	            getParsingFlags(config)._overflowWeeks = true;
	        } else if (weekdayOverflow != null) {
	            getParsingFlags(config)._overflowWeekday = true;
	        } else {
	            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	            config._a[YEAR] = temp.year;
	            config._dayOfYear = temp.dayOfYear;
	        }
	    }

	    // iso 8601 regex
	    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

	    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

	    var isoDates = [
	        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	        ['YYYY-DDD', /\d{4}-\d{3}/],
	        ['YYYY-MM', /\d{4}-\d\d/, false],
	        ['YYYYYYMMDD', /[+-]\d{10}/],
	        ['YYYYMMDD', /\d{8}/],
	        // YYYYMM is NOT allowed by the standard
	        ['GGGG[W]WWE', /\d{4}W\d{3}/],
	        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	        ['YYYYDDD', /\d{7}/]
	    ];

	    // iso time formats and regexes
	    var isoTimes = [
	        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	        ['HH:mm', /\d\d:\d\d/],
	        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	        ['HHmmss', /\d\d\d\d\d\d/],
	        ['HHmm', /\d\d\d\d/],
	        ['HH', /\d\d/]
	    ];

	    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

	    // date from iso format
	    function configFromISO(config) {
	        var i, l,
	            string = config._i,
	            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	            allowTime, dateFormat, timeFormat, tzFormat;

	        if (match) {
	            getParsingFlags(config).iso = true;

	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(match[1])) {
	                    dateFormat = isoDates[i][0];
	                    allowTime = isoDates[i][2] !== false;
	                    break;
	                }
	            }
	            if (dateFormat == null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[3]) {
	                for (i = 0, l = isoTimes.length; i < l; i++) {
	                    if (isoTimes[i][1].exec(match[3])) {
	                        // match[2] should be 'T' or space
	                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                        break;
	                    }
	                }
	                if (timeFormat == null) {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            if (!allowTime && timeFormat != null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[4]) {
	                if (tzRegex.exec(match[4])) {
	                    tzFormat = 'Z';
	                } else {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	            configFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }

	    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
	    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

	    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
	        var result = [
	            untruncateYear(yearStr),
	            defaultLocaleMonthsShort.indexOf(monthStr),
	            parseInt(dayStr, 10),
	            parseInt(hourStr, 10),
	            parseInt(minuteStr, 10)
	        ];

	        if (secondStr) {
	            result.push(parseInt(secondStr, 10));
	        }

	        return result;
	    }

	    function untruncateYear(yearStr) {
	        var year = parseInt(yearStr, 10);
	        if (year <= 49) {
	            return 2000 + year;
	        } else if (year <= 999) {
	            return 1900 + year;
	        }
	        return year;
	    }

	    function preprocessRFC2822(s) {
	        // Remove comments and folding whitespace and replace multiple-spaces with a single space
	        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	    }

	    function checkWeekday(weekdayStr, parsedInput, config) {
	        if (weekdayStr) {
	            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
	            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
	                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
	            if (weekdayProvided !== weekdayActual) {
	                getParsingFlags(config).weekdayMismatch = true;
	                config._isValid = false;
	                return false;
	            }
	        }
	        return true;
	    }

	    var obsOffsets = {
	        UT: 0,
	        GMT: 0,
	        EDT: -4 * 60,
	        EST: -5 * 60,
	        CDT: -5 * 60,
	        CST: -6 * 60,
	        MDT: -6 * 60,
	        MST: -7 * 60,
	        PDT: -7 * 60,
	        PST: -8 * 60
	    };

	    function calculateOffset(obsOffset, militaryOffset, numOffset) {
	        if (obsOffset) {
	            return obsOffsets[obsOffset];
	        } else if (militaryOffset) {
	            // the only allowed military tz is Z
	            return 0;
	        } else {
	            var hm = parseInt(numOffset, 10);
	            var m = hm % 100, h = (hm - m) / 100;
	            return h * 60 + m;
	        }
	    }

	    // date and time from ref 2822 format
	    function configFromRFC2822(config) {
	        var match = rfc2822.exec(preprocessRFC2822(config._i));
	        if (match) {
	            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
	            if (!checkWeekday(match[1], parsedArray, config)) {
	                return;
	            }

	            config._a = parsedArray;
	            config._tzm = calculateOffset(match[8], match[9], match[10]);

	            config._d = createUTCDate.apply(null, config._a);
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

	            getParsingFlags(config).rfc2822 = true;
	        } else {
	            config._isValid = false;
	        }
	    }

	    // date from iso format or fallback
	    function configFromString(config) {
	        var matched = aspNetJsonRegex.exec(config._i);

	        if (matched !== null) {
	            config._d = new Date(+matched[1]);
	            return;
	        }

	        configFromISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	        } else {
	            return;
	        }

	        configFromRFC2822(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	        } else {
	            return;
	        }

	        // Final attempt, use Input Fallback
	        hooks.createFromInputFallback(config);
	    }

	    hooks.createFromInputFallback = deprecate(
	        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
	        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
	        'discouraged and will be removed in an upcoming major release. Please refer to ' +
	        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );

	    // constant that refers to the ISO standard
	    hooks.ISO_8601 = function () {};

	    // constant that refers to the RFC 2822 form
	    hooks.RFC_2822 = function () {};

	    // date from string and format string
	    function configFromStringAndFormat(config) {
	        // TODO: Move this to another part of the creation flow to prevent circular deps
	        if (config._f === hooks.ISO_8601) {
	            configFromISO(config);
	            return;
	        }
	        if (config._f === hooks.RFC_2822) {
	            configFromRFC2822(config);
	            return;
	        }
	        config._a = [];
	        getParsingFlags(config).empty = true;

	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;

	        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            // console.log('token', token, 'parsedInput', parsedInput,
	            //         'regex', getParseRegexForToken(token, config));
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    getParsingFlags(config).unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    getParsingFlags(config).empty = false;
	                }
	                else {
	                    getParsingFlags(config).unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	        }

	        // add remaining unparsed input length to the string
	        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            getParsingFlags(config).unusedInput.push(string);
	        }

	        // clear _12h flag if hour is <= 12
	        if (config._a[HOUR] <= 12 &&
	            getParsingFlags(config).bigHour === true &&
	            config._a[HOUR] > 0) {
	            getParsingFlags(config).bigHour = undefined;
	        }

	        getParsingFlags(config).parsedDateParts = config._a.slice(0);
	        getParsingFlags(config).meridiem = config._meridiem;
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

	        configFromArray(config);
	        checkOverflow(config);
	    }


	    function meridiemFixWrap (locale, hour, meridiem) {
	        var isPm;

	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // this is not supposed to happen
	            return hour;
	        }
	    }

	    // date from string and array of format strings
	    function configFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,

	            scoreToBeat,
	            i,
	            currentScore;

	        if (config._f.length === 0) {
	            getParsingFlags(config).invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }

	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._f = config._f[i];
	            configFromStringAndFormat(tempConfig);

	            if (!isValid(tempConfig)) {
	                continue;
	            }

	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += getParsingFlags(tempConfig).charsLeftOver;

	            //or tokens
	            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

	            getParsingFlags(tempConfig).score = currentScore;

	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }

	        extend(config, bestMoment || tempConfig);
	    }

	    function configFromObject(config) {
	        if (config._d) {
	            return;
	        }

	        var i = normalizeObjectUnits(config._i);
	        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	            return obj && parseInt(obj, 10);
	        });

	        configFromArray(config);
	    }

	    function createFromConfig (config) {
	        var res = new Moment(checkOverflow(prepareConfig(config)));
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }

	        return res;
	    }

	    function prepareConfig (config) {
	        var input = config._i,
	            format = config._f;

	        config._locale = config._locale || getLocale(config._l);

	        if (input === null || (format === undefined && input === '')) {
	            return createInvalid({nullInput: true});
	        }

	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }

	        if (isMoment(input)) {
	            return new Moment(checkOverflow(input));
	        } else if (isDate(input)) {
	            config._d = input;
	        } else if (isArray(format)) {
	            configFromStringAndArray(config);
	        } else if (format) {
	            configFromStringAndFormat(config);
	        }  else {
	            configFromInput(config);
	        }

	        if (!isValid(config)) {
	            config._d = null;
	        }

	        return config;
	    }

	    function configFromInput(config) {
	        var input = config._i;
	        if (isUndefined(input)) {
	            config._d = new Date(hooks.now());
	        } else if (isDate(input)) {
	            config._d = new Date(input.valueOf());
	        } else if (typeof input === 'string') {
	            configFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            configFromArray(config);
	        } else if (isObject(input)) {
	            configFromObject(config);
	        } else if (isNumber(input)) {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            hooks.createFromInputFallback(config);
	        }
	    }

	    function createLocalOrUTC (input, format, locale, strict, isUTC) {
	        var c = {};

	        if (locale === true || locale === false) {
	            strict = locale;
	            locale = undefined;
	        }

	        if ((isObject(input) && isObjectEmpty(input)) ||
	                (isArray(input) && input.length === 0)) {
	            input = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c._isAMomentObject = true;
	        c._useUTC = c._isUTC = isUTC;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;

	        return createFromConfig(c);
	    }

	    function createLocal (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, false);
	    }

	    var prototypeMin = deprecate(
	        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
	        function () {
	            var other = createLocal.apply(null, arguments);
	            if (this.isValid() && other.isValid()) {
	                return other < this ? this : other;
	            } else {
	                return createInvalid();
	            }
	        }
	    );

	    var prototypeMax = deprecate(
	        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
	        function () {
	            var other = createLocal.apply(null, arguments);
	            if (this.isValid() && other.isValid()) {
	                return other > this ? this : other;
	            } else {
	                return createInvalid();
	            }
	        }
	    );

	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return createLocal();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (!moments[i].isValid() || moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }

	    // TODO: Use [].sort instead?
	    function min () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isBefore', args);
	    }

	    function max () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isAfter', args);
	    }

	    var now = function () {
	        return Date.now ? Date.now() : +(new Date());
	    };

	    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

	    function isDurationValid(m) {
	        for (var key in m) {
	            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
	                return false;
	            }
	        }

	        var unitHasDecimal = false;
	        for (var i = 0; i < ordering.length; ++i) {
	            if (m[ordering[i]]) {
	                if (unitHasDecimal) {
	                    return false; // only allow non-integers for smallest unit
	                }
	                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
	                    unitHasDecimal = true;
	                }
	            }
	        }

	        return true;
	    }

	    function isValid$1() {
	        return this._isValid;
	    }

	    function createInvalid$1() {
	        return createDuration(NaN);
	    }

	    function Duration (duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;

	        this._isValid = isDurationValid(normalizedInput);

	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible to translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            quarters * 3 +
	            years * 12;

	        this._data = {};

	        this._locale = getLocale();

	        this._bubble();
	    }

	    function isDuration (obj) {
	        return obj instanceof Duration;
	    }

	    function absRound (number) {
	        if (number < 0) {
	            return Math.round(-1 * number) * -1;
	        } else {
	            return Math.round(number);
	        }
	    }

	    // FORMATTING

	    function offset (token, separator) {
	        addFormatToken(token, 0, 0, function () {
	            var offset = this.utcOffset();
	            var sign = '+';
	            if (offset < 0) {
	                offset = -offset;
	                sign = '-';
	            }
	            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	        });
	    }

	    offset('Z', ':');
	    offset('ZZ', '');

	    // PARSING

	    addRegexToken('Z',  matchShortOffset);
	    addRegexToken('ZZ', matchShortOffset);
	    addParseToken(['Z', 'ZZ'], function (input, array, config) {
	        config._useUTC = true;
	        config._tzm = offsetFromString(matchShortOffset, input);
	    });

	    // HELPERS

	    // timezone chunker
	    // '+10:00' > ['10',  '00']
	    // '-1530'  > ['-15', '30']
	    var chunkOffset = /([\+\-]|\d\d)/gi;

	    function offsetFromString(matcher, string) {
	        var matches = (string || '').match(matcher);

	        if (matches === null) {
	            return null;
	        }

	        var chunk   = matches[matches.length - 1] || [];
	        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	        var minutes = +(parts[1] * 60) + toInt(parts[2]);

	        return minutes === 0 ?
	          0 :
	          parts[0] === '+' ? minutes : -minutes;
	    }

	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function cloneWithOffset(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(res._d.valueOf() + diff);
	            hooks.updateOffset(res, false);
	            return res;
	        } else {
	            return createLocal(input).local();
	        }
	    }

	    function getDateOffset (m) {
	        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	        // https://github.com/moment/moment/pull/1871
	        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	    }

	    // HOOKS

	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    hooks.updateOffset = function () {};

	    // MOMENTS

	    // keepLocalTime = true means only change the timezone, without
	    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	    // +0200, so we adjust the time as needed, to be valid.
	    //
	    // Keeping the time actually adds/subtracts (one hour)
	    // from the actual represented time. That is why we call updateOffset
	    // a second time. In case it wants us to change the offset again
	    // _changeInProgress == true case, then we have to adjust, because
	    // there is no such time in the given timezone.
	    function getSetOffset (input, keepLocalTime, keepMinutes) {
	        var offset = this._offset || 0,
	            localAdjust;
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        if (input != null) {
	            if (typeof input === 'string') {
	                input = offsetFromString(matchShortOffset, input);
	                if (input === null) {
	                    return this;
	                }
	            } else if (Math.abs(input) < 16 && !keepMinutes) {
	                input = input * 60;
	            }
	            if (!this._isUTC && keepLocalTime) {
	                localAdjust = getDateOffset(this);
	            }
	            this._offset = input;
	            this._isUTC = true;
	            if (localAdjust != null) {
	                this.add(localAdjust, 'm');
	            }
	            if (offset !== input) {
	                if (!keepLocalTime || this._changeInProgress) {
	                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
	                } else if (!this._changeInProgress) {
	                    this._changeInProgress = true;
	                    hooks.updateOffset(this, true);
	                    this._changeInProgress = null;
	                }
	            }
	            return this;
	        } else {
	            return this._isUTC ? offset : getDateOffset(this);
	        }
	    }

	    function getSetZone (input, keepLocalTime) {
	        if (input != null) {
	            if (typeof input !== 'string') {
	                input = -input;
	            }

	            this.utcOffset(input, keepLocalTime);

	            return this;
	        } else {
	            return -this.utcOffset();
	        }
	    }

	    function setOffsetToUTC (keepLocalTime) {
	        return this.utcOffset(0, keepLocalTime);
	    }

	    function setOffsetToLocal (keepLocalTime) {
	        if (this._isUTC) {
	            this.utcOffset(0, keepLocalTime);
	            this._isUTC = false;

	            if (keepLocalTime) {
	                this.subtract(getDateOffset(this), 'm');
	            }
	        }
	        return this;
	    }

	    function setOffsetToParsedOffset () {
	        if (this._tzm != null) {
	            this.utcOffset(this._tzm, false, true);
	        } else if (typeof this._i === 'string') {
	            var tZone = offsetFromString(matchOffset, this._i);
	            if (tZone != null) {
	                this.utcOffset(tZone);
	            }
	            else {
	                this.utcOffset(0, true);
	            }
	        }
	        return this;
	    }

	    function hasAlignedHourOffset (input) {
	        if (!this.isValid()) {
	            return false;
	        }
	        input = input ? createLocal(input).utcOffset() : 0;

	        return (this.utcOffset() - input) % 60 === 0;
	    }

	    function isDaylightSavingTime () {
	        return (
	            this.utcOffset() > this.clone().month(0).utcOffset() ||
	            this.utcOffset() > this.clone().month(5).utcOffset()
	        );
	    }

	    function isDaylightSavingTimeShifted () {
	        if (!isUndefined(this._isDSTShifted)) {
	            return this._isDSTShifted;
	        }

	        var c = {};

	        copyConfig(c, this);
	        c = prepareConfig(c);

	        if (c._a) {
	            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
	            this._isDSTShifted = this.isValid() &&
	                compareArrays(c._a, other.toArray()) > 0;
	        } else {
	            this._isDSTShifted = false;
	        }

	        return this._isDSTShifted;
	    }

	    function isLocal () {
	        return this.isValid() ? !this._isUTC : false;
	    }

	    function isUtcOffset () {
	        return this.isValid() ? this._isUTC : false;
	    }

	    function isUtc () {
	        return this.isValid() ? this._isUTC && this._offset === 0 : false;
	    }

	    // ASP.NET json date format regex
	    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

	    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	    // and further modified to allow for strings containing both week and day
	    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

	    function createDuration (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            diffRes;

	        if (isDuration(input)) {
	            duration = {
	                ms : input._milliseconds,
	                d  : input._days,
	                M  : input._months
	            };
	        } else if (isNumber(input)) {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y  : 0,
	                d  : toInt(match[DATE])                         * sign,
	                h  : toInt(match[HOUR])                         * sign,
	                m  : toInt(match[MINUTE])                       * sign,
	                s  : toInt(match[SECOND])                       * sign,
	                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
	            };
	        } else if (!!(match = isoRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y : parseIso(match[2], sign),
	                M : parseIso(match[3], sign),
	                w : parseIso(match[4], sign),
	                d : parseIso(match[5], sign),
	                h : parseIso(match[6], sign),
	                m : parseIso(match[7], sign),
	                s : parseIso(match[8], sign)
	            };
	        } else if (duration == null) {// checks for null or undefined
	            duration = {};
	        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }

	        ret = new Duration(duration);

	        if (isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }

	        return ret;
	    }

	    createDuration.fn = Duration.prototype;
	    createDuration.invalid = createInvalid$1;

	    function parseIso (inp, sign) {
	        // We'd normally use ~~inp for this, but unfortunately it also
	        // converts floats to ints.
	        // inp may be undefined, so careful calling replace on it.
	        var res = inp && parseFloat(inp.replace(',', '.'));
	        // apply sign while we're at it
	        return (isNaN(res) ? 0 : res) * sign;
	    }

	    function positiveMomentsDifference(base, other) {
	        var res = {};

	        res.months = other.month() - base.month() +
	            (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }

	        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

	        return res;
	    }

	    function momentsDifference(base, other) {
	        var res;
	        if (!(base.isValid() && other.isValid())) {
	            return {milliseconds: 0, months: 0};
	        }

	        other = cloneWithOffset(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }

	        return res;
	    }

	    // TODO: remove 'name' arg after deprecation is removed
	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
	                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
	                tmp = val; val = period; period = tmp;
	            }

	            val = typeof val === 'string' ? +val : val;
	            dur = createDuration(val, period);
	            addSubtract(this, dur, direction);
	            return this;
	        };
	    }

	    function addSubtract (mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = absRound(duration._days),
	            months = absRound(duration._months);

	        if (!mom.isValid()) {
	            // No op
	            return;
	        }

	        updateOffset = updateOffset == null ? true : updateOffset;

	        if (months) {
	            setMonth(mom, get(mom, 'Month') + months * isAdding);
	        }
	        if (days) {
	            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
	        }
	        if (milliseconds) {
	            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	        }
	        if (updateOffset) {
	            hooks.updateOffset(mom, days || months);
	        }
	    }

	    var add      = createAdder(1, 'add');
	    var subtract = createAdder(-1, 'subtract');

	    function getCalendarFormat(myMoment, now) {
	        var diff = myMoment.diff(now, 'days', true);
	        return diff < -6 ? 'sameElse' :
	                diff < -1 ? 'lastWeek' :
	                diff < 0 ? 'lastDay' :
	                diff < 1 ? 'sameDay' :
	                diff < 2 ? 'nextDay' :
	                diff < 7 ? 'nextWeek' : 'sameElse';
	    }

	    function calendar$1 (time, formats) {
	        // We want to compare the start of today, vs this.
	        // Getting start-of-today depends on whether we're local/utc/offset or not.
	        var now = time || createLocal(),
	            sod = cloneWithOffset(now, this).startOf('day'),
	            format = hooks.calendarFormat(this, sod) || 'sameElse';

	        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

	        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
	    }

	    function clone () {
	        return new Moment(this);
	    }

	    function isAfter (input, units) {
	        var localInput = isMoment(input) ? input : createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units) || 'millisecond';
	        if (units === 'millisecond') {
	            return this.valueOf() > localInput.valueOf();
	        } else {
	            return localInput.valueOf() < this.clone().startOf(units).valueOf();
	        }
	    }

	    function isBefore (input, units) {
	        var localInput = isMoment(input) ? input : createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units) || 'millisecond';
	        if (units === 'millisecond') {
	            return this.valueOf() < localInput.valueOf();
	        } else {
	            return this.clone().endOf(units).valueOf() < localInput.valueOf();
	        }
	    }

	    function isBetween (from, to, units, inclusivity) {
	        var localFrom = isMoment(from) ? from : createLocal(from),
	            localTo = isMoment(to) ? to : createLocal(to);
	        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
	            return false;
	        }
	        inclusivity = inclusivity || '()';
	        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
	            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
	    }

	    function isSame (input, units) {
	        var localInput = isMoment(input) ? input : createLocal(input),
	            inputMs;
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units) || 'millisecond';
	        if (units === 'millisecond') {
	            return this.valueOf() === localInput.valueOf();
	        } else {
	            inputMs = localInput.valueOf();
	            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
	        }
	    }

	    function isSameOrAfter (input, units) {
	        return this.isSame(input, units) || this.isAfter(input, units);
	    }

	    function isSameOrBefore (input, units) {
	        return this.isSame(input, units) || this.isBefore(input, units);
	    }

	    function diff (input, units, asFloat) {
	        var that,
	            zoneDelta,
	            output;

	        if (!this.isValid()) {
	            return NaN;
	        }

	        that = cloneWithOffset(input, this);

	        if (!that.isValid()) {
	            return NaN;
	        }

	        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

	        units = normalizeUnits(units);

	        switch (units) {
	            case 'year': output = monthDiff(this, that) / 12; break;
	            case 'month': output = monthDiff(this, that); break;
	            case 'quarter': output = monthDiff(this, that) / 3; break;
	            case 'second': output = (this - that) / 1e3; break; // 1000
	            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
	            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
	            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
	            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
	            default: output = this - that;
	        }

	        return asFloat ? output : absFloor(output);
	    }

	    function monthDiff (a, b) {
	        // difference in months
	        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	            // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2, adjust;

	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }

	        //check for negative zero, return zero if negative zero
	        return -(wholeMonthDiff + adjust) || 0;
	    }

	    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

	    function toString () {
	        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	    }

	    function toISOString(keepOffset) {
	        if (!this.isValid()) {
	            return null;
	        }
	        var utc = keepOffset !== true;
	        var m = utc ? this.clone().utc() : this;
	        if (m.year() < 0 || m.year() > 9999) {
	            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
	        }
	        if (isFunction(Date.prototype.toISOString)) {
	            // native implementation is ~50x faster, use it when we can
	            if (utc) {
	                return this.toDate().toISOString();
	            } else {
	                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
	            }
	        }
	        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
	    }

	    /**
	     * Return a human readable representation of a moment that can
	     * also be evaluated to get a new moment which is the same
	     *
	     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	     */
	    function inspect () {
	        if (!this.isValid()) {
	            return 'moment.invalid(/* ' + this._i + ' */)';
	        }
	        var func = 'moment';
	        var zone = '';
	        if (!this.isLocal()) {
	            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
	            zone = 'Z';
	        }
	        var prefix = '[' + func + '("]';
	        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
	        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
	        var suffix = zone + '[")]';

	        return this.format(prefix + year + datetime + suffix);
	    }

	    function format (inputString) {
	        if (!inputString) {
	            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
	        }
	        var output = formatMoment(this, inputString);
	        return this.localeData().postformat(output);
	    }

	    function from (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 createLocal(time).isValid())) {
	            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }

	    function fromNow (withoutSuffix) {
	        return this.from(createLocal(), withoutSuffix);
	    }

	    function to (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 createLocal(time).isValid())) {
	            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }

	    function toNow (withoutSuffix) {
	        return this.to(createLocal(), withoutSuffix);
	    }

	    // If passed a locale key, it will set the locale for this
	    // instance.  Otherwise, it will return the locale configuration
	    // variables for this instance.
	    function locale (key) {
	        var newLocaleData;

	        if (key === undefined) {
	            return this._locale._abbr;
	        } else {
	            newLocaleData = getLocale(key);
	            if (newLocaleData != null) {
	                this._locale = newLocaleData;
	            }
	            return this;
	        }
	    }

	    var lang = deprecate(
	        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	        function (key) {
	            if (key === undefined) {
	                return this.localeData();
	            } else {
	                return this.locale(key);
	            }
	        }
	    );

	    function localeData () {
	        return this._locale;
	    }

	    var MS_PER_SECOND = 1000;
	    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
	    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
	    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

	    // actual modulo - handles negative numbers (for dates before 1970):
	    function mod$1(dividend, divisor) {
	        return (dividend % divisor + divisor) % divisor;
	    }

	    function localStartOfDate(y, m, d) {
	        // the date constructor remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0) {
	            // preserve leap years using a full 400 year cycle, then reset
	            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
	        } else {
	            return new Date(y, m, d).valueOf();
	        }
	    }

	    function utcStartOfDate(y, m, d) {
	        // Date.UTC remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0) {
	            // preserve leap years using a full 400 year cycle, then reset
	            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
	        } else {
	            return Date.UTC(y, m, d);
	        }
	    }

	    function startOf (units) {
	        var time;
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond' || !this.isValid()) {
	            return this;
	        }

	        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

	        switch (units) {
	            case 'year':
	                time = startOfDate(this.year(), 0, 1);
	                break;
	            case 'quarter':
	                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
	                break;
	            case 'month':
	                time = startOfDate(this.year(), this.month(), 1);
	                break;
	            case 'week':
	                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
	                break;
	            case 'isoWeek':
	                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
	                break;
	            case 'day':
	            case 'date':
	                time = startOfDate(this.year(), this.month(), this.date());
	                break;
	            case 'hour':
	                time = this._d.valueOf();
	                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
	                break;
	            case 'minute':
	                time = this._d.valueOf();
	                time -= mod$1(time, MS_PER_MINUTE);
	                break;
	            case 'second':
	                time = this._d.valueOf();
	                time -= mod$1(time, MS_PER_SECOND);
	                break;
	        }

	        this._d.setTime(time);
	        hooks.updateOffset(this, true);
	        return this;
	    }

	    function endOf (units) {
	        var time;
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond' || !this.isValid()) {
	            return this;
	        }

	        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

	        switch (units) {
	            case 'year':
	                time = startOfDate(this.year() + 1, 0, 1) - 1;
	                break;
	            case 'quarter':
	                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
	                break;
	            case 'month':
	                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
	                break;
	            case 'week':
	                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
	                break;
	            case 'isoWeek':
	                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
	                break;
	            case 'day':
	            case 'date':
	                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
	                break;
	            case 'hour':
	                time = this._d.valueOf();
	                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
	                break;
	            case 'minute':
	                time = this._d.valueOf();
	                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
	                break;
	            case 'second':
	                time = this._d.valueOf();
	                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
	                break;
	        }

	        this._d.setTime(time);
	        hooks.updateOffset(this, true);
	        return this;
	    }

	    function valueOf () {
	        return this._d.valueOf() - ((this._offset || 0) * 60000);
	    }

	    function unix () {
	        return Math.floor(this.valueOf() / 1000);
	    }

	    function toDate () {
	        return new Date(this.valueOf());
	    }

	    function toArray () {
	        var m = this;
	        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	    }

	    function toObject () {
	        var m = this;
	        return {
	            years: m.year(),
	            months: m.month(),
	            date: m.date(),
	            hours: m.hours(),
	            minutes: m.minutes(),
	            seconds: m.seconds(),
	            milliseconds: m.milliseconds()
	        };
	    }

	    function toJSON () {
	        // new Date(NaN).toJSON() === null
	        return this.isValid() ? this.toISOString() : null;
	    }

	    function isValid$2 () {
	        return isValid(this);
	    }

	    function parsingFlags () {
	        return extend({}, getParsingFlags(this));
	    }

	    function invalidAt () {
	        return getParsingFlags(this).overflow;
	    }

	    function creationData() {
	        return {
	            input: this._i,
	            format: this._f,
	            locale: this._locale,
	            isUTC: this._isUTC,
	            strict: this._strict
	        };
	    }

	    // FORMATTING

	    addFormatToken(0, ['gg', 2], 0, function () {
	        return this.weekYear() % 100;
	    });

	    addFormatToken(0, ['GG', 2], 0, function () {
	        return this.isoWeekYear() % 100;
	    });

	    function addWeekYearFormatToken (token, getter) {
	        addFormatToken(0, [token, token.length], 0, getter);
	    }

	    addWeekYearFormatToken('gggg',     'weekYear');
	    addWeekYearFormatToken('ggggg',    'weekYear');
	    addWeekYearFormatToken('GGGG',  'isoWeekYear');
	    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

	    // ALIASES

	    addUnitAlias('weekYear', 'gg');
	    addUnitAlias('isoWeekYear', 'GG');

	    // PRIORITY

	    addUnitPriority('weekYear', 1);
	    addUnitPriority('isoWeekYear', 1);


	    // PARSING

	    addRegexToken('G',      matchSigned);
	    addRegexToken('g',      matchSigned);
	    addRegexToken('GG',     match1to2, match2);
	    addRegexToken('gg',     match1to2, match2);
	    addRegexToken('GGGG',   match1to4, match4);
	    addRegexToken('gggg',   match1to4, match4);
	    addRegexToken('GGGGG',  match1to6, match6);
	    addRegexToken('ggggg',  match1to6, match6);

	    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	        week[token.substr(0, 2)] = toInt(input);
	    });

	    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	        week[token] = hooks.parseTwoDigitYear(input);
	    });

	    // MOMENTS

	    function getSetWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input,
	                this.week(),
	                this.weekday(),
	                this.localeData()._week.dow,
	                this.localeData()._week.doy);
	    }

	    function getSetISOWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input, this.isoWeek(), this.isoWeekday(), 1, 4);
	    }

	    function getISOWeeksInYear () {
	        return weeksInYear(this.year(), 1, 4);
	    }

	    function getWeeksInYear () {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	    }

	    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	        var weeksTarget;
	        if (input == null) {
	            return weekOfYear(this, dow, doy).year;
	        } else {
	            weeksTarget = weeksInYear(input, dow, doy);
	            if (week > weeksTarget) {
	                week = weeksTarget;
	            }
	            return setWeekAll.call(this, input, week, weekday, dow, doy);
	        }
	    }

	    function setWeekAll(weekYear, week, weekday, dow, doy) {
	        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

	        this.year(date.getUTCFullYear());
	        this.month(date.getUTCMonth());
	        this.date(date.getUTCDate());
	        return this;
	    }

	    // FORMATTING

	    addFormatToken('Q', 0, 'Qo', 'quarter');

	    // ALIASES

	    addUnitAlias('quarter', 'Q');

	    // PRIORITY

	    addUnitPriority('quarter', 7);

	    // PARSING

	    addRegexToken('Q', match1);
	    addParseToken('Q', function (input, array) {
	        array[MONTH] = (toInt(input) - 1) * 3;
	    });

	    // MOMENTS

	    function getSetQuarter (input) {
	        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	    }

	    // FORMATTING

	    addFormatToken('D', ['DD', 2], 'Do', 'date');

	    // ALIASES

	    addUnitAlias('date', 'D');

	    // PRIORITY
	    addUnitPriority('date', 9);

	    // PARSING

	    addRegexToken('D',  match1to2);
	    addRegexToken('DD', match1to2, match2);
	    addRegexToken('Do', function (isStrict, locale) {
	        // TODO: Remove "ordinalParse" fallback in next major release.
	        return isStrict ?
	          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
	          locale._dayOfMonthOrdinalParseLenient;
	    });

	    addParseToken(['D', 'DD'], DATE);
	    addParseToken('Do', function (input, array) {
	        array[DATE] = toInt(input.match(match1to2)[0]);
	    });

	    // MOMENTS

	    var getSetDayOfMonth = makeGetSet('Date', true);

	    // FORMATTING

	    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

	    // ALIASES

	    addUnitAlias('dayOfYear', 'DDD');

	    // PRIORITY
	    addUnitPriority('dayOfYear', 4);

	    // PARSING

	    addRegexToken('DDD',  match1to3);
	    addRegexToken('DDDD', match3);
	    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	        config._dayOfYear = toInt(input);
	    });

	    // HELPERS

	    // MOMENTS

	    function getSetDayOfYear (input) {
	        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	    }

	    // FORMATTING

	    addFormatToken('m', ['mm', 2], 0, 'minute');

	    // ALIASES

	    addUnitAlias('minute', 'm');

	    // PRIORITY

	    addUnitPriority('minute', 14);

	    // PARSING

	    addRegexToken('m',  match1to2);
	    addRegexToken('mm', match1to2, match2);
	    addParseToken(['m', 'mm'], MINUTE);

	    // MOMENTS

	    var getSetMinute = makeGetSet('Minutes', false);

	    // FORMATTING

	    addFormatToken('s', ['ss', 2], 0, 'second');

	    // ALIASES

	    addUnitAlias('second', 's');

	    // PRIORITY

	    addUnitPriority('second', 15);

	    // PARSING

	    addRegexToken('s',  match1to2);
	    addRegexToken('ss', match1to2, match2);
	    addParseToken(['s', 'ss'], SECOND);

	    // MOMENTS

	    var getSetSecond = makeGetSet('Seconds', false);

	    // FORMATTING

	    addFormatToken('S', 0, 0, function () {
	        return ~~(this.millisecond() / 100);
	    });

	    addFormatToken(0, ['SS', 2], 0, function () {
	        return ~~(this.millisecond() / 10);
	    });

	    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	    addFormatToken(0, ['SSSS', 4], 0, function () {
	        return this.millisecond() * 10;
	    });
	    addFormatToken(0, ['SSSSS', 5], 0, function () {
	        return this.millisecond() * 100;
	    });
	    addFormatToken(0, ['SSSSSS', 6], 0, function () {
	        return this.millisecond() * 1000;
	    });
	    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	        return this.millisecond() * 10000;
	    });
	    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	        return this.millisecond() * 100000;
	    });
	    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	        return this.millisecond() * 1000000;
	    });


	    // ALIASES

	    addUnitAlias('millisecond', 'ms');

	    // PRIORITY

	    addUnitPriority('millisecond', 16);

	    // PARSING

	    addRegexToken('S',    match1to3, match1);
	    addRegexToken('SS',   match1to3, match2);
	    addRegexToken('SSS',  match1to3, match3);

	    var token;
	    for (token = 'SSSS'; token.length <= 9; token += 'S') {
	        addRegexToken(token, matchUnsigned);
	    }

	    function parseMs(input, array) {
	        array[MILLISECOND] = toInt(('0.' + input) * 1000);
	    }

	    for (token = 'S'; token.length <= 9; token += 'S') {
	        addParseToken(token, parseMs);
	    }
	    // MOMENTS

	    var getSetMillisecond = makeGetSet('Milliseconds', false);

	    // FORMATTING

	    addFormatToken('z',  0, 0, 'zoneAbbr');
	    addFormatToken('zz', 0, 0, 'zoneName');

	    // MOMENTS

	    function getZoneAbbr () {
	        return this._isUTC ? 'UTC' : '';
	    }

	    function getZoneName () {
	        return this._isUTC ? 'Coordinated Universal Time' : '';
	    }

	    var proto = Moment.prototype;

	    proto.add               = add;
	    proto.calendar          = calendar$1;
	    proto.clone             = clone;
	    proto.diff              = diff;
	    proto.endOf             = endOf;
	    proto.format            = format;
	    proto.from              = from;
	    proto.fromNow           = fromNow;
	    proto.to                = to;
	    proto.toNow             = toNow;
	    proto.get               = stringGet;
	    proto.invalidAt         = invalidAt;
	    proto.isAfter           = isAfter;
	    proto.isBefore          = isBefore;
	    proto.isBetween         = isBetween;
	    proto.isSame            = isSame;
	    proto.isSameOrAfter     = isSameOrAfter;
	    proto.isSameOrBefore    = isSameOrBefore;
	    proto.isValid           = isValid$2;
	    proto.lang              = lang;
	    proto.locale            = locale;
	    proto.localeData        = localeData;
	    proto.max               = prototypeMax;
	    proto.min               = prototypeMin;
	    proto.parsingFlags      = parsingFlags;
	    proto.set               = stringSet;
	    proto.startOf           = startOf;
	    proto.subtract          = subtract;
	    proto.toArray           = toArray;
	    proto.toObject          = toObject;
	    proto.toDate            = toDate;
	    proto.toISOString       = toISOString;
	    proto.inspect           = inspect;
	    proto.toJSON            = toJSON;
	    proto.toString          = toString;
	    proto.unix              = unix;
	    proto.valueOf           = valueOf;
	    proto.creationData      = creationData;
	    proto.year       = getSetYear;
	    proto.isLeapYear = getIsLeapYear;
	    proto.weekYear    = getSetWeekYear;
	    proto.isoWeekYear = getSetISOWeekYear;
	    proto.quarter = proto.quarters = getSetQuarter;
	    proto.month       = getSetMonth;
	    proto.daysInMonth = getDaysInMonth;
	    proto.week           = proto.weeks        = getSetWeek;
	    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
	    proto.weeksInYear    = getWeeksInYear;
	    proto.isoWeeksInYear = getISOWeeksInYear;
	    proto.date       = getSetDayOfMonth;
	    proto.day        = proto.days             = getSetDayOfWeek;
	    proto.weekday    = getSetLocaleDayOfWeek;
	    proto.isoWeekday = getSetISODayOfWeek;
	    proto.dayOfYear  = getSetDayOfYear;
	    proto.hour = proto.hours = getSetHour;
	    proto.minute = proto.minutes = getSetMinute;
	    proto.second = proto.seconds = getSetSecond;
	    proto.millisecond = proto.milliseconds = getSetMillisecond;
	    proto.utcOffset            = getSetOffset;
	    proto.utc                  = setOffsetToUTC;
	    proto.local                = setOffsetToLocal;
	    proto.parseZone            = setOffsetToParsedOffset;
	    proto.hasAlignedHourOffset = hasAlignedHourOffset;
	    proto.isDST                = isDaylightSavingTime;
	    proto.isLocal              = isLocal;
	    proto.isUtcOffset          = isUtcOffset;
	    proto.isUtc                = isUtc;
	    proto.isUTC                = isUtc;
	    proto.zoneAbbr = getZoneAbbr;
	    proto.zoneName = getZoneName;
	    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
	    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

	    function createUnix (input) {
	        return createLocal(input * 1000);
	    }

	    function createInZone () {
	        return createLocal.apply(null, arguments).parseZone();
	    }

	    function preParsePostFormat (string) {
	        return string;
	    }

	    var proto$1 = Locale.prototype;

	    proto$1.calendar        = calendar;
	    proto$1.longDateFormat  = longDateFormat;
	    proto$1.invalidDate     = invalidDate;
	    proto$1.ordinal         = ordinal;
	    proto$1.preparse        = preParsePostFormat;
	    proto$1.postformat      = preParsePostFormat;
	    proto$1.relativeTime    = relativeTime;
	    proto$1.pastFuture      = pastFuture;
	    proto$1.set             = set;

	    proto$1.months            =        localeMonths;
	    proto$1.monthsShort       =        localeMonthsShort;
	    proto$1.monthsParse       =        localeMonthsParse;
	    proto$1.monthsRegex       = monthsRegex;
	    proto$1.monthsShortRegex  = monthsShortRegex;
	    proto$1.week = localeWeek;
	    proto$1.firstDayOfYear = localeFirstDayOfYear;
	    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

	    proto$1.weekdays       =        localeWeekdays;
	    proto$1.weekdaysMin    =        localeWeekdaysMin;
	    proto$1.weekdaysShort  =        localeWeekdaysShort;
	    proto$1.weekdaysParse  =        localeWeekdaysParse;

	    proto$1.weekdaysRegex       =        weekdaysRegex;
	    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
	    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

	    proto$1.isPM = localeIsPM;
	    proto$1.meridiem = localeMeridiem;

	    function get$1 (format, index, field, setter) {
	        var locale = getLocale();
	        var utc = createUTC().set(setter, index);
	        return locale[field](utc, format);
	    }

	    function listMonthsImpl (format, index, field) {
	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';

	        if (index != null) {
	            return get$1(format, index, field, 'month');
	        }

	        var i;
	        var out = [];
	        for (i = 0; i < 12; i++) {
	            out[i] = get$1(format, i, field, 'month');
	        }
	        return out;
	    }

	    // ()
	    // (5)
	    // (fmt, 5)
	    // (fmt)
	    // (true)
	    // (true, 5)
	    // (true, fmt, 5)
	    // (true, fmt)
	    function listWeekdaysImpl (localeSorted, format, index, field) {
	        if (typeof localeSorted === 'boolean') {
	            if (isNumber(format)) {
	                index = format;
	                format = undefined;
	            }

	            format = format || '';
	        } else {
	            format = localeSorted;
	            index = format;
	            localeSorted = false;

	            if (isNumber(format)) {
	                index = format;
	                format = undefined;
	            }

	            format = format || '';
	        }

	        var locale = getLocale(),
	            shift = localeSorted ? locale._week.dow : 0;

	        if (index != null) {
	            return get$1(format, (index + shift) % 7, field, 'day');
	        }

	        var i;
	        var out = [];
	        for (i = 0; i < 7; i++) {
	            out[i] = get$1(format, (i + shift) % 7, field, 'day');
	        }
	        return out;
	    }

	    function listMonths (format, index) {
	        return listMonthsImpl(format, index, 'months');
	    }

	    function listMonthsShort (format, index) {
	        return listMonthsImpl(format, index, 'monthsShort');
	    }

	    function listWeekdays (localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	    }

	    function listWeekdaysShort (localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	    }

	    function listWeekdaysMin (localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	    }

	    getSetGlobalLocale('en', {
	        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });

	    // Side effect imports

	    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
	    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

	    var mathAbs = Math.abs;

	    function abs () {
	        var data           = this._data;

	        this._milliseconds = mathAbs(this._milliseconds);
	        this._days         = mathAbs(this._days);
	        this._months       = mathAbs(this._months);

	        data.milliseconds  = mathAbs(data.milliseconds);
	        data.seconds       = mathAbs(data.seconds);
	        data.minutes       = mathAbs(data.minutes);
	        data.hours         = mathAbs(data.hours);
	        data.months        = mathAbs(data.months);
	        data.years         = mathAbs(data.years);

	        return this;
	    }

	    function addSubtract$1 (duration, input, value, direction) {
	        var other = createDuration(input, value);

	        duration._milliseconds += direction * other._milliseconds;
	        duration._days         += direction * other._days;
	        duration._months       += direction * other._months;

	        return duration._bubble();
	    }

	    // supports only 2.0-style add(1, 's') or add(duration)
	    function add$1 (input, value) {
	        return addSubtract$1(this, input, value, 1);
	    }

	    // supports only 2.0-style subtract(1, 's') or subtract(duration)
	    function subtract$1 (input, value) {
	        return addSubtract$1(this, input, value, -1);
	    }

	    function absCeil (number) {
	        if (number < 0) {
	            return Math.floor(number);
	        } else {
	            return Math.ceil(number);
	        }
	    }

	    function bubble () {
	        var milliseconds = this._milliseconds;
	        var days         = this._days;
	        var months       = this._months;
	        var data         = this._data;
	        var seconds, minutes, hours, years, monthsFromDays;

	        // if we have a mix of positive and negative values, bubble down first
	        // check: https://github.com/moment/moment/issues/2166
	        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	                (milliseconds <= 0 && days <= 0 && months <= 0))) {
	            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	            days = 0;
	            months = 0;
	        }

	        // The following code bubbles up values, see the tests for
	        // examples of what that means.
	        data.milliseconds = milliseconds % 1000;

	        seconds           = absFloor(milliseconds / 1000);
	        data.seconds      = seconds % 60;

	        minutes           = absFloor(seconds / 60);
	        data.minutes      = minutes % 60;

	        hours             = absFloor(minutes / 60);
	        data.hours        = hours % 24;

	        days += absFloor(hours / 24);

	        // convert days to months
	        monthsFromDays = absFloor(daysToMonths(days));
	        months += monthsFromDays;
	        days -= absCeil(monthsToDays(monthsFromDays));

	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;

	        data.days   = days;
	        data.months = months;
	        data.years  = years;

	        return this;
	    }

	    function daysToMonths (days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        // 400 years have 12 months === 4800
	        return days * 4800 / 146097;
	    }

	    function monthsToDays (months) {
	        // the reverse of daysToMonths
	        return months * 146097 / 4800;
	    }

	    function as (units) {
	        if (!this.isValid()) {
	            return NaN;
	        }
	        var days;
	        var months;
	        var milliseconds = this._milliseconds;

	        units = normalizeUnits(units);

	        if (units === 'month' || units === 'quarter' || units === 'year') {
	            days = this._days + milliseconds / 864e5;
	            months = this._months + daysToMonths(days);
	            switch (units) {
	                case 'month':   return months;
	                case 'quarter': return months / 3;
	                case 'year':    return months / 12;
	            }
	        } else {
	            // handle milliseconds separately because of floating point math errors (issue #1867)
	            days = this._days + Math.round(monthsToDays(this._months));
	            switch (units) {
	                case 'week'   : return days / 7     + milliseconds / 6048e5;
	                case 'day'    : return days         + milliseconds / 864e5;
	                case 'hour'   : return days * 24    + milliseconds / 36e5;
	                case 'minute' : return days * 1440  + milliseconds / 6e4;
	                case 'second' : return days * 86400 + milliseconds / 1000;
	                // Math.floor prevents floating point math errors here
	                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	                default: throw new Error('Unknown unit ' + units);
	            }
	        }
	    }

	    // TODO: Use this.as('ms')?
	    function valueOf$1 () {
	        if (!this.isValid()) {
	            return NaN;
	        }
	        return (
	            this._milliseconds +
	            this._days * 864e5 +
	            (this._months % 12) * 2592e6 +
	            toInt(this._months / 12) * 31536e6
	        );
	    }

	    function makeAs (alias) {
	        return function () {
	            return this.as(alias);
	        };
	    }

	    var asMilliseconds = makeAs('ms');
	    var asSeconds      = makeAs('s');
	    var asMinutes      = makeAs('m');
	    var asHours        = makeAs('h');
	    var asDays         = makeAs('d');
	    var asWeeks        = makeAs('w');
	    var asMonths       = makeAs('M');
	    var asQuarters     = makeAs('Q');
	    var asYears        = makeAs('y');

	    function clone$1 () {
	        return createDuration(this);
	    }

	    function get$2 (units) {
	        units = normalizeUnits(units);
	        return this.isValid() ? this[units + 's']() : NaN;
	    }

	    function makeGetter(name) {
	        return function () {
	            return this.isValid() ? this._data[name] : NaN;
	        };
	    }

	    var milliseconds = makeGetter('milliseconds');
	    var seconds      = makeGetter('seconds');
	    var minutes      = makeGetter('minutes');
	    var hours        = makeGetter('hours');
	    var days         = makeGetter('days');
	    var months       = makeGetter('months');
	    var years        = makeGetter('years');

	    function weeks () {
	        return absFloor(this.days() / 7);
	    }

	    var round = Math.round;
	    var thresholds = {
	        ss: 44,         // a few seconds to seconds
	        s : 45,         // seconds to minute
	        m : 45,         // minutes to hour
	        h : 22,         // hours to day
	        d : 26,         // days to month
	        M : 11          // months to year
	    };

	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }

	    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
	        var duration = createDuration(posNegDuration).abs();
	        var seconds  = round(duration.as('s'));
	        var minutes  = round(duration.as('m'));
	        var hours    = round(duration.as('h'));
	        var days     = round(duration.as('d'));
	        var months   = round(duration.as('M'));
	        var years    = round(duration.as('y'));

	        var a = seconds <= thresholds.ss && ['s', seconds]  ||
	                seconds < thresholds.s   && ['ss', seconds] ||
	                minutes <= 1             && ['m']           ||
	                minutes < thresholds.m   && ['mm', minutes] ||
	                hours   <= 1             && ['h']           ||
	                hours   < thresholds.h   && ['hh', hours]   ||
	                days    <= 1             && ['d']           ||
	                days    < thresholds.d   && ['dd', days]    ||
	                months  <= 1             && ['M']           ||
	                months  < thresholds.M   && ['MM', months]  ||
	                years   <= 1             && ['y']           || ['yy', years];

	        a[2] = withoutSuffix;
	        a[3] = +posNegDuration > 0;
	        a[4] = locale;
	        return substituteTimeAgo.apply(null, a);
	    }

	    // This function allows you to set the rounding function for relative time strings
	    function getSetRelativeTimeRounding (roundingFunction) {
	        if (roundingFunction === undefined) {
	            return round;
	        }
	        if (typeof(roundingFunction) === 'function') {
	            round = roundingFunction;
	            return true;
	        }
	        return false;
	    }

	    // This function allows you to set a threshold for relative time strings
	    function getSetRelativeTimeThreshold (threshold, limit) {
	        if (thresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return thresholds[threshold];
	        }
	        thresholds[threshold] = limit;
	        if (threshold === 's') {
	            thresholds.ss = limit - 1;
	        }
	        return true;
	    }

	    function humanize (withSuffix) {
	        if (!this.isValid()) {
	            return this.localeData().invalidDate();
	        }

	        var locale = this.localeData();
	        var output = relativeTime$1(this, !withSuffix, locale);

	        if (withSuffix) {
	            output = locale.pastFuture(+this, output);
	        }

	        return locale.postformat(output);
	    }

	    var abs$1 = Math.abs;

	    function sign(x) {
	        return ((x > 0) - (x < 0)) || +x;
	    }

	    function toISOString$1() {
	        // for ISO strings we do not use the normal bubbling rules:
	        //  * milliseconds bubble up until they become hours
	        //  * days do not bubble at all
	        //  * months bubble up until they become years
	        // This is because there is no context-free conversion between hours and days
	        // (think of clock changes)
	        // and also not between days and months (28-31 days per month)
	        if (!this.isValid()) {
	            return this.localeData().invalidDate();
	        }

	        var seconds = abs$1(this._milliseconds) / 1000;
	        var days         = abs$1(this._days);
	        var months       = abs$1(this._months);
	        var minutes, hours, years;

	        // 3600 seconds -> 60 minutes -> 1 hour
	        minutes           = absFloor(seconds / 60);
	        hours             = absFloor(minutes / 60);
	        seconds %= 60;
	        minutes %= 60;

	        // 12 months -> 1 year
	        years  = absFloor(months / 12);
	        months %= 12;


	        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	        var Y = years;
	        var M = months;
	        var D = days;
	        var h = hours;
	        var m = minutes;
	        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
	        var total = this.asSeconds();

	        if (!total) {
	            // this is the same as C#'s (Noda) and python (isodate)...
	            // but not other JS (goog.date)
	            return 'P0D';
	        }

	        var totalSign = total < 0 ? '-' : '';
	        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
	        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
	        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

	        return totalSign + 'P' +
	            (Y ? ymSign + Y + 'Y' : '') +
	            (M ? ymSign + M + 'M' : '') +
	            (D ? daysSign + D + 'D' : '') +
	            ((h || m || s) ? 'T' : '') +
	            (h ? hmsSign + h + 'H' : '') +
	            (m ? hmsSign + m + 'M' : '') +
	            (s ? hmsSign + s + 'S' : '');
	    }

	    var proto$2 = Duration.prototype;

	    proto$2.isValid        = isValid$1;
	    proto$2.abs            = abs;
	    proto$2.add            = add$1;
	    proto$2.subtract       = subtract$1;
	    proto$2.as             = as;
	    proto$2.asMilliseconds = asMilliseconds;
	    proto$2.asSeconds      = asSeconds;
	    proto$2.asMinutes      = asMinutes;
	    proto$2.asHours        = asHours;
	    proto$2.asDays         = asDays;
	    proto$2.asWeeks        = asWeeks;
	    proto$2.asMonths       = asMonths;
	    proto$2.asQuarters     = asQuarters;
	    proto$2.asYears        = asYears;
	    proto$2.valueOf        = valueOf$1;
	    proto$2._bubble        = bubble;
	    proto$2.clone          = clone$1;
	    proto$2.get            = get$2;
	    proto$2.milliseconds   = milliseconds;
	    proto$2.seconds        = seconds;
	    proto$2.minutes        = minutes;
	    proto$2.hours          = hours;
	    proto$2.days           = days;
	    proto$2.weeks          = weeks;
	    proto$2.months         = months;
	    proto$2.years          = years;
	    proto$2.humanize       = humanize;
	    proto$2.toISOString    = toISOString$1;
	    proto$2.toString       = toISOString$1;
	    proto$2.toJSON         = toISOString$1;
	    proto$2.locale         = locale;
	    proto$2.localeData     = localeData;

	    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
	    proto$2.lang = lang;

	    // Side effect imports

	    // FORMATTING

	    addFormatToken('X', 0, 0, 'unix');
	    addFormatToken('x', 0, 0, 'valueOf');

	    // PARSING

	    addRegexToken('x', matchSigned);
	    addRegexToken('X', matchTimestamp);
	    addParseToken('X', function (input, array, config) {
	        config._d = new Date(parseFloat(input, 10) * 1000);
	    });
	    addParseToken('x', function (input, array, config) {
	        config._d = new Date(toInt(input));
	    });

	    // Side effect imports


	    hooks.version = '2.24.0';

	    setHookCallback(createLocal);

	    hooks.fn                    = proto;
	    hooks.min                   = min;
	    hooks.max                   = max;
	    hooks.now                   = now;
	    hooks.utc                   = createUTC;
	    hooks.unix                  = createUnix;
	    hooks.months                = listMonths;
	    hooks.isDate                = isDate;
	    hooks.locale                = getSetGlobalLocale;
	    hooks.invalid               = createInvalid;
	    hooks.duration              = createDuration;
	    hooks.isMoment              = isMoment;
	    hooks.weekdays              = listWeekdays;
	    hooks.parseZone             = createInZone;
	    hooks.localeData            = getLocale;
	    hooks.isDuration            = isDuration;
	    hooks.monthsShort           = listMonthsShort;
	    hooks.weekdaysMin           = listWeekdaysMin;
	    hooks.defineLocale          = defineLocale;
	    hooks.updateLocale          = updateLocale;
	    hooks.locales               = listLocales;
	    hooks.weekdaysShort         = listWeekdaysShort;
	    hooks.normalizeUnits        = normalizeUnits;
	    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
	    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
	    hooks.calendarFormat        = getCalendarFormat;
	    hooks.prototype             = proto;

	    // currently HTML5 input type only supports 24-hour formats
	    hooks.HTML5_FMT = {
	        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
	        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
	        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
	        DATE: 'YYYY-MM-DD',                             // <input type="date" />
	        TIME: 'HH:mm',                                  // <input type="time" />
	        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
	        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
	        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
	        MONTH: 'YYYY-MM'                                // <input type="month" />
	    };

	    return hooks;

	})));
	});

	var underscore = createCommonjsModule(function (module, exports) {
	//     Underscore.js 1.9.1
	//     http://underscorejs.org
	//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` (`self`) in the browser, `global`
	  // on the server, or `this` in some virtual machines. We use `self`
	  // instead of `window` for `WebWorker` support.
	  var root = typeof self == 'object' && self.self === self && self ||
	            typeof commonjsGlobal == 'object' && commonjsGlobal.global === commonjsGlobal && commonjsGlobal ||
	            this ||
	            {};

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
	  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

	  // Create quick reference variables for speed access to core prototypes.
	  var push = ArrayProto.push,
	      slice = ArrayProto.slice,
	      toString = ObjProto.toString,
	      hasOwnProperty = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var nativeIsArray = Array.isArray,
	      nativeKeys = Object.keys,
	      nativeCreate = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for their old module API. If we're in
	  // the browser, add `_` as a global object.
	  // (`nodeType` is checked to ensure that `module`
	  // and `exports` are not HTML elements.)
	  if ( !exports.nodeType) {
	    if ( !module.nodeType && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.9.1';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      // The 2-argument case is omitted because we’re not using it.
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  var builtinIteratee;

	  // An internal function to generate callbacks that can be applied to each
	  // element in a collection, returning the desired result — either `identity`,
	  // an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
	    return _.property(value);
	  };

	  // External wrapper for our callback generator. Users may customize
	  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
	  // This abstraction hides the internal-only argCount argument.
	  _.iteratee = builtinIteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // Some functions take a variable number of arguments, or a few expected
	  // arguments at the beginning and then a variable number of values to operate
	  // on. This helper accumulates all remaining arguments past the function’s
	  // argument length (or an explicit `startIndex`), into an array that becomes
	  // the last argument. Similar to ES6’s "rest parameter".
	  var restArguments = function(func, startIndex) {
	    startIndex = startIndex == null ? func.length - 1 : +startIndex;
	    return function() {
	      var length = Math.max(arguments.length - startIndex, 0),
	          rest = Array(length),
	          index = 0;
	      for (; index < length; index++) {
	        rest[index] = arguments[index + startIndex];
	      }
	      switch (startIndex) {
	        case 0: return func.call(this, rest);
	        case 1: return func.call(this, arguments[0], rest);
	        case 2: return func.call(this, arguments[0], arguments[1], rest);
	      }
	      var args = Array(startIndex + 1);
	      for (index = 0; index < startIndex; index++) {
	        args[index] = arguments[index];
	      }
	      args[startIndex] = rest;
	      return func.apply(this, args);
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var shallowProperty = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  var has = function(obj, path) {
	    return obj != null && hasOwnProperty.call(obj, path);
	  };

	  var deepGet = function(obj, path) {
	    var length = path.length;
	    for (var i = 0; i < length; i++) {
	      if (obj == null) return void 0;
	      obj = obj[path[i]];
	    }
	    return length ? obj : void 0;
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object.
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = shallowProperty('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  var createReduce = function(dir) {
	    // Wrap code that reassigns argument variables in a separate function than
	    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
	    var reducer = function(obj, iteratee, memo, initial) {
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      if (!initial) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    };

	    return function(obj, iteratee, memo, context) {
	      var initial = arguments.length >= 3;
	      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
	    };
	  };

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
	    var key = keyFinder(obj, predicate, context);
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = restArguments(function(obj, path, args) {
	    var contextPath, func;
	    if (_.isFunction(path)) {
	      func = path;
	    } else if (_.isArray(path)) {
	      contextPath = path.slice(0, -1);
	      path = path[path.length - 1];
	    }
	    return _.map(obj, function(context) {
	      var method = func;
	      if (!method) {
	        if (contextPath && contextPath.length) {
	          context = deepGet(context, contextPath);
	        }
	        if (context == null) return void 0;
	        method = context[path];
	      }
	      return method == null ? method : method.apply(context, args);
	    });
	  });

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value != null && value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(v, index, list) {
	        computed = iteratee(v, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = v;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value != null && value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(v, index, list) {
	        computed = iteratee(v, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = v;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection.
	  _.shuffle = function(obj) {
	    return _.sample(obj, Infinity);
	  };

	  // Sample **n** random values from a collection using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
	    var length = getLength(sample);
	    n = Math.max(Math.min(n, length), 0);
	    var last = length - 1;
	    for (var index = 0; index < n; index++) {
	      var rand = _.random(index, last);
	      var temp = sample[index];
	      sample[index] = sample[rand];
	      sample[rand] = temp;
	    }
	    return sample.slice(0, n);
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    var index = 0;
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, key, list) {
	      return {
	        value: value,
	        index: index++,
	        criteria: iteratee(value, key, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior, partition) {
	    return function(obj, iteratee, context) {
	      var result = partition ? [[], []] : {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (has(result, key)) result[key]++; else result[key] = 1;
	  });

	  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (_.isString(obj)) {
	      // Keep surrogate pair characters together
	      return obj.match(reStrSymbol);
	    }
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = group(function(result, value, pass) {
	    result[pass ? 0 : 1].push(value);
	  }, true);

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null || array.length < 1) return n == null ? void 0 : [];
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null || array.length < 1) return n == null ? void 0 : [];
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, Boolean);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, output) {
	    output = output || [];
	    var idx = output.length;
	    for (var i = 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        // Flatten current level of array or arguments object.
	        if (shallow) {
	          var j = 0, len = value.length;
	          while (j < len) output[idx++] = value[j++];
	        } else {
	          flatten(value, shallow, strict, output);
	          idx = output.length;
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = restArguments(function(array, otherArrays) {
	    return _.difference(array, otherArrays);
	  });

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // The faster algorithm will not work with an iteratee if the iteratee
	  // is not a one-to-one function, so providing an iteratee will disable
	  // the faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted && !iteratee) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = restArguments(function(arrays) {
	    return _.uniq(flatten(arrays, true, true));
	  });

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      var j;
	      for (j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = restArguments(function(array, rest) {
	    rest = flatten(rest, true, true);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  });

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices.
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = restArguments(_.unzip);

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values. Passing by pairs is the reverse of _.pairs.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions.
	  var createPredicateIndexFinder = function(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  };

	  // Returns the first index on an array-like that passes a predicate test.
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions.
	  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	          i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  };

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    if (!step) {
	      step = stop < start ? -1 : 1;
	    }

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Chunk a single array into multiple arrays, each containing `count` or fewer
	  // items.
	  _.chunk = function(array, count) {
	    if (count == null || count < 1) return [];
	    var result = [];
	    var i = 0, length = array.length;
	    while (i < length) {
	      result.push(slice.call(array, i, i += count));
	    }
	    return result;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments.
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = restArguments(function(func, context, args) {
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var bound = restArguments(function(callArgs) {
	      return executeBound(func, bound, context, this, args.concat(callArgs));
	    });
	    return bound;
	  });

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder by default, allowing any combination of arguments to be
	  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
	  _.partial = restArguments(function(func, boundArgs) {
	    var placeholder = _.partial.placeholder;
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  });

	  _.partial.placeholder = _;

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = restArguments(function(obj, keys) {
	    keys = flatten(keys, false, false);
	    var index = keys.length;
	    if (index < 1) throw new Error('bindAll must be passed function names');
	    while (index--) {
	      var key = keys[index];
	      obj[key] = _.bind(obj[key], obj);
	    }
	  });

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = restArguments(function(func, wait, args) {
	    return setTimeout(function() {
	      return func.apply(null, args);
	    }, wait);
	  });

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var timeout, context, args, result;
	    var previous = 0;
	    if (!options) options = {};

	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };

	    var throttled = function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };

	    throttled.cancel = function() {
	      clearTimeout(timeout);
	      previous = 0;
	      timeout = context = args = null;
	    };

	    return throttled;
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, result;

	    var later = function(context, args) {
	      timeout = null;
	      if (args) result = func.apply(context, args);
	    };

	    var debounced = restArguments(function(args) {
	      if (timeout) clearTimeout(timeout);
	      if (immediate) {
	        var callNow = !timeout;
	        timeout = setTimeout(later, wait);
	        if (callNow) result = func.apply(this, args);
	      } else {
	        timeout = _.delay(later, wait, this, args);
	      }

	      return result;
	    });

	    debounced.cancel = function() {
	      clearTimeout(timeout);
	      timeout = null;
	    };

	    return debounced;
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  _.restArguments = restArguments;

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  var collectNonEnumProps = function(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  };

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`.
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object.
	  // In contrast to _.map it returns an object.
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = _.keys(obj),
	        length = keys.length,
	        results = {};
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys[index];
	      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  // The opposite of _.object.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`.
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, defaults) {
	    return function(obj) {
	      var length = arguments.length;
	      if (defaults) obj = Object(obj);
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!defaults || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s).
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test.
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Internal pick helper function to determine if `obj` has key `key`.
	  var keyInObj = function(value, key, obj) {
	    return key in obj;
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = restArguments(function(obj, keys) {
	    var result = {}, iteratee = keys[0];
	    if (obj == null) return result;
	    if (_.isFunction(iteratee)) {
	      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
	      keys = _.allKeys(obj);
	    } else {
	      iteratee = keyInObj;
	      keys = flatten(keys, false, false);
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  });

	  // Return a copy of the object without the blacklisted properties.
	  _.omit = restArguments(function(obj, keys) {
	    var iteratee = keys[0], context;
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	      if (keys.length > 1) context = keys[1];
	    } else {
	      keys = _.map(flatten(keys, false, false), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  });

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq, deepEq;
	  eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // `null` or `undefined` only equal to itself (strict comparison).
	    if (a == null || b == null) return false;
	    // `NaN`s are equivalent, but non-reflexive.
	    if (a !== a) return b !== b;
	    // Exhaust primitive checks
	    var type = typeof a;
	    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
	    return deepEq(a, b, aStack, bStack);
	  };

	  // Internal recursive comparison function for `isEqual`.
	  deepEq = function(a, b, aStack, bStack) {
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN.
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	      case '[object Symbol]':
	        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
	  var nodelist = root.document && root.document.childNodes;
	  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`?
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && isNaN(obj);
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, path) {
	    if (!_.isArray(path)) {
	      return has(obj, path);
	    }
	    var length = path.length;
	    for (var i = 0; i < length; i++) {
	      var key = path[i];
	      if (obj == null || !hasOwnProperty.call(obj, key)) {
	        return false;
	      }
	      obj = obj[key];
	    }
	    return !!length;
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  // Creates a function that, when passed an object, will traverse that object’s
	  // properties down the given `path`, specified as an array of keys or indexes.
	  _.property = function(path) {
	    if (!_.isArray(path)) {
	      return shallowProperty(path);
	    }
	    return function(obj) {
	      return deepGet(obj, path);
	    };
	  };

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    if (obj == null) {
	      return function(){};
	    }
	    return function(path) {
	      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	  // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped.
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // Traverses the children of `obj` along `path`. If a child is a function, it
	  // is invoked with its parent as context. Returns the value of the final
	  // child, or `fallback` if any child is undefined.
	  _.result = function(obj, path, fallback) {
	    if (!_.isArray(path)) path = [path];
	    var length = path.length;
	    if (!length) {
	      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
	    }
	    for (var i = 0; i < length; i++) {
	      var prop = obj == null ? void 0 : obj[path[i]];
	      if (prop === void 0) {
	        prop = fallback;
	        i = length; // Ensure we don't continue iterating.
	      }
	      obj = _.isFunction(prop) ? prop.call(obj) : prop;
	    }
	    return obj;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate: /<%([\s\S]+?)%>/g,
	    interpolate: /<%=([\s\S]+?)%>/g,
	    escape: /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'": "'",
	    '\\': '\\',
	    '\r': 'r',
	    '\n': 'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offset.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    var render;
	    try {
	      render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var chainResult = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return chainResult(this, func.apply(_, args));
	      };
	    });
	    return _;
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return chainResult(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return chainResult(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return String(this._wrapped);
	  };
	}());
	});
	var underscore_1 = underscore._;

	var sprintf$1 = createCommonjsModule(function (module, exports) {
	/* global window, exports, define */

	!function() {

	    var re = {
	        not_string: /[^s]/,
	        not_bool: /[^t]/,
	        not_type: /[^T]/,
	        not_primitive: /[^v]/,
	        number: /[diefg]/,
	        numeric_arg: /[bcdiefguxX]/,
	        json: /[j]/,
	        not_json: /[^j]/,
	        text: /^[^\x25]+/,
	        modulo: /^\x25{2}/,
	        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
	        key: /^([a-z_][a-z_\d]*)/i,
	        key_access: /^\.([a-z_][a-z_\d]*)/i,
	        index_access: /^\[(\d+)\]/,
	        sign: /^[+-]/
	    };

	    function sprintf(key) {
	        // `arguments` is not an array, but should be fine for this call
	        return sprintf_format(sprintf_parse(key), arguments)
	    }

	    function vsprintf(fmt, argv) {
	        return sprintf.apply(null, [fmt].concat(argv || []))
	    }

	    function sprintf_format(parse_tree, argv) {
	        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign;
	        for (i = 0; i < tree_length; i++) {
	            if (typeof parse_tree[i] === 'string') {
	                output += parse_tree[i];
	            }
	            else if (typeof parse_tree[i] === 'object') {
	                ph = parse_tree[i]; // convenience purposes only
	                if (ph.keys) { // keyword argument
	                    arg = argv[cursor];
	                    for (k = 0; k < ph.keys.length; k++) {
	                        if (arg == undefined) {
	                            throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k-1]))
	                        }
	                        arg = arg[ph.keys[k]];
	                    }
	                }
	                else if (ph.param_no) { // positional argument (explicit)
	                    arg = argv[ph.param_no];
	                }
	                else { // positional argument (implicit)
	                    arg = argv[cursor++];
	                }

	                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
	                    arg = arg();
	                }

	                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {
	                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))
	                }

	                if (re.number.test(ph.type)) {
	                    is_positive = arg >= 0;
	                }

	                switch (ph.type) {
	                    case 'b':
	                        arg = parseInt(arg, 10).toString(2);
	                        break
	                    case 'c':
	                        arg = String.fromCharCode(parseInt(arg, 10));
	                        break
	                    case 'd':
	                    case 'i':
	                        arg = parseInt(arg, 10);
	                        break
	                    case 'j':
	                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
	                        break
	                    case 'e':
	                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
	                        break
	                    case 'f':
	                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
	                        break
	                    case 'g':
	                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
	                        break
	                    case 'o':
	                        arg = (parseInt(arg, 10) >>> 0).toString(8);
	                        break
	                    case 's':
	                        arg = String(arg);
	                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
	                        break
	                    case 't':
	                        arg = String(!!arg);
	                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
	                        break
	                    case 'T':
	                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
	                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
	                        break
	                    case 'u':
	                        arg = parseInt(arg, 10) >>> 0;
	                        break
	                    case 'v':
	                        arg = arg.valueOf();
	                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
	                        break
	                    case 'x':
	                        arg = (parseInt(arg, 10) >>> 0).toString(16);
	                        break
	                    case 'X':
	                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
	                        break
	                }
	                if (re.json.test(ph.type)) {
	                    output += arg;
	                }
	                else {
	                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
	                        sign = is_positive ? '+' : '-';
	                        arg = arg.toString().replace(re.sign, '');
	                    }
	                    else {
	                        sign = '';
	                    }
	                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';
	                    pad_length = ph.width - (sign + arg).length;
	                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : '';
	                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg);
	                }
	            }
	        }
	        return output
	    }

	    var sprintf_cache = Object.create(null);

	    function sprintf_parse(fmt) {
	        if (sprintf_cache[fmt]) {
	            return sprintf_cache[fmt]
	        }

	        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
	        while (_fmt) {
	            if ((match = re.text.exec(_fmt)) !== null) {
	                parse_tree.push(match[0]);
	            }
	            else if ((match = re.modulo.exec(_fmt)) !== null) {
	                parse_tree.push('%');
	            }
	            else if ((match = re.placeholder.exec(_fmt)) !== null) {
	                if (match[2]) {
	                    arg_names |= 1;
	                    var field_list = [], replacement_field = match[2], field_match = [];
	                    if ((field_match = re.key.exec(replacement_field)) !== null) {
	                        field_list.push(field_match[1]);
	                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
	                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
	                                field_list.push(field_match[1]);
	                            }
	                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
	                                field_list.push(field_match[1]);
	                            }
	                            else {
	                                throw new SyntaxError('[sprintf] failed to parse named argument key')
	                            }
	                        }
	                    }
	                    else {
	                        throw new SyntaxError('[sprintf] failed to parse named argument key')
	                    }
	                    match[2] = field_list;
	                }
	                else {
	                    arg_names |= 2;
	                }
	                if (arg_names === 3) {
	                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
	                }

	                parse_tree.push(
	                    {
	                        placeholder: match[0],
	                        param_no:    match[1],
	                        keys:        match[2],
	                        sign:        match[3],
	                        pad_char:    match[4],
	                        align:       match[5],
	                        width:       match[6],
	                        precision:   match[7],
	                        type:        match[8]
	                    }
	                );
	            }
	            else {
	                throw new SyntaxError('[sprintf] unexpected placeholder')
	            }
	            _fmt = _fmt.substring(match[0].length);
	        }
	        return sprintf_cache[fmt] = parse_tree
	    }

	    /**
	     * export to either browser or node.js
	     */
	    /* eslint-disable quote-props */
	    {
	        exports['sprintf'] = sprintf;
	        exports['vsprintf'] = vsprintf;
	    }
	    if (typeof window !== 'undefined') {
	        window['sprintf'] = sprintf;
	        window['vsprintf'] = vsprintf;
	    }
	    /* eslint-enable quote-props */
	}(); // eslint-disable-line
	});

	// OrdMap {{{1

	/**
	 * Create a map (a.k.a. dictionary) where the order of the keys added to the data structure is
	 * maintained.
	 *
	 * @class
	 *
	 * @property {Array<string>} keys List of all keys, in the order they were inserted.
	 * @property {Object<string, number>} keyIndex Associates key with the index it was inserted at.
	 * @property {Object} map Contains all the data inserted.
	 * @property {number} size Number of elements in the map.
	 */

	function OrdMap() {
		this._keys = [];
		this._keyIndex = {};
		this._map = {};
		this._size = 0;
		this._setHandlers = {};
	}

	Object.defineProperty(OrdMap, 'name', {value: 'OrdMap'});
	OrdMap.prototype = Object.create(Object.prototype);
	OrdMap.prototype.constructor = OrdMap;

	// .fromArray {{{2

	/**
	 * Construct a new OrdMap from an array of values.
	 *
	 * @method
	 *
	 * @param {Array.<object>} values The values to add to the new OrdMap.
	 * @param {string} keyField Name of the field to use as the key.
	 * @returns {OrdMap} An OrdMap containing the values.
	 */

	OrdMap.fromArray = function (values, keyField) {
		var o = new OrdMap();

		for (var i = 0; i < values.length; i += 1) {
			o.set(values[i][keyField], values[i]);
		}

		return o;
	};

	// .fromMerge {{{2

	/**
	 * Construct a new OrdMap by merging several OrdMaps together.
	 *
	 * @param {Array.<OrdMap>} maps
	 * The OrdMaps to merge.
	 */

	OrdMap.fromMerge = function (maps) {
		var o = new OrdMap();

		for (var i = 0; i < maps.length; i += 1) {
			if (!(maps[i] instanceof OrdMap)) {
				throw new Error('Call Error: `maps[' + i + ']` must be an OrdMap');
			}
			maps[i].each(function (v, k) {
				if (!o.isSet(k)) {
					o.set(k, v);
				}
			});
		}

		return o;
	};
	// .deserialize {{{2

	OrdMap.deserialize = function (x) {
		var result = new OrdMap();

		if (typeof x === 'string') {
			x = JSON.parse(x);
		}

		for (var i = 0; i < x._keys.length; i += 1) {
			if (x._map[x._keys[i]] !== undefined) {
				result.set(x._keys[i], x._map[x._keys[i]]);
			}
		}

		return result;
	};

	// #get {{{2

	/**
	 * Retrieve a key/value association from the map.
	 *
	 * @method
	 *
	 * @param {string} k The key to retrieve.
	 * @param {any} d The default to return if `k` is not set.
	 * @returns {any} The value associated with that key.
	 */

	OrdMap.prototype.get = function (k, d) {
		return this.isSet(k) ? this._map[k] : d;
	};

	// #set {{{2

	/**
	 * Create a key/value association in the map.
	 *
	 * @method
	 *
	 * @param {string} k The key to use.
	 * @param {any} v The value to use.
	 */

	OrdMap.prototype.set = function (k, v) {
		if (!this.isSet(k)) {
			this._keys.push(k);
			this._keyIndex[k] = this._keys.length - 1;
			this._size += 1;
		}

		this._map[k] = v;

		// Invoke all the handlers for when this value was set.

		if (this._setHandlers[k] != null) {
			for (var i = 0; i < this._setHandlers[k].length; i += 1) {
				this._setHandlers[k][i](v);
			}
			this._setHandlers[k] = null;
		}
	};

	// #append {{{2

	OrdMap.prototype.append = function (k, v) {
		if (this.isSet(k)) {
			if (!Array.isArray(this._map[k])) {
				this._map[k] = [this._map[k]];
			}
			this._map[k].push(v);
		}
		else {
			this.set(k, [v]);
		}
	};

	// #unset {{{2

	/**
	 * Remove a key/value association from the map.
	 *
	 * @method
	 *
	 * @param {string} k The key for the association to remove.
	 */

	OrdMap.prototype.unset = function (k) {
		delete this._keyIndex[k];
		delete this._map[k];
		this._size -= 1;
	};

	// #isSet {{{2

	/**
	 * Indicate if there is an association set for the specified key.
	 *
	 * @method
	 *
	 * @param {string} k The key to check on.
	 * @returns {boolean} True if there is an association for this key, false if there is not.
	 */

	OrdMap.prototype.isSet = function (k) {
		return this._keyIndex[k] !== undefined;
	};

	// #each {{{2

	/**
	 * Iterate over the map in the order of the keys inserted.  This is the principle way in which
	 * OrdMap differs from a regular JavaScript object.
	 *
	 * @method
	 *
	 * @param {function} f A function called for each existing association.  The function is invoked
	 * like this: f(VALUE, KEY, KEY-NUMBER).
	 */

	OrdMap.prototype.each = function (f) {
		var i, j = 0,
			k, v, keyLen = this._keys.length;
		for (i = 0; i < keyLen; i += 1) {
			k = this._keys[i];
			if (this._keyIndex[k] === i) {
				v = this._map[k];
				f(v, k, j);
				j += 1;
			}
		}
	};

	// #keys {{{2

	/**
	 * Get a list of the keys used, in the order they were inserted.
	 *
	 * @method
	 *
	 * @returns {array} All the keys in order.
	 */

	OrdMap.prototype.keys = function () {
		var i, k, result = [], keyLen = this._keys.length;
		for (i = 0; i < keyLen; i += 1) {
			k = this._keys[i];
			if (this._keyIndex[k] === i) {
				result.push(k);
			}
		}
		return result;
	};

	// #toString {{{2

	OrdMap.prototype.toString = function () {
		var s = '';
		this.each(function (v, k) {
			v = JSON.stringify(v);
			if (v == null) {
				v = 'null';
			}
			if (s !== '') {
				s += ', ';
			}
			s += '"' + k + '": ' + v;
		});
		return '{' + s + '}';
	};

	// #asMap {{{2

	/**
	 * Returns the internal representation of this ordered map as a regular JS object (a map with no
	 * way to tell the order).  Changing the return value will change the internal representation of
	 * this ordered map, so adding/removing keys will completely screw the `OrdMap` instance up!
	 */

	OrdMap.prototype.asMap = function () {
		return this._map;
	};

	// #serialize / #toJSON {{{2

	OrdMap.prototype.serialize = function () {
		return {
			_keys: this.keys(),
			_map: this.asMap()
		};
	};

	OrdMap.prototype.toJSON = OrdMap.prototype.serialize;

	// #size {{{2

	/**
	 * Tells the number of keys.
	 */

	OrdMap.prototype.size = function () {
		return this._size;
	};

	/**
	 * Call an event handler when a key is set in this map.  If the key is already set, then the handler
	 * is invoked immediately.
	 *
	 * @param {string} k
	 * The key to monitor.
	 *
	 * @param {function} h
	 * The handler to set.
	 */

	OrdMap.prototype.whenSet = function (k, h, opts) {
		opts = opts || {};

		if (opts.prepend == null) {
			opts.prepend = false;
		}

		if (this.isSet(k)) {
			return h(this.get(k));
		}

		if (this._setHandlers[k] == null) {
			this._setHandlers[k] = [];
		}

		if (opts.prepend) {
			this._setHandlers[k].unshift(h);
		}
		else {
			this._setHandlers[k].push(h);
		}
	};

	// #filter {{{2

	OrdMap.prototype.filter = function (test) {
		var result = new OrdMap();

		this.each(function (v, k) {
			if (test(v, k)) {
				result.set(k, v);
			}
		});

		return result;
	};

	// #clone {{{2

	OrdMap.prototype.clone = function () {
		var result = new OrdMap();

		this.each(function (v, k) {
			result.set(k, deepCopy(v));
		});

		return result;
	};

	// #clear {{{2

	OrdMap.prototype.clear = function () {
		this._keys = [];
		this._keyIndex = {};
		this._map = {};
		this._size = 0;
	};

	// #replaceWith {{{2

	OrdMap.prototype.replaceWith = function (o) {
		var self = this;

		if (!(o instanceof OrdMap)) {
			throw new Error('Call Error: `o` must be an instance of OrdMap');
		}

		self.clear();
		o.each(function (v, k) {
			self.set(k, v);
		});
	};

	// #mergeWith {{{2

	OrdMap.prototype.mergeWith = function (o) {
		var self = this;
		var numSet = 0;

		if (!(o instanceof OrdMap)) {
			throw new Error('Call Error: `o` must be an instance of OrdMap');
		}

		o.each(function (v, k) {
			if (!self.isSet(k)) {
				self.set(k, v);
				numSet += 1;
			}
		});

		return numSet;
	};

	// #_changeKeyIndex {{{2

	OrdMap.prototype._changeKeyIndex = function (oldIndex, newIndex) {
		var self = this;

		var key = self._keys[oldIndex];
		self._keys.splice(oldIndex, 1);
		self._keys.splice(newIndex, 0, key);
	};

	// Lock {{{1
	// Constructor {{{2

	/**
	 * An implementation of a counting semaphore for JavaScript.
	 * @class
	 */

	var Lock = function (name, opts) {
		var self = this;

		self._opts = opts || {};

		if (self._opts.debug == null) {
			self._opts.debug = true;
		}

		self._name = name || '#' + (Lock._id++);
		self._lockCount = 0;
		self._onUnlock = [];

		if (!self._opts.debug) {
			self.debug = NOP;
		}
	};

	Lock._id = 1;

	mixinDebugging(Lock, function () {
		return 'LOCK - ' + this._name + ' (level ' + this._lockCount + ')';
	});

	// #lock {{{2

	/**
	 * Engage the lock.  A lock can be engaged multiple times.  Each lock operation must be unlocked
	 * separately to fully disengage the lock.
	 *
	 * @method
	 */

	Lock.prototype.lock = function (why) {
		var self = this;

		this._lockCount += 1;

		var msg = 'Locking to level: ' + self._lockCount;

		if (why != null) {
			msg += ' - ' + why;
		}

		self.debug(null, msg);
	};

	// #unlock {{{2

	/**
	 * Disengage the lock.  A lock can be engaged multiple times.  Each lock operation must be unlocked
	 * separately to fully disengage the lock.
	 *
	 * @method
	 */

	Lock.prototype.unlock = function () {
		var self = this;

		self._lockCount -= 1;
		self.debug(null, 'Unlocking to level: ' + self._lockCount);

		// If we're completely unlocked, start going through the functions that were registered to be run.
		// The only problem is that these functions can cause us to be locked again.  If that happens, we
		// abort.  The functions to run are a queue, and when we become unlocked we'll just resume running
		// the functions in the queue.

		var onUnlockLen = self._onUnlock.length;
		var i = 0;

		while (self._onUnlock.length > 0 && !self.isLocked()) {
			i += 1;
			var onUnlock = self._onUnlock.shift();
			self.debug(null, 'Running onUnlock function (%d of %d) - %s', i, onUnlockLen, onUnlock.info || '[NO INFO]');
			onUnlock.f();
		}
	};

	// #completelyUnlock {{{2

	Lock.prototype.completelyUnlock = function () {
		var self = this;

		while (self.isLocked()) {
			self.unlock();
		}
	};

	// #isLocked {{{2

	/**
	 * Check to see if the lock is engaged.
	 *
	 * @method
	 *
	 * @returns {boolean} True if the lock is engaged, false if it's disengaged.
	 */

	Lock.prototype.isLocked = function () {
		var self = this;

		return self._lockCount !== 0;
	};

	// #onUnlock {{{2

	/**
	 * Register a function to call when the lock is fully disengaged (i.e. all locks have been
	 * unlocked).
	 *
	 * @method
	 *
	 * @param {function} f Function to call when the lock is disengaged.
	 */

	Lock.prototype.onUnlock = function (f, info) {
		var self = this;

		// If we're not already locked, there's no point in queueing it up, just do it.  This can simplify
		// logic in callers (i.e. they don't have to do the check).

		if (!self.isLocked()) {
			return f();
		}

		self._onUnlock.push({
			f: f,
			info: info
		});

		self.debug(null, 'Saved onUnlock function (#%d) - %s', self._onUnlock.length, info || '[NO INFO]');
	};

	// #flushUnlockQueue

	Lock.prototype.flushUnlockQueue = function () {
		var self = this;
		var count = self._onUnlock.length;
		if (count > 0) {
			var info = underscore.map(underscore.pluck(self._onUnlock, 'info'), function (i) {
				return i || '[NO INFO]';
			});
			self.debug(null, 'Flushing ' + count + ' onUnlock functions: %O', info);
			self._onUnlock = [];
		}
	};

	// #clear {{{2

	Lock.prototype.clear = function () {
		var self = this;
		self.flushUnlockQueue();
		self.completelyUnlock();
	};

	/**
	 * @namespace util
	 */

	// Functional {{{1

	/**
	 * @namespace util.functional
	 */

	/**
	 * Generate unique symbols to use for element IDs. It doesn't much matter what the actual string
	 * produced is, as long as it's unique. That's why we use the 'gensymSeed' upvalue.
	 *
	 * @memberof util
	 * @inner
	 */

	var gensym = (function () {
		var gensymSeed = 0;
		return function () {
			gensymSeed += 1;
			return 'gensym-' + gensymSeed;
		};
	})();

	/**
	 * Y combinator.
	 *
	 * @memberof util.functional
	 * @inner
	 */

	function Y(f) {
		return (function (g) {
			return g(g);
		})(function (g) {
			return f(function () {
				return g(g).apply(this, arguments);
			});
		});
	}

	/**
	 * Identity function.
	 *
	 * @memberof util.functional
	 * @inner
	 */

	function I(x) {
		return x;
	}

	/**
	 * Does nothing.
	 *
	 * @memberof util.functional
	 * @inner
	 */

	function NOP() {
		return;
	}

	/**
	 * Universal comparison function.  Uses the builtin JavaScript type-safe equality and less-than
	 * operators to do the comparison.
	 *
	 * @memberof util.functional
	 * @inner
	 *
	 * @param {any} a First operand.
	 * @param {any} b Second operand.
	 *
	 * @returns {number} Zero if operands are equal, -1 if the first operand compares less than the
	 * second, and +1 if the first operand compares greater than the second.
	 */

	function universalCmp(a, b) {
		return a === b ? 0 : a < b ? -1 : 1;
	}

	// IE does not have Number.EPSILON so set it according to 2 ^ -52 which what it "should" be for
	// JavaScript floating point arithmetic.  (JavaScript uses doubles, which are 64 bits wide and have
	// a 53-bit significand in the IEEE 754 floating point specification.)
	//
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON

	if (Number.EPSILON == null) {
		Number.EPSILON = Math.pow(2, -52);
	}

	var getComparisonFn = (function () {
		var cmpFn = {};

		var floatSafe_equalp = function (n, m) {
			var epsilon = Number.EPSILON;

			/*
			var biggerEpsilon = 0.0000000001;

			if (Math.abs(n - m) > epsilon && Math.abs(n - m) < biggerEpsilon) {
				log.error('FLOATING POINT WEIRDNESS: %s <=> %s', n, m);
			}
			*/

			return Math.abs(n - m) < epsilon;
		};

		// Dates and times are stored as Moment instances, so we need to compare them accordingly.

		cmpFn.date = function (a, b) {
			if (a == null || b == null) {
				return a == b ? 0 : a == null ? -1 : 1;
			}

			if (!moment.isMoment(a) && !moment.isMoment(b)) {
				return a < b ? -1 : a > b ? 1 : 0;
			}
			else if (moment.isMoment(a) && moment.isMoment(b)) {
				return a.isBefore(b) ? -1 : a.isAfter(b) ? 1 : 0;
			}
			else {
				log.warn('Cannot compare Moment w/ non-Moment');
				return 0;
			}
		};
		cmpFn.time = cmpFn.date;
		cmpFn.datetime = cmpFn.date;

		// TODO: i18n
		cmpFn.month = function (a, b) {
			var trans = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,
				'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12};

			var a_month = trans[a];
			var b_month = trans[b];

			return a_month == null ? -1
				: b_month == null ? 1
				: a_month < b_month ? -1
				: a_month > b_month ? 1
				: 0;
		};

		// TODO: i18n
		cmpFn.day_of_week = function (a, b) {
			var trans = {'Mon': 0, 'Tue': 1, 'Wed': 2, 'Thu': 3, 'Fri': 4, 'Sat': 5, 'Sun': 6};

			var a_num = trans[a];
			var b_num = trans[b];

			return a_num == null ? -1
				: b_num == null ? 1
				: a_num < b_num ? -1
				: a_num > b_num ? 1
				: 0;
		};

		// TODO: i18n
		cmpFn.year_and_month = function (a, b) {
			var trans = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,
				'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12};

			var regexp = /^(\d{4}) (\w{3})$/;
			var m;

			var a_year, a_month, b_year, b_month;

			if ((m = regexp.exec(a)) != null) {
				a_year = toInt(m[1]);
				a_month = trans[m[2]];
			}
			if (m == null || a_month == null) {
				return -1;
			}

			if ((m = regexp.exec(b)) != null) {
				b_year = toInt(m[1]);
				b_month = trans[m[2]];
			}
			if (m == null || b_month == null) {
				return 1;
			}

			return a_year < b_year ? -1
				: a_year > b_year ? 1
				: a_month < b_month ? -1
				: a_month > b_month ? 1
				: 0;
		};

		// Strings, numbers, and currency are stored as JavaScript primitives, so using the builtin
		// operators to compare them is OK.

		cmpFn.string = function (a, b) {
			if (a == null || b == null) {
				return a == b ? 0 : a == null ? -1 : 1;
			}

			return a < b ? -1 : a > b ? 1 : 0;
		};

		cmpFn.number = function (a, b) {
			// We *should* only be comparing numbers with the same representation, but just to be safe we
			// allow comparisons among different representations.

			// First, make sure that we are handling comparisons with undefined/null consistently.  You'd
			// think this would work just fine based on the fallback to universalCmp below... or at least,
			// that's what I thought.  But that's wrong, and I'm not sure why.  Doing it here makes it very
			// obvious what we're trying to accomplish, and more importantly, actually makes it work right.

			if (a == null || b == null) {
				return a == b ? 0 : a == null ? -1 : 1;
			}

			// Second, handle the common case of comparisons between the same representation.

			if (typeof a === 'number' && typeof b === 'number') {
				{
					return floatSafe_equalp(a, b) ? 0 : a < b ? -1 : 1;
				}
			}
			else if (numeral.isNumeral(a) && numeral.isNumeral(b)) {
				{
					return floatSafe_equalp(a.value(), b.value()) ? 0 : a.value() < b.value() ? -1 : 1;
				}
			}
			else if (bignumber.isBigNumber(a) && bignumber.isBigNumber(b)) {
				// No need to perform a separate check for safer float comparison because BigNumber values
				// are inherently as precise as they need to be.
				return a.lt(b) ? -1 : a.gt(b) ? 1 : 0;
			}

			// Third, handle comparisons between different representations.

			if (numeral.isNumeral(a)) {
				if (bignumber.isBigNumber(b)) {
					return b.gt(a.value()) ? -1 : b.lt(a.value()) ? 1 : 0;
				}
				else if (typeof b === 'number') {
					return a.value() < b ? -1 : a.value() > b ? 1 : 0;
				}
				else {
					return universalCmp(a, b);
				}
			}
			else if (bignumber.isBigNumber(a)) {
				if (numeral.isNumeral(b)) {
					return a.lt(b.value()) ? -1 : a.gt(b.value()) ? 1 : 0;
				}
				else if (typeof b === 'number') {
					return a.lt(b) ? -1 : a.gt(b) ? 1 : 0;
				}
				else {
					return universalCmp(a, b);
				}
			}
			else if (typeof a === 'number') {
				if (bignumber.isBigNumber(b)) {
					return b.gt(a) ? -1 : b.lt(a) ? 1 : 0;
				}
				else if (numeral.isNumeral(b)) {
					return a < b.value() ? -1 : a > b.value() ? 1 : 0;
				}
				else {
					return universalCmp(a, b);
				}
			}
			else {
				return universalCmp(a, b);
			}
		};

		cmpFn.currency = cmpFn.number;

		cmpFn.array = function (a, b) {
			return arrayCompare(a, b);
		};

		return {
			byType: (function (type) {
				return cmpFn[type];
			}),
			byValue: (function (val) {
				if (typeof val === 'number' || numeral.isNumeral(val) || bignumber.isBigNumber(val)) {
					return cmpFn.number;
				}
				else if (moment.isMoment(val)) {
					return cmpFn.date;
				}
				else if (underscore.isArray(val)) {
					return cmpFn.array;
				}
				else {
					return cmpFn.string;
				}
			})
		};
	})();

	function getNatRep(x) {
		if (numeral.isNumeral(x)) {
			return x.value();
		}
		else if (moment.isMoment(x)) {
			return x.unix();
		}
		else {
			return x;
		}
	}

	/**
	 * Call a chain of functions, such that each function consumes as its arguments the result(s) of
	 * the previous function.
	 *
	 * @param {array} #0 The arguments to pass to the first function in the chain.  If it's not an
	 * array, that's OK.  An array of multiple elements gets turned into multiple arguments for the
	 * first function in the chain.
	 *
	 * @param {function} ... The functions to call in a chain.
	 *
	 * @returns {any} Whatever the result of calling the last function in the chain is.
	 */

	function chain() {
		var args = Array.prototype.slice.call(arguments);
		var fnArgs = args.shift();
		var fn;

		while (args.length > 0) {
			fn = args.shift();

			if (!(fnArgs instanceof Array)) {
				fnArgs = [fnArgs];
			}

			if (typeof fn !== 'function') {
				return fnArgs;
			}

			fnArgs = fn.apply(null, fnArgs);
		}

		return fnArgs;
	}

	/**
	 * Build a function that invokes a chain of function calls, where each function consumes as its
	 * arguments the result of the previous call (converting an array into separate arguments).  The
	 * arguments of the function thus produced are the arguments for the first function in the chain.
	 *
	 * @param {function} ... The functions to chain together.
	 *
	 * @returns {function} A function that takes any number of arguments; these are passed to the first
	 * function in the chain.  The result of the last function of the chain is the return value.
	 */

	function makeChain() {
		var fns = Array.prototype.slice.call(arguments);
		return function () {
			var args = Array.prototype.slice.call(arguments);
			return chain.apply(null, Array.prototype.concat.call([args], fns));
		};
	}

	function makeArray() {
		return Array.prototype.slice.call(arguments);
	}

	/**
	 * Call methods on an object, and build an object from the values which are passed to callbacks by
	 * those methods.  In other words, it's a way to get results from multiple callback-taking methods
	 * at the same time.
	 *
	 * @param {Function} cont
	 * @param {Array.<Object.<fn:string, prop:string>>} spec
	 * @param {Object} thisArg
	 * @param {?Object} acc
	 *
	 * @example
	 * trulyYours(cont, [{prop: a, fn: alpha}, {prop: b, fn: bravo}], target) =>
	 *
	 * var obj = {};
	 * return target.alpha(function (x) {
	 *   obj[a] = x;
	 *   return target.bravo(function (y) {
	 *     obj[b] = y;
	 *     return cont(obj);
	 *   });
	 * });
	 */
	function trulyYours(cont, spec, thisArg, acc) {
		acc = acc || {};
		return (spec.length === 0) ? cont(acc) : (function () {
			debug.info('TRULY YOURS', 'Calling #%s() to set property .%s', spec[0].fn, spec[0].prop);
			return (thisArg[spec[0].fn].bind(thisArg))(function (y) {
				acc[spec[0].prop] = (spec[0].conv || I)(y);
				return trulyYours(cont, spec.slice(1), thisArg, acc);
			});
		})();
	}

	function asyncChain(fns, args, done) {
		var self = this;
		if (!underscore.isArray(fns)) {
			throw new Error('Call Error: `fns` must be an array');
		}
		if (!underscore.isArray(args)) {
			throw new Error('Call Error: `args` must be an array');
		}

		fns = shallowCopy(fns);
		var g = function () {
			if (fns.length === 0) {
				return done();
			}
			fns.shift().apply(self, args.concat(g));
		};
		return g();
	}

	/**
	 * Partial application of a function.  Returns a new function that is a version of the argument
	 * with some parameters already bound.  Also called Schönfinkelization.
	 *
	 * @param {function} f The function to curry.
	 * @param {...any} args Arguments to bind in `f`.
	 *
	 * @returns {function} A function with free parameters corresponding to the parameters of `f`
	 * which weren't bound by `args`.
	 */

	function curry() {
		var curryArgs = Array.prototype.slice.call(arguments);
		var fn = curryArgs.shift();
		var placeholderIndex = curryArgs.indexOf('#');
		return function () {
			var args = Array.prototype.slice.call(arguments);
			var fnArgs = curryArgs.slice();
			var spliceArgs = placeholderIndex === -1 ? [fnArgs.length, 0] : [placeholderIndex, 1];
			Array.prototype.splice.apply(fnArgs, spliceArgs.concat(args));
			return fn.apply(this, fnArgs);
		};
	}

	function curryCtor() {
		var args = Array.prototype.slice.call(arguments)
			, result = curry.apply(null, args);
		result.prototype = args[0].prototype;
		return result;
	}

	function either() {
		var args = Array.prototype.slice.call(arguments);
		for (var i = 0; i < args.length; i += 1) {
			if (args[i] !== undefined) {
				return args[i];
			}
		}
		return undefined;
	}

	function car(a) {
		return a[0];
	}

	function cdr(a) {
		return a.slice(1);
	}

	// Conversion {{{1

	/**
	 * @namespace util.conversion
	 */

	function isInt(x) {
		return (typeof x === 'string') ? String(parseInt(x, 10)) === x : +x === Math.floor(+x);
	}

	function isFloat(x) {
		if (x === null || (typeof x === 'string' && x === '')) {
			// Because: +null => 0 ; +"" => 0
			return false;
		}

		return !isNaN(+x);
	}

	function toInt(x) {
		return (typeof x === 'string') ? parseInt(x, 10) : Math.floor(+x);
	}

	function toFloat(x) {
		return +x;
	}

	var stringValueType = (function () {
		var re_date = new RegExp(/^\d{4}-\d{2}-\d{2}$/);
		var re_time = new RegExp(/^\d{2}:\d{2}:\d{2}$/);
		var re_datetime = new RegExp(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/);
	  var re_number = new RegExp(/(^-?[1-9]{1}[0-9]{0,2}(,?\d{3})*(\.\d+)?(e[+-]?\d+)?$)|(^0(e[+-]?\d+)?$)|(^-?0?\.\d+(e[+-]?\d+)?$)/);
	  return function p(s) {
			var guess;
			if (re_date.test(s)) {
				return 'date';
			}
			else if (re_time.test(s)) {
				return 'time';
			}
			else if (re_datetime.test(s)) {
				return 'datetime';
			}
			else if (typeof s === 'string' && s.charAt(0) === '$') {
				guess = p(s.substring(1));
	      return guess === 'number' ? 'currency' : 'string';
	    }
	    else if (typeof s === 'string' && s.charAt(0) === '(' && s.charAt(s.length - 1) === ')') {
				guess = p(s.substring(1, s.length - 1));
				return ['number', 'currency'].indexOf(guess) >= 0 ? guess : 'string';
	    }
	    else {
	      return re_number.test(s) ? 'number' : 'string';
	    }
	  };
	})();

	var parseNumber = (function () {
	  var re_number = new RegExp(/(^-?[1-9]{1}[0-9]{0,2}(,?\d{3})*(\.\d+)?(e[+-]?\d+)?$)|(^0(e[+-]?\d+)?$)|(^-?0?\.\d+(e[+-]?\d+)?$)/);
		var re_comma = new RegExp(/,/g);
	  return function p(s, resultType) {
			if (typeof s !== 'string') {
				throw new Error('Call Error: `s` must be a string');
			}
			if (resultType != null && typeof resultType !== 'string') {
				throw new Error('Call Error: `resultType` must be null or a string');
			}

			if (resultType == null) {
				resultType = 'number';
			}

			if (['number', 'string'].indexOf(resultType) < 0) {
				throw new Error('Call Error: `resultType` must be one of: ["number", "string"]');
			}

	    if (s.charAt(0) === '$') {
	      return p(s.substring(1));
	    }
	    else if (s.charAt(0) === '(' && s.charAt(-1) === ')') {
	      return p(s.substring(1, s.length - 1)) * -1;
	    }
	    else {
	      return !re_number.test(s) ? null
	        : s.indexOf('.') >= 0 || s.indexOf('e') >= 0 ? (resultType === 'number' ? parseFloat : I)(s.replace(re_comma, ''))
	        : (resultType === 'number' ? parseInt : I)(s.replace(re_comma, ''));
	    }
	  };
	})();

	/**
	 * Convert from a string to an integer.
	 *
	 * @param {any} x Value to attempt to convert.
	 *
	 * @returns {number} The value as an integer number, or 0 if the value is not something which can
	 * be converted cleanly.
	 */

	function tryIntConvert(x) {
		return isInt(x) ? toInt(x) : 0;
	}

	/**
	 * Convert from a string to a float.
	 *
	 * @param {any} x Value to attempt to convert.
	 *
	 * @returns {number} The value as a floating point number, or 0.0 if the value is not something
	 * which can be converted cleanly.
	 */

	function tryFloatConvert(x) {
		return isFloat(x) ? toFloat(x) : 0.0;
	}

	// Data Structures {{{1

	/**
	 * @namespace util.data_structures
	 */

	/**
	 * @memberof util.data_structures
	 * @inner
	 */

	function arrayCompare(a, b) {
		if (!underscore.isArray(a) || !underscore.isArray(b)) {
			throw new Error('Call Error: arguments must be arrays');
		}

		if (a.length !== b.length) {
			throw new Error('Call Error: arguments must have the same length');
		}

		for (var i = 0; i < a.length; i += 1) {
			if (a[i] < b[i]) {
				return -1;
			}
			else if (a[i] > b[i]) {
				return 1;
			}
		}

		return 0;
	}

	/**
	 * @memberof util.data_structures
	 * @inner
	 */

	function arrayEqual(a, b) {
		if (!underscore.isArray(a) || !underscore.isArray(b)) {
			throw new Error('Call Error: arguments must be arrays');
		}

		if (a.length !== b.length) {
			return false;
		}

		return arrayCompare(a, b) === 0;
	}

	function moveArrayElement(a, fromIdx, toIdx) {
		var elt = a[fromIdx];
		a.splice(fromIdx, 1);
		a.splice(toIdx, 0, elt);
	}

	/**
	 * Calls a function on each element in a list until a certain value is returned.
	 *
	 * @memberof util.data_structures
	 * @inner
	 *
	 * @param {array} l List to iterate over.
	 * @param {function} f Function to invoke on each element.  Called like: f(item, index).
	 * @param {any} r Return value that causes the iteration to abort.
	 *
	 * @returns {void} Nothing.
	 */

	function eachUntil(l, f, r) {
		var i;
		for (i = 0; i < l.length; i += 1) {
			if (f(l[i], i) === r) {
				return;
			}
		}
	}

	/**
	 * Calls a function on each key/value pair in an object until the function returns a certain value.
	 * This is mainly useful as a sort of short-circuited version of `_.each()` or a version of
	 * `_.every()` that works on objects.  This contrived example only goes through as many keys as
	 * necessary to determine that one of them is "TERMINATE."
	 *
	 * ```
	 * if (!eachUntilObject(o, (v, k) => { k.toUpperCase() }, "TERMINATE")) {
	 *   console.log('Object contains TERMINATE key!');
	 * }
	 * ```
	 *
	 * @memberof util.data_structures
	 * @inner
	 *
	 * @param {object} o
	 * The object to iterate over.
	 *
	 * @param {function} f
	 * Function to call like this: `f(value, key, extra)`
	 *
	 * @param {any} r
	 * If `f` returns `r` then this function returns false.
	 *
	 * @param {any} [extra]
	 * A "userdata" type of argument passed to `f`.
	 *
	 * @return {boolean}
	 * False if `f` returned `r` for some key/value pair in the object, and true otherwise.
	 */

	function eachUntilObj(o, f, r, extra) {
		for (var k in o) {
			if (o.hasOwnProperty(k) && f(o[k], k, extra) === r) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Call an asynchronous function for each element in a list.
	 *
	 * @param {object[]} args
	 * The list to iterate over.
	 *
	 * @param {function} fun
	 * An asynchronous function.  The arguments passed to it are: (1) the next element of `args`, and
	 * (2) a callback function to continue iterating.
	 *
	 * @param {function} done
	 * A function called when we're done.
	 */

	function asyncEach(args, fun, done) {
		if (!underscore.isArray(args)) {
			throw new Error('Call Error: `args` must be an array');
		}
		if (typeof fun !== 'function') {
			throw new Error('Call Error: `fun` must be a function');
		}
		if (typeof done !== 'function') {
			throw new Error('Call Error: `done` must be a function');
		}

		args = shallowCopy(args);
		var i = 0;
		function g() {
			if (args.length === 0) {
				return done();
			}
			return fun(args.shift(), i++, g);
		}
		return g();
	}

	/**
	 * Map a function over an array, stopping after a preset number of elements.
	 *
	 * @memberof util.data_structures
	 * @inner
	 *
	 * @param {any[]} a
	 * An array of items.
	 *
	 * @param {function} f
	 * The function to map.
	 *
	 * @param {number} l
	 * Maximum number of elements to process.
	 *
	 * @return {any[]}
	 * An array of size `min(a.length, l)` containing the mapped results.
	 */

	function mapLimit(a, f, l) {
		var result = [];
		for (var i = 0; i < Math.min(a.length, l); i += 1) {
			result.push(f(a[i], i));
		}
		return result;
	}

	/**
	 * Create a shallow copy of an object.
	 *
	 * @memberof util.data_structures
	 * @inner
	 *
	 * @param {any} x
	 * The thing to copy.
	 *
	 * @return {any}
	 * A shallow copy of the argument.
	 */

	var shallowCopy = function (x) {
		if (x == null) {
			return {};
		}

		var result;

		if (jQuery.isArray(x)) {
			result = [];

			for (var i = 0; i < x.length; i += 1) {
				result[i] = x[i];
			}

			return result;
		}
		else if (jQuery.isPlainObject(x)) {
			result = {};

			for (var k in x) {
				if (x.hasOwnProperty(k)) {
					result[k] = x[k];
				}
			}

			return result;
		}
		else {
			return x;
		}
	};

	/**
	 * Create a deep copy of an object.
	 *
	 * @memberof util.data_structures
	 * @inner
	 *
	 * @param {any} x0
	 * The thing to copy.
	 *
	 * @return {any}
	 * A clean copy of the argument.
	 */

	var deepCopy = function (x0) {
		var depthLimit = 99;
		var path = [];

		if (x0 == null) {
			return {};
		}

		function recursive(x, depth) {
			if (depth > depthLimit) {
				log.error('deepCopy: path = %O', path);
				throw new Error('deepCopy: Maximum recursion depth exceeded');
			}

			var result;

			if (jQuery.isArray(x)) {
				result = [];

				for (var i = 0; i < x.length; i += 1) {
					path.push(i);
					result[i] = recursive(x[i], depth + 1);
					path.pop();
				}

				return result;
			}
			else if (jQuery.isPlainObject(x)) {
				result = {};

				for (var k in x) {
					if (x.hasOwnProperty(k)) {
						path.push(k);
						result[k] = recursive(x[k], depth + 1);
						path.pop();
					}
				}

				return result;
			}
			else {
				return x;
			}
		}

		return recursive(x0, 0);
	};

	var arrayCopy = deepCopy;

	/**
	 * Returns true if the argument is null or undefined.
	 *
	 * @memberof util.data_structures
	 * @inner
	 * @deprecated
	 */

	function isNothing(x) {
		return x === undefined || x === null;
	}

	/**
	 * Returns true if the object doesn't have any properties.
	 *
	 * @memberof util.data_structures
	 * @inner
	 * @deprecated
	 */

	function isEmpty(o) {
		var numProps = 0;

		underscore.each(o, function () {
			numProps += 1;
		});

		return numProps === 0;
	}

	/**
	 * @memberof util.data_structures
	 * @inner
	 */

	function deepDefaults() {
		var args = Array.prototype.slice.call(arguments)
			, base;

		if (args[0] === true) {
			args.shift();
			base = args.shift();
		}
		else {
			base = deepCopy(args.shift());
		}

		var f = function (dst, src) {
			underscore.each(src, function (v, k) {
				if (dst[k] === undefined) {
					dst[k] = (typeof v === 'object' && v != null) ? deepCopy(v) : v;
				}
				else if (underscore.isObject(dst[k]) && underscore.isObject(v)) {
					f(dst[k], v);
				}
			});
		};

		underscore.each(args, function (arg) {
			f(base, arg);
		});

		return base;
	}

	/**
	 * Safely get the value of a property path in an object, even if some properties in the path don't
	 * exist.  Returns the value of the last property in the path, or undefined if some elements in
	 * the path don't exist in the object.
	 *
	 * @memberof util.data_structures
	 * @inner
	 *
	 * @param {object} obj The object to search for the property path.
	 * @param {...(string|number)} prop Property path to traverse.
	 *
	 * @returns {any} The value of the property found at the end of the provided path, or undefined if
	 * the path cannot be traversed at any step of the way.
	 *
	 * @example
	 * var obj = {a: {b: 2}};
	 *
	 * getProp(obj, 'a', 'b');  // 2
	 * getProp(obj, 'a');		  // {b: 2}
	 * getProp(obj, 'a', 'x');  // undefined
	 * getProp(obj, 'x');		  // undefined
	 */

	function getProp() {
		var args = Array.prototype.slice.call(arguments)
			, o = args.shift()
			, i;

		args = underscore.flatten(args);

		for (i = 0; o !== undefined && o !== null && i < args.length; i += 1) {
			o = o[args[i]];
		}

		return i < args.length ? undefined : o;
	}

	/**
	 * Safely get the value of a property path in an object, even if some properties in the path don't
	 * exist.  Returns the value of the last property in the path, or a default value if some elements
	 * in the path don't exist in the object.
	 *
	 * @memberof util.data_structures
	 * @inner
	 *
	 * @param {any} value The default value to return if the property doesn't exist.
	 * @param {object} obj The object to search for the property within.
	 * @param {...(string|number)} prop Property path to traverse.
	 *
	 * @example
	 * var obj = {a: {b: 2}};
	 *
	 * getPropDef(1, obj, 'a', 'b');		// 2
	 * getPropDef(1, obj, 'a', 'b', 'c'); // 1
	 * getPropDef(1, obj, 'a', 'x');		// 1
	 * getPropDef(1, obj, 'x');			// 1
	 */

	function getPropDef() {
		var args = Array.prototype.slice.call(arguments);
		var d = args.shift();
		var p = getProp.apply(undefined, args);
		return p !== undefined ? p : d;
	}

	/**
	 * Set a value for a property path in an object.
	 *
	 * @memberof util.data_structures
	 * @inner
	 *
	 * @param {any} value The value to set for the property.
	 * @param {object} obj The object to set the property within.
	 * @param {...(string|number)} prop Property path to traverse before setting the value.
	 *
	 * @example
	 * var obj = {};
	 * setProp(42, obj, 'a', 'b', 'c');
	 * obj.a.b.c === 42;
	 */

	function setProp() {
		var args = Array.prototype.slice.call(arguments);
		var x = args.shift();
		var o = args.shift();

		args = underscore.flatten(args);

		for (var i = 0; i < args.length - 1; i += 1) {
			if (o[args[i]] == null) {
				o[args[i]] = {};
			}

			o = o[args[i]];
		}

		o[args[args.length - 1]] = x;
	}

	/**
	 * @memberof util.data_structures
	 * @inner
	 */

	function setPropDef() {
		var args = Array.prototype.slice.call(arguments);
		var x = args.shift();
		var o = args.shift();

		args = underscore.flatten(args);

		for (var i = 0; i < args.length - 1; i += 1) {
			if (o[args[i]] === undefined) {
				o[args[i]] = {};
			}

			o = o[args[i]];
		}

		if (o[args[args.length - 1]] === undefined) {
			o[args[args.length - 1]] = x;
		}
	}

	/**
	 * Copy properties from one object to another.
	 *
	 * @param {object} src
	 * Where to copy properties from.
	 *
	 * @param {object} dest
	 * Where to copy properties to.
	 *
	 * @param {string[]} props
	 * Array of properties to copy.
	 *
	 * @param {object} opts
	 * Additional options.
	 *
	 * @param {boolean} [opts.followPrototype=false]
	 * If true, follow the prototype chain; the default behavior is that `src` must have its own
	 * property with the specified name for it to be copied.
	 */

	function copyProps(src, dest, props, opts) {
		opts = opts || {};

		underscore.each(props, function (p) {
			if (src.hasOwnProperty(p) || (opts.followPrototype && p in src)) {
				dest[p] = src[p];
			}
		});
	}

	/**
	 * Throw an exception if a property is missing.
	 *
	 * @param {function} exn Constructor used to instantiate an exception if an error arises.
	 * @param {object} obj Target object to search within.
	 * @param {...(string|number)} prop Property path.
	 */

	function needProp() {
		var args = Array.prototype.slice.call(arguments)
			, exn = args.shift()
			, prop = getProp.apply(this, args);

		if (prop === undefined) {
			throw new exn('Missing property: [' + args.slice(1).join('.') + ']');
		}

		return prop;
	}

	/**
	 * Throw an exception if a property is missing or not a member of a set.
	 *
	 * @param {object} obj Target object to search within.
	 * @param {...(string|number)} prop Property path.
	 * @param {array} arr Set of values which the property must be in.
	 */

	function needPropIn() {
		var args = Array.prototype.slice.call(arguments)
			, set = args.pop()
			, prop = needProp.apply(this, args);

		if (set.indexOf(prop) === -1) {
			throw new Error('Property [' + args.slice(1).join('.') + '] must be one of: {"' + set.join('", "') + '"}');
		}

		return prop;
	}

	/**
	 * Throw an exception if a property is missing or not an array.
	 *
	 * @param {function} exn Constructor used to instantiate an exception if an error arises.
	 * @param {object} obj Target object to search within.
	 * @param {...(string|number)} prop Property path.
	 */

	function needPropArr() {
		var args = Array.prototype.slice.call(arguments)
			, exn = args[0]
			, prop = needProp.apply(this, args);

		if (!underscore.isArray(prop)) {
			throw new exn('Property [' + args.slice(1).join('.') + '] must be an array');
		}

		return prop;
	}

	/**
	 * Throw an exception if a property is missing or not an object.
	 *
	 * @param {function} exn Constructor used to instantiate an exception if an error arises.
	 * @param {object} obj Target object to search within.
	 * @param {...(string|number)} prop Property path.
	 */

	function needPropObj() {
		var args = Array.prototype.slice.call(arguments)
			, exn = args[0]
			, prop = needProp.apply(this, args);

		if (!underscore.isObject(prop)) {
			throw new exn('Property [' + args.slice(1).join('.') + '] must be an object');
		}

		return prop;
	}

	/**
	 * Throw an exception if a property is missing or not an instance of a class.
	 *
	 * @param {function} exn Constructor used to instantiate an exception if an error arises.
	 * @param {object} obj Target object to search within.
	 * @param {...string|number} prop Property path.
	 * @param {function} cls Class which the property must be an instance of.
	 */

	function needPropInst() {
		var args = Array.prototype.slice.call(arguments)
			, exn = args[0]
			, cls = args.pop()
			, prop = needProp.apply(this, args);

		if (!(prop instanceof cls)) {
			throw new exn('Property [' + args.slice(1).join('.') + '] must be an instance of ' + cls.name);
		}

		return prop;
	}

	function needArgInst(val, varName, cls) {
		needArg(val, varName);
		var msg = arguments.callee.name + '(): Argument "' + varName + '" must be an instance of ' + cls.name;

		if (!(val instanceof cls)) {
			console.error(msg + ', received: %O', val);
			throw new Error(msg);
		}

		return val;
	}

	function needArg(val, varName) {
		var msg = arguments.callee.name + '(): Missing required argument "' + varName + '"';

		if (isNothing(val)) {
			throw new Error(msg);
		}

		return val;
	}

	function iota(a, b, step) {
		var r = []
			, start
			, end;

		if (b == null) {
			start = 0;
			end = a;
		}
		else {
			start = a;
			end = b;
		}

		if (step == null) {
			step = 1;
		}

		for (var i = start; i <= end; i += step) {
			r.push(i);
		}

		return r;
	}

	/**
	 * Prune a subtree in an object.  This means to prune the leaf, and then if there are no other
	 * leaves on that branch, prune the branch, and so on all the way up.
	 *
	 * @example pruneTree(OBJECT, PATH...)
	 */

	function pruneTree() {
		var args = Array.prototype.slice.call(arguments);
		var o = args.shift();
		var deleteFrom = [];
		var i;

		for (i = 0; i < args.length; i += 1) {
			if (o[args[i]] !== undefined) {
				deleteFrom.push(o);
				if (underscore.isObject(o[args[i]])) {
					o = o[args[i]];
					continue;
				}
			}

			break;
		}

		for (i = deleteFrom.length - 1; i >= 0; i -= 1) {
			delete deleteFrom[i][args[i]];
			if (!isEmpty(deleteFrom[i])) {
				break;
			}
		}
	}

	function interleaveWith(a, x) {
		var result = [];

		if (a.length > 0) {
			result.push(a[0]);
		}

		for (var i = 1; i < a.length; i += 1) {
			result.push(x);
			result.push(a[i]);
		}

		return result;
	}

	/**
	 * Stable sort algorithm that allows for responsive browser UI.
	 */

	function mergeSort(data, cmp, cont) {
		cmp = cmp || universalCmp;
		return Y(function (recur) {
			return function (data, cont) {
				function merge(left, right, cont) {
					var result = [];
					while (left.length !== 0 && right.length !== 0) {
						var cmpResult = cmp(left[0], right[0]);
						if (!underscore.isNumber(cmpResult)) {
							throw 'comparison result returned non-number';
						}
						result.push(cmpResult <= 0 ? left.shift() : right.shift());
					}
					window.setTimeout(function () {
						cont(result.concat(left.length > 0 ? left : right));
					}, 0);
				}
				if (data.length <= 1) {
					window.setTimeout(function () {
						cont(data);
					}, 0);
				}
				else {
					var pivot = Math.floor(data.length / 2);
					window.setTimeout(function () {
						recur(data.slice(0, pivot), function (left) {
							window.setTimeout(function () {
								recur(data.slice(pivot), function (right) {
									window.setTimeout(function () {
										merge(left, right, cont);
									}, 0);
								});
							}, 0);
						});
					}, 0);
				}
			};
		})(data, cont);
	}

	function mergeSort2(data, cmp) {
		cmp = cmp || function (a, b) { return a < b };

		var merge = function (left, right) {
			var result = []
				, leftLen = left.length
				, leftIdx = 0
				, rightLen = right.length
				, rightIdx = 0;
			while (leftIdx < leftLen && rightIdx < rightLen) {
				var cmpResult = cmp(left[leftIdx], right[rightIdx]);
				result.push(cmpResult ? left[leftIdx++] : right[rightIdx++]);
			}
			return result.concat(leftIdx < leftLen ? left.slice(leftIdx) : right.slice(rightIdx));
		};

		if (data.length <= 1) {
			return data;
		}
		else {
			var pivot = Math.floor(data.length / 2)
				, left = mergeSort2(data.slice(0, pivot), cmp)
				, right = mergeSort2(data.slice(pivot), cmp);
			return merge(left, right);
		}
	}

	function mergeSort3(data, cmp, cont, update) {
		cmp = cmp || function (a, b) { return a < b };
		var size = data.length;
		var step = 0;
		var stepsBeforeUpdate = Math.min(data.length / 50, 500);

		function merge(left, right) {
			var result = []
				, leftLen = left.length
				, leftIdx = 0
				, rightLen = right.length
				, rightIdx = 0;
			while (leftIdx < leftLen && rightIdx < rightLen) {
				var cmpResult = cmp(left[leftIdx], right[rightIdx]);
				result.push(cmpResult ? left[leftIdx++] : right[rightIdx++]);
			}
			return result.concat(leftIdx < leftLen ? left.slice(leftIdx) : right.slice(rightIdx));
		}

		function sort(data, cont) {
			if (data.length <= 1) {
				return cont(data);
			}
			else {
				var pivot = Math.floor(data.length / 2);
				return sort(data.slice(0, pivot), function (left) {
					return sort(data.slice(pivot), function (right) {
						var fn = function () {
							return cont(merge(left, right));
						};
						step += 1;
						if (step % stepsBeforeUpdate === 0) {
							if (typeof update === 'function') {
								update(step, size);
							}
							return window.setTimeout(fn);
						}
						else {
							return fn();
						}
					});
				});
			}
		}

		return sort(data, cont);
	}

	/**
	 * Non-recursive merge sort, mostly taken from: https://stackoverflow.com/questions/1557894/
	 * Breaks for update every "merge" which happens log_2(n) times.
	 */

	var mergeSort4 = function (data, cmp, cont, update) {
		cmp = cmp || function (x, y) { return x < y };
		var a = data;
		var num = data.length;
		var b = new Array(num);

		var rght, rend;
		var i, j, m;

		var sortWindow = function (k) {
			for (var left=0; left+k < num; left += k*2 ) {
				rght = left + k;
				rend = rght + k;
				if (rend > num) rend = num;
				m = left; i = left; j = rght;
				while (i < rght && j < rend) {
					if (cmp(a[i], a[j])) {
						b[m] = a[i]; i++;
					} else {
						b[m] = a[j]; j++;
					}
					m++;
				}
				while (i < rght) {
					b[m]=a[i];
					i++; m++;
				}
				while (j < rend) {
					b[m]=a[j];
					j++; m++;
				}
				for (m=left; m < rend; m++) {
					a[m] = b[m];
				}
			}

			if (k < num) {
				if (typeof update === 'function') {
					update(k, num);
				}
				return window.setTimeout(function () {
					sortWindow(k * 2);
				});
			}
			else {
				return cont(a);
			}
		};

		sortWindow(1);
	};

	function pigeonHoleSort(data, values, cont) {
		var o = {}
			, r = []
			, i
			, j
		;

		for (i = 0; i < values.length; i += 1) {
			o[values[i]] = [];
		}

		for (i = 0; i < data.length; i += 1) {
			if (o[data[i].sortSource] != null) {
				o[data[i].sortSource].push(data[i]);
			}
		}

		for (i = 0; i < values.length; i += 1) {
			for (j = 0; j < o[values[i]].length; j += 1) {
				r.push(o[values[i]][j]);
			}
		}

		return cont(r);
	}

	function objGetPath(obj, fieldPath) {
		var i, len = fieldPath.length;
		for (i = 0; i < len && obj !== undefined; i += 1) {
			obj = obj[fieldPath[i]];
		}
		return obj;
	}

	function cmpObjField(fieldPath, cmp) {
		cmp = cmp || universalCmp;
		return function (a, b) {
			a = objGetPath(a, fieldPath);
			b = objGetPath(b, fieldPath);
			if (!underscore.isString(a) && !underscore.isNumber(a) && !underscore.isDate(a)) {
				throw 'object "a" doesn\'t contain field path: ' + fieldPath.toString();
			}
			if (!underscore.isString(b) && !underscore.isNumber(b) && !underscore.isDate(b)) {
				throw 'object "b" doesn\'t contain field path: ' + fieldPath.toString();
			}
			return cmp(a, b);
		};
	}

	/**
	 * Constructs an object from a simplified array representation.
	 *
	 * ```
	 * objFromArray(['foo', 'bar', 'baz'])             => {foo: 0, bar: 1}
	 * objFromArray(['foo', 'bar', 'baz'], ['a'])      => {foo: 'a', bar: 'a', baz: 'a'}
	 * objFromArray(['foo', 'bar', 'baz'], ['a', 'b']) => {foo: 'a', bar: 'b', baz: 'a'}
	 * ```
	 *
	 * @param {any[]} a
	 * Items that will become the keys in the object.
	 *
	 * @param {any[]} [v]
	 * Items that will become the values in the object.
	 */

	function objFromArray(a, v) {
		return underscore.reduce(a, function (o, x, i) {
			o[x] = v ? v[i % v.length] : x;
			return o;
		}, {});
	}

	/**
	 * Treating an object like a tree, descends through object values until it hits a non-object, then
	 * calls the given function.
	 *
	 * @param object o The root of the tree.
	 *
	 * @param function f Callback to invoke, applied to the leaf and the path of keys taken to arrive
	 * at that leaf.
	 *
	 * @param array acc Accumulator of the key path.
	 */

	function walkObj(o, f, opts) {
		opts = deepDefaults(opts, {
			replace: false,
			callOnNodes: false
		});

		var walk = function (o, acc) {
			underscore.each(o, function (v, k) {
				var x;
				var newAcc = acc.slice();
				newAcc.push(k);

				if (opts.callOnNodes || !underscore.isObject(v) || underscore.isArray(v)) {
					x = f(v, newAcc);
				}

				if (opts.replace) {
					o[k] = v = x;
				}

				if (underscore.isObject(v)) {
					walk(v, newAcc);
				}
			});

			return o;
		};

		return walk(o, []);
	}

	// Object Orientation {{{1

	// makeSubclass {{{2

	/**
	 * Create a function representing a subclass.
	 *
	 * ```
	 * var Animal = makeSubclass('Animal', Object, function (name) {
	 *   this.name = name;
	 * }, {
	 *   species: 'unknown species'
	 * });
	 *
	 * Animal.prototype.printInfo = function () {
	 *   console.log(this.name + ' is a ' + this.species + '.');
	 * };
	 *
	 * var HouseFinch = makeSubclass('HouseFinch', Animal, null, {
	 *   species: 'Haemorhous mexicanus'
	 * });
	 *
	 * HouseFinch.prototype.printInfo = function () {
	 *   self.super.printInfo();
	 *   console.log('He says: Tweet tweet!');
	 * };
	 *
	 * var harold = new HouseFinch('Harold');
	 * harold.printInfo();
	 *
	 * > Harold is a Haemorhous mexicanus.
	 * > He says: Tweet tweet!
	 * ```
	 *
	 * Within the source code, look to {@linkcode Aggregate} or {@linkcode GridTable} for some prime
	 * examples.
	 *
	 * @param {function} parent
	 * The parent class; use "Object" to create base classes.
	 *
	 * @param {function} [ctor]
	 * Constructor for the subclass.  If not provided, a default constructor is used which simply calls
	 * the superclass' constructor with all arguments.
	 *
	 * @param {object} [ptype]
	 * Properties added to the resulting class' prototype.
	 *
	 * @return {function}
	 * A constructor used to create new instances of the subclass.  The instance will get a `super`
	 * property which can be used to invoke the superclass' methods on itself.
	 */

	var makeSubclass = function (name, parent, ctor, ptype) {
		// Default constructor just calls the super constructor.

		if (typeof name !== 'string') {
			throw new Error('Call Error: `name` must be a string');
		}
		if (typeof parent !== 'function') {
			throw new Error('Call Error: `parent` must be a function');
		}
		if (ctor != null && typeof ctor !== 'function') {
			throw new Error('Call Error: `ctor` must be null or a function');
		}
		if (ptype != null && typeof ptype !== 'object') {
			throw new Error('Call Error: `ptype` must be null or an object');
		}

		if (ctor == null && parent !== Object) {
			ctor = function () {
				this.super.ctor.apply(this, arguments);
			};
		}

		var subclass = function () {
			if (parent !== Object) {
				this.super = makeSuper(this, parent);
			}

			if (ctor != null) {
				ctor.apply(this, arguments);
			}
		};

		Object.defineProperty(subclass, 'name', {value: name});
		subclass.prototype = Object.create(parent.prototype);
		subclass.prototype.constructor = subclass;

		//subclass.prototype.__ctor = subclass;
		//subclass.prototype.__ctorname = name;

		underscore.each(ptype, function (v, k) {
			subclass.prototype[k] = v;
		});

		return subclass;
	};

	// makeSuper {{{2

	/**
	 * Creates an object to act as a proxy to superclass methods.  Probably best to not use this
	 * directly, and instead let {@linkcode makeSubclass makeSubclass()} do the work for you.
	 *
	 * @param {object} me
	 * An instance of the subclass.
	 *
	 * @param {function} parent
	 * The superclass.
	 *
	 * @return {object}
	 * An object containing proxies to superclass methods (bound to `me`).
	 */

	var makeSuper = function (me, parent) {
		var sup = underscore.mapObject(parent.prototype, function (v, k) {
			if (typeof v === 'function') {
				return underscore.bind(v, me);
			}
		});

		sup.ctor = underscore.bind(parent, me);

		return sup;
	};

	// mixinEventHandling {{{2

	var mixinEventHandling = (function () {
		var HANDLER_ID = 0;

		return function (obj, events) {
			obj.events = objFromArray(events);

			var getName = function () {
				return obj.toString === Object.toString
					? obj.prototype.constructor.name
					: obj.toString();
			};

			var getTag = function (self) {
				if (typeof self.getDebugTag === 'function') {
					return self.getDebugTag();
				}
				else if (typeof self.toString === 'function' && self.toString !== Object.toString) {
					return self.toString();
				}
				else {
					return obj.prototype.constructor.name.toUpperCase();
				}
			};

			// #_initEventHandlers {{{3

			obj.prototype._initEventHandlers = function () {
				var self = this;

				if (self.eventHandlers == null) {
					self.eventHandlers = {};

					underscore.each(obj.events, function (evt) {
						self.eventHandlers[evt] = [];
					});
				}

				if (self.eventHandlersById == null) {
					self.eventHandlersById = [];
				}
			};

			// #echo {{{3

			/**
			 * Echo events from a source, reproducing them ourselves.
			 *
			 * @param {object} src
			 * The source, it must have had `mixinEventHandling()` called on it as well.
			 *
			 * @param {string[]} evt
			 * List of events to echo.
			 *
			 * @param {object} opts
			 * Additional options to pass to the `on()` method.
			 */

			obj.prototype.echo = function (src, evt, opts) {
				var self = this;

				opts = opts || {};

				self._initEventHandlers();

				if (!underscore.isArray(evt)) {
					evt = [evt];
				}
				underscore.each(evt, function (e, i) {
					if (typeof e !== 'string') {
						throw new Error('Call Error: `evt[' + i + ']` must be a string');
					}
					if (obj.events[e] === undefined) {
						throw new Error('Unable to register handler on ' + getName() + ' for "' + e + '" event: no such event available');
					}
					src.on(e, function () {
						self.fire(e);
					}, opts);
				});
			};

			// #on {{{3

			obj.prototype.on = function (evt, cb, opts) {
				var self = this;

				opts = opts || {};

				self._initEventHandlers();

				if (!underscore.isArray(evt)) {
					evt = [evt];
				}

				underscore.each(evt, function (e) {
					if (obj.events[e] === undefined) {
						throw new Error('Unable to register handler on ' + getName() + ' for "' + e + '" event: no such event available');
					}

					var handler = {
						id: HANDLER_ID++,
						who: opts.who,
						info: opts.info,
						cb: cb,
						limit: opts.limit
					};

					self.eventHandlers[e].push(handler);
					self.eventHandlersById[handler.id] = handler;

					var msg = 'Adding "' + evt + '" event handler on ' + getName();
					if (opts.who != null) {
						msg += ' from ' + opts.who;
					}
					debug.info(getTag(self) + ' // ON', msg);
				});

				return self;
			};

			// #off {{{3

			obj.prototype.off = function (evt, who, opts) {
				var self = this;

				opts = opts || {};

				self._initEventHandlers();

				if (evt === '*') {
					underscore.each(obj.events, function (e) {
						self.off(e, who, opts);
					});
					return;
				}

				if (obj.events[evt] === undefined) {
					throw new Error('Unable to register handler on ' + getName() + ' for "' + evt + '" event: no such event available');
				}

				var newHandlers = [];

				underscore.each(self.eventHandlers[evt], function (handler, i) {
					if (handler == null) {
						// This handler has been removed, e.g. due to reaching the invocation limit.
						return;
					}

					if (who == null || handler.who === who) {
						// Remove from the ID lookup.  This is used to allow event handlers to be removed while
						// their event is being fired.

						self.eventHandlersById[handler.id] = null;
					}
					else {
						newHandlers.push(handler);
					}
				});

				if (!opts.silent) {
					debug.info(getTag(self) + ' // OFF', 'Removed ' + (self.eventHandlers[evt].length - newHandlers.length) + ' handlers from ' + who + ' on "' + evt + '" event');
				}

				self.eventHandlers[evt] = newHandlers;
			};

			// #fire {{{3

			/**
			* @param {string} event
			*
			* @param {object} opts
			*
			* @param {boolean} opts.silent
			* If true, don't print a debugging log entry for sending the event.  This is useful for some
			* really spammy events which would otherwise slow down the console.
			*
			* @param {object|Array.<object>|function} opts.notTo
			* Indicates entities which should not receive the event.  Can either be the entity itself, a list
			* of entities, or a function which returns true when passed an entity which shouldn't receive the
			* event.  An entity here is registered in the `who` property of the handler.
			*/

			obj.prototype.fire = function () {
				var self = this
					, args = Array.prototype.slice.call(arguments)
					, evt = args.shift()
					, opts = args.shift() || {};

				self._initEventHandlers();

				if (obj.events[evt] === undefined) {
					throw new Error('Illegal event: ' + evt);
				}

				var handlers = [];

				underscore.each(self.eventHandlers[evt], function (handler, i) {
					var handler = self.eventHandlers[evt][i];

					if (handler == null) {
						// This handler has been removed, e.g. due to reaching the invocation limit.
						return;
					}

					// Check to see if this handler is for someone we shouldn't be sending to.
					//
					//   - `notTo` is an array (check memberof)
					//   - `notTo` is a function returning true
					//   - `notTo` is an object (direct comparison)

					if (handler.who && opts.notTo &&
							((underscore.isArray(opts.notTo) && opts.notTo.indexOf(handler.who) >= 0)
								|| (typeof opts.notTo === 'function' && opts.notTo(handler.who))
								|| (typeof opts.notTo === 'object' && opts.notTo === handler.who))) {
						return;
					}

					handlers.push({
						handler: handler,
						index: i
					});
				});

				// Print a debugging message unless invoked with the silent option (used internally to prevent
				// spamming millions of messages, which slows down the console).

				if (!opts.silent) {
					debug.info(getTag(self) + ' // FIRE', 'Triggering %d handlers for "%s" event on %s: %O', handlers.length, evt, getName(), args);
				}

				// Execute all matching handlers in the order they were registered.  A break is added between
				// each handler's invocation using setTimeout().  This allows user interface changes made a
				// handler to be picked up by the browser.  An early handler is allowed to remove a later one.

				asyncEach(handlers, function (h, i, next) {
					if (self.eventHandlersById[h.handler.id] == null) {
						// This handler has been removed since we started firing for this event.  This happens one
						// an earlier event handler removes a later one.
						return;
					}

					if (h.handler.info != null) {
						debug.info(getTag(self) + ' // FIRE', 'Executing "%s" handler (%d of %d) on %s: %s', evt, i+1, handlers.length, getName(), h.handler.info);
					}
					else {
						debug.info(getTag(self) + ' // FIRE', 'Executing "%s" handler (%d of %d) on %s', evt, i+1, handlers.length, getName());
					}
					h.handler.cb.apply(null, args);

					// Remove the handler if we've hit the limit of how many times we're supposed to invoke it.
					// Actually we just set the handler to null and remove it below.

					if (h.handler.limit) {
						h.handler.limit -= 1;
						if (h.handler.limit <= 0) {
							debug.info(getTag(self) + ' // FIRE', 'Removing "%s" handler #%d from %s after reaching invocation limit', evt, i+1, getName());
							self.eventHandlers[evt][h.index] = null;
						}
					}

					return opts.async ? window.setTimeout(next) : next();
				}, function () {
					if (!opts.silent) {
						debug.info(getTag(self) + ' // FIRE', 'Done triggering handlers for "%s" event on %s', evt, getName());
					}

					// Clean up handlers we removed (because they reached the limit).

					self.eventHandlers[evt] = underscore.without(self.eventHandlers[evt], null);
				});
			};

			// }}}3
		};
	})();

	// mixinDebugging {{{2

	function mixinDebugging(obj, tagStart) {
		if (tagStart != null && typeof tagStart !== 'string' && typeof tagStart !== 'function') {
			throw new Error('Call Error: `tagStart` must be null, a string, or a function');
		}

		var getTag = function (self) {
			if (typeof tagStart === 'function') {
				return tagStart.call(self);
			}
			else if (typeof tagStart === 'string') {
				return tagStart;
			}
			else if (typeof self.getDebugTag === 'function') {
				return self.getDebugTag();
			}
			else if (typeof self.toString === 'function' && self.toString !== Object.toString) {
				return self.toString();
			}
			else {
				return obj.prototype.constructor.name.toUpperCase();
			}
		};

		obj.prototype.debug = function () {
			var args = Array.prototype.slice.call(arguments);
			var tag = args.shift();
			var fullTag = getTag(this);
			if (tag != null) {
				fullTag += ' // ' + tag;
			}
			debug.info.apply(null, Array.prototype.concat.call([fullTag], args));
		};
	}

	// mixinLogging {{{2

	function mixinLogging(obj, tagPrefix) {
		if (tagPrefix != null && typeof tagPrefix !== 'string' && typeof tagPrefix !== 'function') {
			throw new Error('Call Error: `tagPrefix` must be null, a string, or a function');
		}

		var getTag = function (self) {
			if (typeof tagStart === 'function') {
				return tagStart.call(self);
			}
			else if (typeof tagStart === 'string') {
				return tagStart;
			}
			else if (typeof self.getDebugTag === 'function') {
				return self.getDebugTag();
			}
			else if (typeof self.toString === 'function' && self.toString !== Object.toString) {
				return self.toString();
			}
			else {
				return obj.prototype.constructor.name.toUpperCase();
			}
		};

		var makeLogger = function (loggerType) {
			return function () {
				var args = Array.prototype.slice.call(arguments);
				var tag = args.shift();
				var msg = args.shift();
				var prefix = ['[' + getTag(this) + ' // ' + tag + '] ' + msg];
				var call = Function.prototype.call;
				call.apply(call, [console[loggerType], console].concat(prefix, args));
			};
		};

		obj.prototype.logInfo = makeLogger('log');
		obj.prototype.logWarning = makeLogger('warn');
		obj.prototype.logError = makeLogger('error');
	}

	// Locking {{{1

	/**
	 * @namespace util.locking
	 */

	/**
	 * Locks exist because we may have multiple asynchronous chunks of JavaScript running at the same
	 * time which interfere with each other.
	 *
	 * A really good example is preferences: loading them into the jQWidgets grid fires the event
	 * handlers associated with changing all the items in the prefs.  The preferences contain column
	 * widths, so loading them causes all the column resize event handlers to fire.  So we have a lock
	 * for preferences.  We engage it when load the preferences, then the event handlers find the lock
	 * engaged, so they don't try to save the preferences.  When the preferences are done loading, we
	 * disengage the lock, and event handlers are free to save prefs again.
	 */

	/**
	 * Engage the lock with the given name.
	 */

	function lock(defn, name) {
		if (defn.locks === undefined) {
			defn.locks = {};
		}

		if (defn.locks[name] === undefined) {
			defn.locks[name] = 0;
		}

		defn.locks[name] += 1;
		debug.info('LOCK', 'Locking ' + name + ' - ' + defn.locks[name]);
	}

	/**
	 * Disengage the lock with the given name.
	 */

	function unlock(defn, name) {
		if (defn.locks === undefined) {
			defn.locks = {};
		}

		if (defn.locks[name] === undefined) {
			defn.locks[name] = 1;
		}

		defn.locks[name] -= 1;
		debug.info('LOCK', 'Unlocking ' + name + ' - ' + defn.locks[name]);
	}

	/**
	 * Check to see if the lock with the given name is engaged or not.
	 */

	function isLocked(defn, name) {
		return defn.locks && !!defn.locks[name];
	}

	// HTML {{{1

	/**
	 * @namespace util.html
	 */

	/**
	 * Returns the HTML used to construct the argument.
	 */

	function outerHtml(elt) {
		return jQuery('<div>').append(elt).html();
	}

	/**
	 * Get all the next nodes which are direct children of the specified nodes.
	 *
	 * @param selector jQuery selector used to search for nodes containing text
	 * children.
	 *
	 * @return An array of strings, each element being the text of a node matched
	 * by the specified selector.
	 */

	function getText(selector) {
		return jQuery(selector).map(function (i, x) {
			return jQuery(x).text();
		});
	}

	function isVisible(elt) {
		return elt.css('display') !== 'none' && elt.css('visibility') === 'visible';
	}

	function isElement(x) {
		return x instanceof Element || x instanceof jQuery;
	}

	function getElement(x) {
		return x instanceof Element ? x
			: x instanceof jQuery ? x.get(0)
			: null;
	}

	/*
	 * Taken from --
	 *   https://stackoverflow.com/a/7557433/5628
	 */

	function isElementInViewport (parent, elt) {
		if (elt instanceof jQuery) {
			elt = elt.get(0);
		}

		var eltRect = elt.getBoundingClientRect();

		if (eltRect.top < 0 || eltRect.left < 0) {
			return false;
		}

		if (parent !== window) {
			if (parent instanceof Element) {
				parent = jQuery(parent);
			}

			var parentRect = parent.get(0).getBoundingClientRect();
			//console.log('top=' + eltRect.top + ', ' +
			//						'left=' + eltRect.left + ', ' +
			//						'bottom=' + eltRect.bottom + ', ' +
			//						'height=' + (parent.innerHeight() + parentRect.top));
			return eltRect.bottom <= parent.innerHeight() + parentRect.top;
		}
		else {
			//console.log('top=' + eltRect.top + ', ' +
			//						'left=' + eltRect.left + ', ' +
			//						'bottom=' + eltRect.bottom + ', ' +
			//						'height=' + window.innerHeight);
			return eltRect.bottom <= window.innerHeight;
		}
	}

	function onVisibilityChange(parent, elt, callback) {
		var old_visible;
		return function () {
			var visible = isElementInViewport(parent, elt);
			if (visible !== old_visible) {
				if (old_visible !== undefined && typeof callback == 'function') {
					callback(visible);
				}
				old_visible = visible;
			}
		}
	}

	function fontAwesome(icon, cls, title) {
		var span = jQuery('<span>')
			.addClass('fa');

		if (icon.substr(0, 3) === 'fa-') {
			span.addClass(icon);
		}
		else {
			span.text(String.fromCharCode(parseInt(icon, 16)));
		}

		if (cls !== undefined) {
			span.addClass(cls);
		}

		if (title !== undefined) {
			span.attr('title', title);
		}

		return span;
	}

	/**
	 * @function loadScript
	 * @description
	 *
	 * Dynamically load JavaScript from a URL into the page.
	 *
	 * Here's an example of using the `needAsyncSetup` option:
	 *
	 * ```
	 * return loadScript('https://www.gstatic.com/charts/loader.js', function (wasAlreadyLoaded, k) {
	 *   if (!wasAlreadyLoaded) {
	 *     google.charts.load('current', {'packages':['corechart']});
	 *     google.charts.setOnLoadCallback(k);
	 *   }
	 *   else {
	 *     k();
	 *   }
	 * }, {
	 *   needAsyncSetup: true
	 * });
	 * ```
	 *
	 * Calling `k()` *must* be done to properly unlock the loading code (only one file is loaded at a
	 * time) but only after everything is fully set up.
	 *
	 * @param {string} url
	 * The URL to load a script file from.
	 *
	 * @param {function} callback
	 * A function that receives at least one argument, a boolean which is true if the script was already
	 * loaded in the page.  The callback will not be called until the browser has finished executing the
	 * script, so it can safely use anything that the script provides.  If the callback needs to perform
	 * any additional setup before the loading is considered "complete" then use the `needAsyncSetup`
	 * option as shown below.
	 *
	 * @param {object} [opts]
	 * Additional options (see below).
	 *
	 * @param {boolean} [opts.needAsyncSetup = false]
	 * If true, then the callback function receives an additional argument, another function *which it
	 * must call* when finished.  This is specifically to support Google's JS API "loader" script, which
	 * requires additional (asynchronous) setup.
	 */

	var loadScript = (function () {
		var alreadyLoaded = {};
		var lock = new Lock('LOAD SCRIPT');
		return function (url, callback, opts) {
			underscore.defaults(opts, {
				needAsyncSetup: false
			});

			// https://stackoverflow.com/a/950146

			var load = function (url, callback) {
				// Adding the script tag to the head as suggested before
				var head = document.getElementsByTagName('head')[0];
				var script = document.createElement('script');
				script.type = 'text/javascript';
				script.src = url;

				// Then bind the event to the callback function.
				// There are several events for cross browser compatibility.
				script.onreadystatechange = callback;
				script.onload = callback;

				// Fire the loading
				head.appendChild(script);
			};

			var makeCb = function (isAlreadyLoaded) {
				var showLoadMsg = function () {
					if (isAlreadyLoaded) {
						debug.info('UTIL // LOAD SCRIPT', '[url = %s] Already loaded', url);
					}
					else {
						debug.info('UTIL // LOAD SCRIPT', '[url = %s] Finished executing loaded script', url);
					}
				};

				if (opts.needAsyncSetup) {
					return function () {
						showLoadMsg();
						callback(isAlreadyLoaded, function () {
							debug.info('UTIL // LOAD SCRIPT', '[url = %s] Exiting control of the script loader', url);
							if (!isAlreadyLoaded) {
								alreadyLoaded[url] = true;
								lock.unlock();
							}
						});
					};
				}
				else {
					return function () {
						showLoadMsg();
						debug.info('UTIL // LOAD SCRIPT', '[url = %s] Exiting control of the script loader', url);
						if (!isAlreadyLoaded) {
							alreadyLoaded[url] = true;
							lock.unlock();
						}
						callback(isAlreadyLoaded);
					};
				}
			};

			lock.onUnlock(function () {
				if (alreadyLoaded[url]) {
					makeCb(true)();
				}
				else {
					lock.lock();
					load(url, makeCb(false));
				}
			}, sprintf$1.sprintf('Waiting to load [url = %s]', url));
		};
	})();

	/**
	 * Set the value of a table cell.
	 *
	 * @param {jQuery|HTMLTableCellElement} cell
	 * @param {Element|jQuery|string|number} value
	 * @param {object} opts
	 * @param {string} opts.field
	 * @param {OrdMap} opts.colConfig
	 * @param {OrdMap} opts.typeInfo
	 */

	function setTableCell(cell, value, opts) {
		opts = opts || {};

		var fcc = (opts.colConfig instanceof OrdMap && opts.colConfig.get(opts.field)) || opts.colConfig || {};
		var fti = (opts.typeInfo instanceof OrdMap && opts.typeInfo.get(opts.field)) || opts.typeInfo || {};

		if (cell instanceof jQuery) {
			cell = cell.get(0);
		}

		if (!(cell instanceof HTMLTableCellElement)) {
			throw new Error('Call Error: `cell` must be a HTMLTableCellElement instance');
		}

		var container = cell;

		if (fcc.maxHeight != null && value !== '') {
			var wrapper = document.createElement('div');
			wrapper.classList.add('wcdv_maxheight_wrapper');
			wrapper.style.maxHeight = fcc.maxHeight;

			if (fcc.width) {
				wrapper.classList.add('wcdv_maxheight_wrapper_withwidth');
				wrapper.style.width = fcc.width;
			}

			var showValueBtn = document.createElement('button');
			showValueBtn.setAttribute('title', 'Full value has been truncated; click to show it.');
			showValueBtn.classList.add('wcdv_icon_button');
			showValueBtn.classList.add('wcdv_icon_button_incell');
			showValueBtn.classList.add('wcdv_icon_button_nolabel');
			showValueBtn.classList.add('wcdv_show_full_value');

			var showValueSpan = document.createElement('span');
			showValueSpan.classList.add('fa');
			showValueSpan.classList.add('fa-asterisk');

			container = document.createElement('div');

			// cell (td)
			//   wrapper (div)
			//     showValueBtn (button)
			//       showValueSpan (span.fa)
			//     container (div)

			cell.appendChild(wrapper);
			wrapper.appendChild(showValueBtn);
			showValueBtn.appendChild(showValueSpan);
			wrapper.appendChild(container);
		}

		setElement(container, value, opts);
	}

	/**
	 * Set the value of an element.
	 *
	 * @param {jQuery|Element} container
	 * @param {Element|jQuery|string|number} value
	 * @param {object} opts
	 * @param {string} opts.field
	 * @param {OrdMap} opts.colConfig
	 * @param {OrdMap} opts.typeInfo
	 */

	function setElement(container, value, opts) {
		opts = opts || {};

		var fcc = (opts.colConfig instanceof OrdMap && opts.colConfig.get(opts.field)) || opts.colConfig || {};
		var fti = (opts.typeInfo instanceof OrdMap && opts.typeInfo.get(opts.field)) || opts.typeInfo || {};

		if (container instanceof jQuery) {
			container = container.get(0);
		}

		if (!(container instanceof Element)) {
			throw new Error('Call Error: `container` must be an Element instance');
		}

		if (value instanceof Element) {
			container.appendChild(value);
		}
		else if (value instanceof jQuery) {
			container.appendChild(value.get(0));
		}
		else if (fcc.allowHtml && fti.type === 'string') {
			container.innerHTML = value;
		}
		else if (value === '') {
			container.innerText = '\u00A0';
		}
		else {
			container.innerText = value;
		}
	}

	// makeCheckbox {{{2

	function makeCheckbox(startChecked, onChange, text, parent) {
		var label = jQuery('<label>');
		var input = jQuery('<input>', { 'type': 'checkbox', 'checked': startChecked }).on('change', onChange);

		label.append(input).append(text).appendTo(parent);

		return input;
	}

	// makeToggleCheckbox {{{2

	function makeToggleCheckbox(rootObj, path, startChecked, text, parent, after) {
		if (rootObj != null) {
			setPropDef(startChecked, rootObj, path);
		}

		return makeCheckbox(rootObj != null ? getProp(rootObj, path) : startChecked, function () {
			var isChecked = jQuery(this).prop('checked');
			if (rootObj != null) {
				debug.info('GRID // TOOLBAR', 'Setting `' + path.join('.') + '` to ' + isChecked);
				setProp(isChecked, rootObj, path);
			}
			if (typeof after === 'function') {
				after(isChecked);
			}
		}, text, parent);
	}

	// makeRadioButtons {{{2

	/**
	 * @typedef makeRadioButtons_values
	 *
	 * @property {string} label
	 *
	 * @property {string} value
	 */

	/**
	 * @param {Object} rootObj
	 * Object to update when radio button is selected.
	 *
	 * @param {string[]} path
	 * Path within the object to set the value of the selected radio button.
	 *
	 * @param {string} def
	 * Default value to set in the object.
	 *
	 * @param {string} [label]
	 * Label to put before the group of radio buttons.
	 *
	 * @param {string} name
	 * Name of the form variable.
	 *
	 * @param {Array.<string|makeRadioButtons_values>} values
	 * Possible values to create radio buttons for.
	 *
	 * @param {function} [conv]
	 * Pass selected value through this function to convert it (e.g. "true" -> 1).
	 *
	 * @param {function} [onChange]
	 * Function to call when the value is changed.
	 *
	 * @param {Element|jQuery} parent
	 * Element to place the radio buttons within.
	 */

	function makeRadioButtons(rootObj, path, def, label, name, values, conv, onChange, parent) {
		setPropDef(def, rootObj, path);
		var initial = getProp(rootObj, path);

		var root = jQuery('<div>').css('display', 'inline-block').appendTo(parent);

		var handler = function () {
			var selected = root.find('input[type=radio]:checked').val();
			if (typeof conv === 'function') {
				selected = conv(selected);
			}
			debug.info('GRID // TOOLBAR', 'Setting `' + path.join('.') + '` to ' + selected);
			setProp(selected, rootObj, path);
			if (typeof onChange === 'function') {
				onChange(selected);
			}
		};

		if (label) {
			jQuery('<label>').text(label).appendTo(root);
		}
		underscore.each(values, function (v) {
			var label = underscore.isString(v) ? v : v.label;
			var value = underscore.isString(v) ? v : v.value;
			jQuery('<label>')
				.append(jQuery('<input>', { 'type': 'radio', 'name': name, 'value': value })
								.on('change', handler))
				.append(label)
				.appendTo(root);
		});
		root.find('input[type=radio]').val([initial]);
		return root;
	}

	// Input / Output {{{1

	/**
	 * @namespace util.io
	 */

	function valueInfo(value) {
		if (underscore.isNumber(value)) {
			return [value, ': Number'];
		}
		else if (underscore.isString(value)) {
			return ['"' + value + '"', ': String'];
		}
		else if (underscore.isArray(value)) {
			return [value, ': Array'];
		}
		else if (underscore.isObject(value)) {
			return [value, ': Object'];
		}
		else {
			return [value, ': Unknown'];
		}
	}

	function addSrcInfo(srcIndex, field) {
		return ':' + srcIndex + ':' + field;
	}

	/**
	 * Logging wrappers.
	 */

	var log = {
		info: Function.prototype.bind.call(window.console.log, window.console),
		warn: Function.prototype.bind.call(window.console.warn, window.console),
		error: Function.prototype.bind.call(window.console.error, window.console)
	};

	/**
	 * More logging wrappers.
	 */

	var concatLog = {
		info: function () {
			log.info.apply(window.console, underscore.flatten(arguments, true));
		},
		warn: function () {
			log.warn.apply(window.console, underscore.flatten(arguments, true));
		},
		error: function () {
			log.error.apply(window.console, underscore.flatten(arguments, true));
		}
	};

	/**
	 * Debug logging.
	 */

	var debug = {
		info: function (tag) {
			if (!(window.MIE && window.MIE.DEBUGGING)) {
				return;
			}

			var rest = Array.prototype.slice.call(arguments, 1);
			var args = Array.prototype.concat.call(['[DEBUG // ' + tag + '] ' + rest[0]], rest.slice(1));

			return log.info.apply(window.console, args);
		},
		warn: function (tag) {
			if (!(window.MIE && window.MIE.DEBUGGING)) {
				return;
			}

			var rest = Array.prototype.slice.call(arguments, 1);
			var args = Array.prototype.concat.call(['[DEBUG // ' + tag + '] ' + rest[0]], rest.slice(1));

			return log.warn.apply(window.console, args);
		},
		error: function (tag) {
			if (!(window.MIE && window.MIE.DEBUGGING)) {
				return;
			}

			var rest = Array.prototype.slice.call(arguments, 1);
			var args = Array.prototype.concat.call(['[DEBUG // ' + tag + '] ' + rest[0]], rest.slice(1));

			return log.error.apply(window.console, args);
		},
	};

	var logAsync = (function () {
		var ids = {};
		return function (id) {
			ids[id] = ids[id] == null ? 0 : ids[id] + 1;
			id += '[' + ids[id] + ']';
			console.log('~~~ ASYNC: ' + id + ' - START');
			return {
				finish: function () {
					console.log('~~~ ASYNC: ' + id + ' - FINISH');
				}
			};
		};
	})();

	/**
	 * Issue a warning about deprecated usage.  This also sends an email at the warning level, so that
	 * we can see any systems which are using deprecated features.
	 *
	 * @param {object} defn The grid definition.
	 * @param {string} msg The explanatory message.
	 * @param {string} ref Section in the wiki that describes this deprecated usage.
	 *
	 * @example
	 * deprecated(defn, 'Usage of [showColumns] and [hideColumns] is deprecated.', 'Showing_.26_Hiding_Columns');
	 */

	function deprecated(defn, msg, ref) {
		var output = msg + ' See https://miewiki.med-web.com/wiki/index.php/Advanced_Reports:_Filtering,_Graphing,_Comparing#' + ref + ' for more information.';
		emailWarning(defn, output);
	}

	function convert(cell, fti) {
		var value = cell.value;
		var error = function (msg) {
			log.error('Unable to convert cell value, %s: field = "%s", fti.type = %s, fti.internalType = %s, value = %O (%s)', msg, fti.field || '[unknown]', fti.type, fti.internalType, value, typeof value);
		};

		if (cell.decoded) {
			return;
		}

		if (cell.orig === undefined) {
			cell.orig = cell.value;
		}

		switch (fti.type) {
		case 'number':
		case 'currency':
			if (typeof cell.value === 'number') {
				switch (fti.internalType) {
				case 'primitive':
					// number -> primitive ... Nothing to do.
					break;
				case 'numeral':
					// number -> numeral
					cell.value = numeral(cell.value);
					break;
				case 'bignumber':
					// number -> bignumber
					cell.value = new bignumber(cell.value);
					break;
				default:
					return error('unsupported internal representation');
				}
			}
			else if (typeof cell.value === 'string') {
				if (cell.value === '') {
					cell.value = null;
				}
				else {
					switch (fti.internalType) {
					case 'primitive':
						// string -> primitive
						cell.value = parseNumber(cell.value);
						if (cell.value == null) {
							return error('cannot decode primitive number');
						}
						break;
					case 'numeral':
						// string -> numeral
						var newVal = parseNumber(cell.value);
						if (newVal == null) {
							cell.value = null;
							return error('cannot decode primitive number');
						}
						cell.value = numeral(newVal);
						break;
					case 'bignumber':
						var newVal = parseNumber(cell.value, 'string');
						if (newVal == null) {
							cell.value = null;
							return error('invalid value');
						}
						cell.value = new bignumber(newVal);
						break;
					default:
						return error('unsupported internal representation');
					}
				}
			}
			else if (numeral.isNumeral(cell.value) || bignumber.isBigNumber(cell.value)) ;
			else {
				return error('unsupported value type');
			}
			break;
		case 'date':
		case 'time':
		case 'datetime':
			if (typeof cell.value === 'string') {
				if (cell.value === '') {
					cell.value = null;
				}
				else {
					switch (fti.internalType) {
					case 'moment':
						// string -> moment
						cell.value = moment(cell.value, fti.format);
						break;
					case 'string':
						// string -> string ... Nothing to do.
						break;
					default:
						return error('unsupported internal representation');
					}
				}
			}
			else if (cell.value instanceof Date) {
				switch (fti.internalType) {
				case 'moment':
					// date -> moment
					cell.value = moment(cell.value, fti.format);
					break;
				default:
					return error('unsupported internal representation');
				}
			}
			else if (moment.isMoment(cell.value)) ;
			else {
				return error('unsupported value type');
			}
			break;
		case 'string':
			if (typeof cell.value === 'string') ;
			else if (cell.value == null) {
				cell.value = '';
			}
			else {
				// We have the data in some other type, like a date or a number, but the user wants to treat
				// it as a string.  This is strange, but it's easy to convert so we just let it go.
				cell.value = '' + cell.value;
			}
			break;
		default:
			return error('unsupported target type');
		}

		cell.decoded = true;
	}

	/**
	 * Correctly format a value according to its type and user specification.
	 *
	 * @param {object} colConfig Configuration object for the column corresponding to this field.
	 *
	 * @param {object} typeInfo
	 *
	 * @param {Cell} cell The true value, as used by the View to perform sorting and
	 * filtering.
	 *
	 * @param {object} opts
	 * Additional options.
	 *
	 * @param {boolean} [opts.debug=false]
	 * If true, some debugging output is produced.  Turned off by default because it tends to be noisy
	 * and thus slow down the browser.
	 *
	 * @param {string} [opts.overrideType]
	 * If true, the type of the data is assumed to be that specified, instead of what's in `typeInfo`.
	 * This is often used when outputting aggregate function results that have a different type from the
	 * type of the field they're applied on (e.g. "distinct values" always produces a string, even if
	 * it's applied over a field that contains dates or currency).
	 *
	 * @param {boolean} [saferCaching=true]
	 * If true, only cache non-Element results from calling the `render` function on a cell.  In the
	 * event that the cell is displayed more than once (e.g. group summary or pivot output, where the
	 * single cell representing a rowval element is shown in each rowval having it as a member), if we
	 * cache the Element, it will be reused, and thus moved around on the page, causing all but one
	 * instance of the cell to disappear.
	 */

	function format(fcc, fti, cell, opts) {
		var newVal
			, isNegative = false
			, isSafeToCache = true;

		fcc = fcc || {};
		fti = fti || {};
		opts = opts || {};

		underscore.defaults(opts, {
			debug: false,
			overrideType: null,
			convert: true,
			saferCaching: true
		});

		if (opts.debug) {
			debug.info('FORMAT', 'typeInfo = %O ; colConfig = %O ; cell = %O ; opts = %O', fti, fcc, cell, opts);
		}

		// Convert from a number format string to a number format object.  Originally, there was only one
		// internal representation for a number, using the Numeral library.  The formatting string we
		// accepted was just passed to numeral#format().  Now we support other internal representations
		// and have a generalized object to specify how numbers should be formatted.  But we allow the
		// user to specify the same format strings they always have, convert them to the new object-driven
		// way of doing things, and apply them to all numbers regardless of representation.

		var formatStrToObj = function (formatStr, base) {
			var formatObj = deepCopy(base);

			if (formatStr[0] === '$') {
				formatObj.currencySymbol = '$';
				formatStr = formatStr.slice(1);
			}

			//TODO Better way to handle detection of currency symbols.
			//m = formatStr.match(/[\$\x7F-\uD7FF\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF]/);
			//setProp(m != null ? m[0] : '', formatObj, 'currencySymbol');

			m = formatStr.match(/^0,0/);
			setProp(!!m, formatObj, 'integerPart', 'grouping');

			m = formatStr.match(/\.(0+)$/);
			setProp(m != null ? m[1].length : 0, formatObj, 'decimalPlaces');

			return formatObj;
		};

		var bigNumberFormat = function (fmt) {
			var result = {
				prefix: '',
				decimalSeparator: fmt.radixPoint,
				secondaryGroupSize: 0,
				suffix: ''
			};

			if (fmt.integerPart.grouping) {
				result.groupSeparator = fmt.integerPart.groupSeparator;
				result.groupSize = fmt.integerPart.groupSize;
			}
			else {
				result.groupSize = 0;
			}
			if (fmt.fractionalPart.grouping) {
				result.fractionGroupSeparator = fmt.fractionalPart.groupSeparator;
				result.fractionGroupSize = fmt.fractionalPart.groupSize;
			}
			else {
				result.fractionGroupSize = 0;
			}

			return result;
		};

		var bigNumberRoundingMode = function (fmt) {
			switch (fmt.roundingMethod) {
			case 'up': // away from zero
				return bignumber.ROUND_UP;
			case 'down': // towards zero
				return bignumber.ROUND_DOWN;
			case 'ceil': // towards infinity
				return bignumber.ROUND_CEIL;
			case 'floor': // towards negative infinity
				return bignumber.ROUND_FLOOR;
			case 'half_up':
				// towards nearest neighbor; halfway point goes away from zero
				//   -2.5 => -3    -1.5 => -2    1.5 => 2    2.5 => 3
				return bignumber.ROUND_HALF_UP;
			case 'half_down':
				// towards nearest neighbor: halfway point goes towards zero
				//   -2.5 => -2    -1.5 => -1    1.5 => 1    2.5 => 2
				return bignumber.ROUND_HALF_DOWN;
			case 'half_even':
				// towards nearest neighbor: halfway point goes to even neighbor
				//   -2.5 => -2    -1.5 => -2    1.5 => 2    2.5 => 2
				return bignumber.ROUND_HALF_EVEN;
			case 'half_ceil':
				// towards nearest neighbor: halfway point goes towards infinity
				//   -2.5 => -2    -1.5 => -1    1.5 => 2    2.5 => 3
				return bignumber.ROUND_HALF_CEIL;
			case 'half_floor':
				// towards nearest neighbor: halfway point goes towards negative infinity
				//   -2.5 => -3    -1.5 => -2    1.5 => 1    2.5 => 2
				return bignumber.ROUND_HALF_FLOOR;
			}
		};

		var numeralFormat = function (fmt) {
			var result = '';

			result += fmt.integerPart.grouping ? '0,0' : '0';

			if (fmt.decimalPlaces == null) {
				result += '[.][0000000000000000]';
			}
			else if (fmt.decimalPlaces > 0) {
				result += '.';
				result += '0'.repeat(fmt.decimalPlaces);
			}

			return result;
		};

		var formatPrimitiveNumber = function (x, fmt, method) {
			var language;

			switch (method) {
			case 'intl':
				if (window.Intl != null && window.Intl.NumberFormat != null) {
					if (window.navigator.languages) {
						language = window.navigator.languages[0];
					}
					else {
						language = window.navigator.userLanguage || window.navigator.language;
					}

					var config = {
						useGrouping: fmt.integerPart.grouping
					};

					if (fmt.decimalPlaces != null) {
						config.minimumFractionDigits = fmt.decimalPlaces;
						config.maximumFractionDigits = fmt.decimalPlaces;
					}

					var intlNumFmt = new Intl.NumberFormat(language, config);
					console.log(intlNumFmt.resolvedOptions());
					return intlNumFmt.format(x);
				}
				else {
					return '' + x;
				}
			case 'bignumber':
				return new bignumber(x).toFormat(fmt.decimalPlaces, bigNumberRoundingMode(fmt), bigNumberFormat(fmt));
			case 'numeral':
				return numeral(x).format(numeralFormat(fmt));
			default:
				return '' + x;
			}
		};

		// When we just receive a value instead of a proper data cell, convert it so that code below can
		// be simplified.  These cells are just "pretend" and anything stored in them is going to be
		// discarded when this function is done.

		if ((moment.isMoment(cell))
				|| numeral.isNumeral(cell)
				|| bignumber.isBigNumber(cell)
				|| cell == null
				|| typeof cell !== 'object') {
			cell = {
				value: cell
			};
		}

		// When we've already rendered this cell before, just reuse that.

		if (cell.cachedRender != null) {
			return cell.cachedRender;
		}

		var result = cell.orig || cell.value;

		var t = opts.overrideType || fti.type;
		var format = fcc.format;
		var format_dateOnly = fcc.format_dateOnly;

		var defaultNumberFormat = {
			integerPart: {
				grouping: false,
				groupSize: 3,
				groupSeparator: ','
			},
			fractionalPart: {
				grouping: false,
				groupSize: 3,
				groupSeparator: ' '
			},
			radixPoint: '.',
			decimalPlaces: null,
			negativeFormat: 'minus',
			roundingMethod: 'half_up',
		};

		var defaultCurrencyFormat = deepDefaults({
			integerPart: {
				grouping: true
			},
			decimalPlaces: 2,
			negativeFormat: 'parens',
			currencySymbol: '$'
		}, defaultNumberFormat);

		// Set default formatting strings for some types.  Note that we're NOT setting one for generic
		// numbers, because they are often used in different ways (e.g. an ID should have no commas).

		if (format == null) {
			switch (t) {
			case 'number':
				format = deepCopy(defaultNumberFormat);
				break;
			case 'currency':
				format = deepCopy(defaultCurrencyFormat);
				break;
			case 'date':
				format = 'LL';
				break;
			case 'datetime':
				format = 'LLL';
				break;
			}
		}
		else {
			switch (t) {
			case 'number':
				format = typeof format === 'string'
					? formatStrToObj(format, defaultNumberFormat)
					: deepDefaults(format, defaultNumberFormat);
				break;
			case 'currency':
				format = typeof format === 'string'
					? formatStrToObj(format, defaultCurrencyFormat)
					: deepDefaults(format, defaultCurrencyFormat);
				break;
			}
		}

		if (format_dateOnly == null && t === 'datetime') {
			format_dateOnly = 'LL';
		}

		if (result == null || result === '') {
			result = '';
		}
		else if (['date', 'datetime'].indexOf(t) >= 0
			&& ((moment.isMoment(cell.value) && !cell.value.isValid())
				|| ['', '0000-00-00', '0000-00-00 00:00:00'].indexOf(cell.value) >= 0)) {

			// Handle zero dates like Webchart uses all the time.  Turn them into the empty string,
			// otherwise Moment will say "Invalid Date".

			result = '';
		}
		else {
			switch (t) {
			case 'date':
			case 'datetime':
				if (opts.convert) {
					convert(cell, fti);
				}

				if (moment.isMoment(cell.value)) {
					if (!cell.value.isValid()) {
						break;
					}

					if (t === 'datetime' && fcc.hideMidnight && cell.value.hour() === 0 && cell.value.minute() === 0 && cell.value.second() === 0) {
						result = cell.value.format(format_dateOnly);
					}
					else {
						result = cell.value.format(format);
					}
				}
				else {
					// FIXME: Make this work without Moment.

					var m = moment(cell.value);

					if (!m.isValid()) {
						break;
					}

					if (t === 'datetime' && fcc.hideMidnight && m.hour() === 0 && m.minute() === 0 && m.second() === 0) {
						result = m.format(format_dateOnly);
					}
					else {
						result = m.format(format);
					}
				}
				break;
			case 'number':
			case 'currency':
				if (opts.convert) {
					convert(cell, fti);
				}

				if (cell.value == null
						|| (fti.internalType === 'primitive' && Number.isNaN(cell.value))
						|| (fti.internalType === 'numeral' && (Number.isNaN(cell.value) || cell.value.value() === null))
						|| (fti.internalType === 'bignumber' && cell.value.isNaN())) {
					break;
				}

				if (bignumber.isBigNumber(cell.value)) {
					if (cell.value.isNaN()) {
						break;
					}

					if (cell.value.isNegative()) {
						isNegative = true;
						newVal = cell.value.abs();
					}
					else {
						newVal = cell.value;
					}

					result = newVal.toFormat(format.decimalPlaces, bigNumberRoundingMode(format), bigNumberFormat(format));
				}
				else if (numeral.isNumeral(cell.value)) {
					if (cell.value.value() === null) {
						break;
					}

					if (cell.value.value() < 0) {
						isNegative = true;
						newVal = cell.value.multiply(-1);
					}
					else {
						newVal = cell.value;
					}

					result = cell.value.format(numeralFormat(format));
				}
				else {
					if (Number.isNaN(cell.value)) {
						break;
					}

					if (cell.value < 0) {
						isNegative = true;
						newVal = cell.value * -1;
					}
					else {
						newVal = cell.value;
					}

					result = formatPrimitiveNumber(newVal, format, 'bignumber');
				}

				if (isNegative) {
					switch (format.negativeFormat) {
					case 'minus':
						result = (t === 'currency' ? format.currencySymbol : '') + '-' + result;
						break;
					case 'parens':
						result = '(' + (t === 'currency' ? format.currencySymbol : '') + result + ')';
						break;
					}
				}
				else {
					result = (t === 'currency' ? format.currencySymbol : '') + result;
				}

				break;
			case 'string':
				result = cell.value;
				break;
			default:
				log.error('Unable to format - unknown type: { field = "%s", type = "%s", value = "%s" }',
					fti.field, t, cell.value);
			}
		}

		// If there's a rendering function, pass the (possibly formatted) value through it to get the new
		// value to display.  If the rendering function returns an Element (possibly built via jQuery),
		// mark the result as unsafe to cache, because an Element can't be on the page more than once, so
		// we need to have the rendering function make it every time, in the event that the same cell is
		// displayed more than once in the grid.

		if (typeof cell.render === 'function') {
			result = cell.render(result);
			if (opts.saferCaching && (result instanceof jQuery || result instanceof Element)) {
				isSafeToCache = false;
			}
		}

		if (isSafeToCache) {
			cell.cachedRender = result;
		}

		return result;
	}

	// Date and Time Formatting {{{1

	/**
	 * @namespace util.datetime
	 */

	// Initialize date and time format strings from user preferences.  There doesn't seem to be a
	// builtin way to convert the magick numbers into format strings, but since they're stored in the
	// database it seems safe to assume that they won't change.

	var dateFormatString = 'yyyy-MM-dd';
	var timeFormatString = 'HH:mm:ss';

	/**
	 * Initialization function to grab things we need before doing anything else (e.g. user
	 * preferences).  This function is asynchronous and requires that you pass it a continuation.
	 */

	function init(cont) {
		switch (miecgictrl.dateformat) {
		case 1:
			dateFormatString = 'MM-dd-yyyy';
			break;
		case 2:
			dateFormatString = 'dd-MM-yyyy';
			break;
		case 3:
			dateFormatString = 'yyyy-MM-dd';
			break;
		default:
			dateFormatString = 'yyyy-MM-dd';
		}
		timeFormatString = miecgictrl.militaryTime ? 'HH:mm:ss' : 'hh:mm:ss tt';
		cont();
	}

	/**
	 * Format a Date object according to the user's date formatting preferences.  To be accurate, you
	 * need to call the init() function first.
	 *
	 * @param {Date} d The date to format.
	 * @returns {string} The date formatted according to the user's preference.
	 */

	function formatDate(d) {
		var convert = {
			'MM': function (x) {
				var m = x.getMonth() + 1;
				return m > 9 ? m : '0' + m;
			},
			'dd': function (x) {
				var d = x.getDate();
				return d > 9 ? d : '0' + d;
			},
			'yyyy': function (x) {
				return x.getFullYear();
			}
		};
		return underscore.map(dateFormatString.split('-'), function (fmt) {
			if (convert[fmt]) {
				return convert[fmt](d);
			}
			else {
				return '[UNKNOWN]';
			}
		}).join('-');
	}

	/**
	 * Format a Date object according to the user's time formatting preferences.  To be accurate, you
	 * need to call the init() function first.
	 *
	 * @param {Date} t The time to format.
	 * @returns {string} The time formatted according to the user's preference.
	 */

	function formatTime(t) {
		var convert = {
			'HH': function (x) {
				var h = x.getHours();
				return h > 9 ? h : '0' + h;
			},
			'hh': function (x) {
				var h = x.getHours();
				if (h === 0) {
					h = 12;
				}
				else if (h > 12) {
					h = h - 12;
				}
				return h > 9 ? h : '0' + h;
			},
			'mm': function (x) {
				var m = x.getMinutes();
				return m > 9 ? m : '0' + m;
			},
			'ss': function (x) {
				var s = x.getSeconds();
				return s > 9 ? s : '0' + s;
			},
			'tt': function (x) {
				var h = x.getHours();
				return h < 12 ? 'AM' : 'PM';
			}
		};
		return timeFormatString.replace(/[A-Za-z]+/g, function (fmt) {
			if (convert[fmt]) {
				return convert[fmt](t);
			}
		});
	}

	/**
	*/

	function formatDateTime(d) {
		return formatDate(d) + ' ' + formatTime(d);
	}

	/**
	*/

	function formatDateString(s) {
		if (s === '' || s === '0000-00-00' || s === '0000-00-00 00:00:00') {
			return '[UNKNOWN]';
		}
		return formatDate(new Date(s));
	}

	/**
	*/

	function formatTimeString(s) {
		if (s === '' || s === '0000-00-00' || s === '0000-00-00 00:00:00') {
			return '[UNKNOWN]';
		}
		return formatTime(new Date(s));
	}

	/**
	*/

	function formatDateTimeString(s) {
		if (s === '' || s === '0000-00-00' || s === '0000-00-00 00:00:00') {
			return '[UNKNOWN]';
		}
		formatDateTime(new Date(s));
	}

	/**
	*/

	function removeZeroDates(x) {
		return x === '0000-00-00' ? '' : x;
	}

	/**
	*/

	function removeZeroDateTimes(x) {
		return x === '0000-00-00 00:00:00' ? '' : x;
	}

	var DATE_ONLY_REGEXP = /^\d\d\d\d-\d\d-\d\d$/;

	/**
	*/

	function addTimeComponent(x) {
		return (typeof x === 'string' && DATE_ONLY_REGEXP.test(x)) ? x + ' 00:00:00' : x;
	}

	/**
	 * Block the grid.  If the grid has already been blocked, then nothing happens.
	 *
	 * @param {object} defn The definition of the report that created the grid to block.
	 * @param {function} fn If present, that function will be used as BlockUI's onBlock event handler.
	 * @param {string} info Message that can be logged when blocking.
	 */

	function blockGrid(defn, fn, info) {
		var grid;
		var blockConfig;
		var output;

		if (defn.table.blockCount === undefined) {
			defn.table.blockCount = 0;
		}

		defn.table.blockCount += 1;

		debug.info('BLOCKING // PUSH', '> COUNT =', defn.table.blockCount, '> INFO =', info);

		if (defn.table.blockCount === 1) {
			output = getProp(defn, 'table', 'output', 'method');

			switch (output) {
			case 'jqwidgets':
				grid = jQuery(document.getElementById(defn.table.id)).children('div [role="grid"]');
				break;
			case 'pivot':
				grid = jQuery(document.getElementById(defn.table.id));
				break;
			default:
				grid = null;
			}

			if (grid !== null) {
				blockConfig = {
					message: null,
					overlayCSS: {
						opacity: 0.9,
						backgroundColor: '#FFF'
					}
				};

				if (typeof fn === 'function') {
					blockConfig.onBlock = fn;
				}

				grid.block(blockConfig);
			}
			else {
				fn();
			}
		}
		else if (typeof fn === 'function') {
			fn();
		}
	}

	/**
	 * Unblock the grid.  If the grid has been blocked by more events then it has been unblocked by,
	 * then the block will remain.
	 *
	 * @param {object} defn The definition of the report that created the grid to block.
	 * @param {string} info Message that can be logged when unblocking.
	 */

	function unblockGrid(defn, info) {
		var grid;
		var output;

		if (defn.table.blockCount === undefined) {
			defn.table.blockCount = 0;
		}

		if (defn.table.blockCount > 0) {
			defn.table.blockCount -= 1;
			debug.info('BLOCKING // POP', ' > COUNT =', defn.table.blockCount, '> INFO =', info);
			if (defn.table.blockCount === 0) {
				output = getProp(defn, 'table', 'output', 'method');

				switch (output) {
				case 'jqwidgets':
					grid = jQuery(document.getElementById(defn.table.id)).children('div [role="grid"]');
					break;
				case 'pivot':
					grid = jQuery(document.getElementById(defn.table.id));
					break;
				default:
					grid = null;
				}

				if (grid !== null) {
					grid.unblock();
				}
			}
		}
	}

	/**
	 * Check to see if a grid is blocked.
	 *
	 * @param {object} defn The definition of the report that created the grid we want to check.
	 *
	 * @return {boolean} True if the grid is blocked, false if it is not.
	 */

	function gridIsBlocked(defn) {
		return defn.table.blockCount > 0;
	}

	/**
	 * Wrap a function to execute while the grid is blocked.  Blocks the grid, calls the function, and
	 * unblocks immediately afterward.  You probably only want to use this is the function you provide
	 * is not asynchronous (otherwise the grid will unblock "early" when the function returns).
	 *
	 * @param {object} defn The definition of the report that created the grid to block.
	 *
	 * @param {function} fn A zero-arity function to call after the grid has been blocked.  After this
	 * function returns, the grid is unblocked.
	 *
	 * @param {string} info Message that can be logged when blocking/unblocking.
	 */

	function withGridBlock(defn, fn, info) {
		if (typeof fn !== 'function') {
			throw Error('Call Error: `fn` must be a function');
		}

		blockGrid(defn, function () {
			// This shouldn't be necessary because we're doing it in BlockUI's onBlock event handler, but
			// for whatever reason it doesn't always work... oftentimes, when fn() executes, the element
			// is not visually blocked.  This seems to be much more consistent in how it looks.

			window.setTimeout(function () {
				fn();
				unblockGrid(defn, info);
			}, jQuery.blockUI.defaults.fadeIn);
		}, info);
	}

	// Timing {{{1

	function Timing() {
		var self = this;

		self.data = {};
		self.events = {};
		self.eventCount = {};
	}

	// #start {{{2

	Timing.prototype.start = function (what) {
		var self = this
			, subject = what[0]
			, event = what[1];

		setPropDef([], self.events, subject);
		setPropDef(0, self.eventCount, subject, event);
		setPropDef({}, self.data, subject);

		self.eventCount[subject][event] += 1;

		if (self.eventCount[subject][event] > 1) {
			event += ' (#' + self.eventCount[subject][event] + ')';
		}

		self.events[subject].push(event);

		debug.info('TIMING', 'Received <START> event for [' + subject + ' : ' + event + ']');

		setProp(Date.now(), self.data, subject, event, 'start');
	};

	// #stop {{{2

	Timing.prototype.stop = function (what) {
		var self = this
			, subject = what[0]
			, event = what[1];

		setPropDef(0, self.eventCount, subject, event);

		if (self.eventCount[subject][event] > 1) {
			event += ' (#' + self.eventCount[subject][event] + ')';
		}

		debug.info('TIMING', 'Received <STOP> event for [' + subject + ' : ' + event + ']');

		if (getProp(self.data, subject, event, 'start') === undefined) {
			log.warn('Received <STOP> event for [' + subject + ' : ' + event + '] with no <START> event');
			return;
		}

		setProp(Date.now(), self.data, subject, event, 'end');
	};

	// #getSubjects {{{2

	Timing.prototype.getSubjects = function () {
		return underscore.keys(this.events);
	};

	// #dump {{{2

	Timing.prototype.dump = function (subject) {
		var self = this;

		var f = function (sub) {
			if (isNothing(self.events[sub])) {
				throw new Error('Unknown subject: ' + sub);
			}

			underscore.each(self.events[sub], function (evt) {
				var start = getProp(self.data, sub, evt, 'start')
					, end = getProp(self.data, sub, evt, 'end');

				log.info('[TIMING] ' + sub + ' : ' + evt + ' >> ' + (end - start) + 'ms');
			});
		};

		if (subject != null) {
			f(subject);
		}
		else {
			underscore.each(self.getSubjects(), f);
		}
	};

	// }}}1

	function delegate(from, to, methods) {
		if (!underscore.isArray(methods)) {
			methods = [methods];
		}
		underscore.each(methods, function (m, i) {
			if (typeof m !== 'string') {
				throw new Error('Call Error: `methods[' + i + ']` must be a string');
			}
			from.prototype[m] = function () {
				var args = Array.prototype.slice.call(arguments);
				return this[to][m].apply(this[to], args);
			};
		});
	}

	// https://stackoverflow.com/questions/901115/

	function getParamsFromUrl() {
		var match, key, val,
			pl     = /\+/g,  // Regex for replacing addition symbol with a space
			search = /([^&=]+)=?([^&]*)/g,
			decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); },
			query  = window.location.search.substring(1),
			params = {};

		while (match = search.exec(query)) {
			key = decode(match[1]);
			val = decode(match[2]);
			if (params[key]) {
				if (!underscore.isArray(params[key])) {
					params[key] = [params[key]];
				}
				params[key].push(val);
			}
			else {
				params[key] = val;
			}
		}

		return params;
	}

	function validateColConfig(colConfig, data) {
		if (!(colConfig instanceof OrdMap)) {
			throw new Error('Call Error: `colConfig` must be an OrdMap instance');
		}

		if (data != null) {
			if ((data.isPivot && (data.data.length === 0 || data.data[0].length === 0 || data.data[0][0].length === 0))
				|| (!data.isPivot && data.isGroup && (data.data.length === 0 || data.data[0].length === 0))
				|| (data.isPlain && (data.data.length === 0))) {
				log.warn('Unable to check column configuration using data with no rows');
				return false;
			}
			else {
				colConfig.each(function (fcc, field) {
					if ((data.isPivot && data.data[0][0][0].rowData[field] === undefined)
							|| (!data.isPivot && data.isGroup && data.data[0][0].rowData[field] === undefined)
							|| (data.isPlain && data.data[0].rowData[field] === undefined)) {
						log.warn('Column configuration refers to field "' + field + '" which does not exist in the data');
						return false;
					}
				});
			}
		}

		return true;
	}

	/**
	 * Determine which columns should be shown in plain or grouped output, based on information from
	 * several sources.
	 *
	 * If the user has set `defn.table.columns`, then it will be used to figure out what fields are to
	 * be shown.  Otherwise, the fields come from the source's type info, and fields starting with an
	 * underscore are omitted.
	 *
	 * @todo What do we do when the data has been pivotted?
	 *
	 * @param {Grid~Defn} defn
	 *
	 * @param {array} data
	 *
	 * @param {Source~TypeInfo} typeInfo
	 *
	 * @returns {Array.<string>} An array of the names of the fields that should constitute the columns
	 * in the output.  This is not necessarily the same as the headers to be shown in the output.
	 */

	function determineColumns(colConfig, data, typeInfo) {
		var columns = [];

		if (!(colConfig instanceof OrdMap)) {
			throw new Error('Call Error: `colConfig` must be an OrdMap instance');
		}

		if (!(typeInfo instanceof OrdMap)) {
			throw new Error('Call Error: `typeInfo` must be an OrdMap instance');
		}

		validateColConfig(colConfig, data);

		// FIXME: Checking _keys.length is a stand-in for saying "this OrdMap has never had anything added
		// to it" and should be implemented in a way that doesn't use knowledge of OrdMap's internals.
		//
		// The reason for not just checking size is this test:
		//
		//   - defn: columns = ['A', 'B']
		//   - source: columns = ['X', 'Y', 'Z']
		//
		// The defn colConfig is stripped of fields not in the source, making it [].  Here, an empty
		// colConfig means to show all source fields.  But that defies the purpose of defn colConfig,
		// which is to limit what is visible: the correct behavior is to show nothing.  The fix is to
		// check instead that the OrdMap has never been changed, meaning it wasn't set by defn, and
		// therefore it's OK to show all fields.

		if (colConfig._keys.length > 0) {
			var notHidden = colConfig.filter(function (cc) {
				return !cc.isHidden;
			});
			var pinned = notHidden.filter(function (cc) {
				return cc.isPinned;
			}).keys();
			var notPinned = notHidden.filter(function (cc) {
				return !cc.isPinned;
			}).keys();
			columns = pinned.concat(notPinned);
		}
		else if (typeInfo.size() > 0) {
			columns = underscore.reject(typeInfo.keys(), function (field) {
				return field.charAt(0) === '_';
			});
		}
		else if (data != null) {
			if (data.isPlain && data.data.length > 0) {
				columns = underscore.keys(data.data[0].rowData);
			}
			else if (data.isGroup && data.data[0].length > 0) {
				columns = underscore.keys(data.data[0][0].rowData);
			}
			else if (data.isPivot && data.data[0][0].length > 0) {
				columns = underscore.keys(data.data[0][0][0].rowData);
			}
		}

		debug.info('DETERMINE COLUMNS', 'Columns = %O', columns);

		return columns;
	}

	// Downloading {{{1

	/**
	 * Present a blob as a download.  This works even in IE10!
	 *
	 * @param {Blob} blob
	 * The content to download.
	 *
	 * @param {string} fileName
	 * Default name to use for the file.
	 */

	function presentDownload(blob, fileName) {
		if (!(blob instanceof Blob)) {
			throw new Error('Call Error: `blob` must be a Blob');
		}

		// IE11 supports Blob, but doesn't allow you to fake a click on the download link.  Fortunately
		// for us, it has a function which does all of that for you in one step!

		if (window.navigator.msSaveBlob != null) {
			window.navigator.msSaveBlob(blob, fileName);
		}
		else {
			var a = document.createElement('a');
			a.download = fileName;
			a.href = URL.createObjectURL(blob);
			jQuery(document.body).append(a);
			a.click();
			a.remove();
		}
	}

	// https://stackoverflow.com/a/12300351

	/**
	 * Convert a data URI to a blob which can be downloaded.  This works even in IE10!
	 *
	 * @param {string} dataURI
	 * The URI to convert into a blob.
	 *
	 * @return {Blob}
	 * A blob that can be downloaded.
	 */

	function dataURItoBlob(dataURI) {
	  // convert base64 to raw binary data held in a string
	  // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
	  var byteString = atob(dataURI.split(',')[1]);

	  // separate out the mime component
	  var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

	  // write the bytes of the string to an ArrayBuffer
	  var ab = new ArrayBuffer(byteString.length);

	  // create a view into the buffer
	  var ia = new Uint8Array(ab);

	  // set the bytes of the buffer to the correct values
	  for (var i = 0; i < byteString.length; i++) {
	      ia[i] = byteString.charCodeAt(i);
	  }

	  // write the ArrayBuffer to a blob, and you're done
	  var blob = new Blob([ab], {type: mimeString});
	  return blob;

	}

	// Misc {{{1

	// https://stackoverflow.com/a/2117523

	function uuid() {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
			var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
			return v.toString(16);
		});
	}

	// sleep {{{2

	function sleep(ms) {
	}

	// EagerPipeline {{{1

	var EagerPipeline = makeSubclass('EagerPipeline', Object, function (x) {
		this.x = x;
	});

	// #andThen {{{2

	EagerPipeline.prototype.andThen = function (f) {
		var x = this.x;
		return new EagerPipeline(f(x));
	};

	// #andThenCurry {{{2

	EagerPipeline.prototype.andThenCurry = function () {
		var f = curry.apply(null, arguments);
		return this.andThen(f);
	};

	// #done {{{2

	EagerPipeline.prototype.done = function () {
		return this.x;
	};

	// Polyfills {{{1

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

	if (!String.prototype.repeat) {
	  String.prototype.repeat = function(count) {
	    if (this == null) { // check if `this` is null or undefined
	      throw new TypeError('can\'t convert ' + this + ' to object');
	    }
	    var str = '' + this;
	    // To convert string to integer.
	    count = +count;
	    if (count < 0) {
	      throw new RangeError('repeat count must be non-negative');
	    }
	    if (count == Infinity) {
	      throw new RangeError('repeat count must be less than infinity');
	    }
	    count |= 0; // floors and rounds-down it.
	    if (str.length == 0 || count == 0) {
	      return '';
	    }
	    // Ensuring count is a 31-bit integer allows us to heavily optimize the
	    // main part. But anyway, most current (August 2014) browsers can't handle
	    // strings 1 << 28 chars or longer, so:
	    if (str.length * count >= (1 << 28)) {
	      throw new RangeError('repeat count must not overflow maximum string size');
	    }
	    while (count >>= 1) { // shift it by multiple of 2 because this is binary summation of series
	       str += str; // binary summation
	    }
	    str += str.substring(0, str.length * count - str.length);
	    return str;
	  };
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN

	Number.isNaN = Number.isNaN || function(value) {
		return value !== value;
	};

	// https://developer.mozilla.org/en-US/docs/Web/API/Element/closest

	if (!Element.prototype.matches) {
	  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
	}

	if (!Element.prototype.closest) {
	  Element.prototype.closest = function(s) {
	    var el = this;

	    do {
	      if (el.matches(s)) return el;
	      el = el.parentElement || el.parentNode;
	    } while (el !== null && el.nodeType === 1);
	    return null;
	  };
	}

	var Util = /*#__PURE__*/Object.freeze({
		gensym: gensym,
		Y: Y,
		I: I,
		NOP: NOP,
		universalCmp: universalCmp,
		getComparisonFn: getComparisonFn,
		getNatRep: getNatRep,
		chain: chain,
		makeChain: makeChain,
		makeArray: makeArray,
		trulyYours: trulyYours,
		asyncChain: asyncChain,
		curry: curry,
		curryCtor: curryCtor,
		either: either,
		car: car,
		cdr: cdr,
		isInt: isInt,
		isFloat: isFloat,
		toInt: toInt,
		toFloat: toFloat,
		stringValueType: stringValueType,
		parseNumber: parseNumber,
		tryIntConvert: tryIntConvert,
		tryFloatConvert: tryFloatConvert,
		arrayCompare: arrayCompare,
		arrayEqual: arrayEqual,
		moveArrayElement: moveArrayElement,
		eachUntil: eachUntil,
		eachUntilObj: eachUntilObj,
		asyncEach: asyncEach,
		mapLimit: mapLimit,
		shallowCopy: shallowCopy,
		deepCopy: deepCopy,
		arrayCopy: arrayCopy,
		isNothing: isNothing,
		isEmpty: isEmpty,
		deepDefaults: deepDefaults,
		getProp: getProp,
		getPropDef: getPropDef,
		setProp: setProp,
		setPropDef: setPropDef,
		copyProps: copyProps,
		needProp: needProp,
		needPropIn: needPropIn,
		needPropArr: needPropArr,
		needPropObj: needPropObj,
		needPropInst: needPropInst,
		needArgInst: needArgInst,
		needArg: needArg,
		iota: iota,
		pruneTree: pruneTree,
		interleaveWith: interleaveWith,
		mergeSort: mergeSort,
		mergeSort2: mergeSort2,
		mergeSort3: mergeSort3,
		mergeSort4: mergeSort4,
		pigeonHoleSort: pigeonHoleSort,
		objGetPath: objGetPath,
		cmpObjField: cmpObjField,
		objFromArray: objFromArray,
		walkObj: walkObj,
		makeSubclass: makeSubclass,
		makeSuper: makeSuper,
		mixinEventHandling: mixinEventHandling,
		mixinDebugging: mixinDebugging,
		mixinLogging: mixinLogging,
		lock: lock,
		unlock: unlock,
		isLocked: isLocked,
		outerHtml: outerHtml,
		getText: getText,
		isVisible: isVisible,
		isElement: isElement,
		getElement: getElement,
		isElementInViewport: isElementInViewport,
		onVisibilityChange: onVisibilityChange,
		fontAwesome: fontAwesome,
		loadScript: loadScript,
		setTableCell: setTableCell,
		setElement: setElement,
		makeCheckbox: makeCheckbox,
		makeToggleCheckbox: makeToggleCheckbox,
		makeRadioButtons: makeRadioButtons,
		valueInfo: valueInfo,
		addSrcInfo: addSrcInfo,
		log: log,
		concatLog: concatLog,
		debug: debug,
		logAsync: logAsync,
		deprecated: deprecated,
		convert: convert,
		format: format,
		init: init,
		formatDate: formatDate,
		formatTime: formatTime,
		formatDateTime: formatDateTime,
		formatDateString: formatDateString,
		formatTimeString: formatTimeString,
		formatDateTimeString: formatDateTimeString,
		removeZeroDates: removeZeroDates,
		removeZeroDateTimes: removeZeroDateTimes,
		addTimeComponent: addTimeComponent,
		blockGrid: blockGrid,
		unblockGrid: unblockGrid,
		gridIsBlocked: gridIsBlocked,
		withGridBlock: withGridBlock,
		Timing: Timing,
		delegate: delegate,
		getParamsFromUrl: getParamsFromUrl,
		validateColConfig: validateColConfig,
		determineColumns: determineColumns,
		presentDownload: presentDownload,
		dataURItoBlob: dataURItoBlob,
		uuid: uuid,
		sleep: sleep,
		EagerPipeline: EagerPipeline
	});

	// Aggregate {{{1

	/**
	 * @class Aggregate
	 *
	 * Base class for all aggregate functions.  To make your own, extend it with {@linkcode
	 * makeSubclass makeSubclass()} like this:
	 *
	 * ```
	 * var MyAggregate = makeSubclass('MyAggregate', MIE.WC_DataVis.Aggregate, function () {
	 *   // constructor (optional)
	 * }, {
	 *   name: 'My Aggregate',
	 *   ... // override properties listed below
	 * });
	 * ```
	 *
	 * Aggregate functions are computed with the `calculate()` method.  You *must* either override the
	 * base class' implementation of this method, or provide an implementation of the `calculateStep()`
	 * method.  The base implementation of `calculate()` uses the abstract `calculateStep()` to iterate
	 * over each row in the data.  This is the most common use, but some aggregate functions (e.g.
	 * "count") don't need to iterate over all the rows, and therefore override `calculate()` with
	 * something simpler.
	 *
	 * After creating the class, it needs to be added to the aggregate registry:
	 *
	 * ```
	 * MIE.WC_DataVis.AGGREGATE_REGISTRY.set('briefUniqueName', MyAggregate);
	 * ```
	 *
	 * Since the registry is an {@linkcode OrdMap}, the aggregate functions appear in the user interface
	 * in the order they were added to the registry.
	 *
	 * @property {string} name
	 * Name of the aggregate function used in the dropdown menu by the grid.
	 *
	 * @property {int} [fieldCount=0]
	 * Number of fields required.  Usually zero or one.
	 *
	 * @property {string} [type]
	 * Fixed type of the result of this aggregate function.  Undefined indicates that the type depends
	 * on the field(s) used.
	 *
	 * @property {string[]} [allowedTypes]
	 * If fields have one of the types specified, that type overrides the fixed type.  This exists as a
	 * way of dealing with subtypes (e.g. "Sum" returns a number, but could also return a currency if
	 * the field it's operating on is a currency).
	 *
	 * @property {boolean} [inheritFormatting=false]
	 * If true, then the result should be formatted according to the formatting of the field(s).
	 *
	 * @property {any} [bottomValue]
	 * The value returned when an error occurs.  Also used as the "starting point" of the reduction over
	 * the data (i.e. zero or the empty string for most aggregates) when `init` isn't provided.
	 *
	 * @property {function|any} [init]
	 * The value used as the initial seed of the result calculation (which is a reduction/fold over the
	 * data).  If a function, that function is invoked with no arguments to get the value.  When not
	 * provided, the bottom value is used.
	 *
	 * @property {boolean} [enabled=true]
	 * If false, then the aggregate function will not be shown in the user interface.
	 */

	var Aggregate = makeSubclass('Aggregate', Object, function (opts) {
		var self = this;

		self.opts = deepDefaults(opts, {
			isHidden: false
		});
	}, {
		enabled: true,
		fieldCount: 0,
		fieldInfo: [],
		inheritFormatting: false,
		numItems: 0
	});

	// JSDoc {{{2

	/**
	 * @method calculateStep
	 * @abstract
	 * @memberof Aggregate
	 * @instance
	 *
	 * @param {any} acc
	 * Accumulator built up by the aggregate function so far.
	 *
	 * @param {any} next
	 * The value from the next "row" in the data.
	 *
	 * @return {any}
	 * The new accumulator value.
	 */

	/**
	 * @method calculateDone
	 * @abstract
	 * @memberof Aggregate
	 * @instance
	 *
	 * If this exists, it will be called to determine what the final result from the aggregate function
	 * should be.  It receives the final accumulator value built from the reduction over the data.
	 *
	 * @param {any} result
	 * The result of the aggregate function (the value returned from the final call to `calculateStep`).
	 *
	 * @return {any}
	 * A value to return instead of the last accumulator.
	 */

	// #calculate {{{2

	/**
	 * Calculate the result of the aggregate function applied over the specified data.  Calls the
	 * `calculateStep` method for each "row" in the data.  If the `calculateDone` method exists, the
	 * result is passed through it before being returned.
	 *
	 * @param {object[]} data
	 * The data to apply this aggregate function to.
	 *
	 * @return {any}
	 * The result of the aggregate function.  This will have the type indicated by the `type` property
	 * of the instance (and if undefined, will depend on the type of the fields used).
	 */

	Aggregate.prototype.calculate = function (data) {
		var self = this;
		var i, i0, len, acc;

		if (!self.checkOpts() || !self.checkData(data)) {
			return self.bottomValue;
		}

		self.numItems = 0;

		len = data.length;

		// Determine the initial value of the accumulator.  When there's an `init` property, prefer it.
		// Fall back to the `bottomValue` property.

		acc = typeof self.init === 'function' ? self.init()
			: self.init != null ? self.init
			: self.bottomValue;
		i0 = 0;

		// When there's no data, bail with the initial value.

		if (len === 0) {
			if (typeof self.calculateDone === 'function') {
				return self.calculateDone(acc);
			}
			return acc;
		}

		// If there's no initial value for the accumulator, use the first value from the data.

		if (acc == null) {
			acc = data[0].rowData;
			if (self.opts.fields && self.opts.fields.length > 0) {
				acc = self.getRealValue(acc[self.opts.fields[0]]);
			}
			i0 = 1;
		}

		// Loop through the rest of the data and call the `calculateStep` function.  This is basically
		// like calling fold/reduce.

		for (i = i0; i < len; i += 1) {
			try {
				acc = self.calculateStep(acc, data[i].rowData, data, i);
			}
			catch (e) {
				log.error('Aggregate ' + self.name + ': Error occurred at data index [' + i + ']: ' + e.toString());
				return self.bottomValue;
			}
		}

		return self.calculateDone != null ? self.calculateDone(acc) : acc;
	};

	// #checkOpts {{{2

	/**
	 * Check the options provided to the constructor.  This ensures that all configuration needed by the
	 * aggregate function was provided.
	 *
	 * @return {boolean}
	 * True if everything is OK, false if there is a problem with the options.
	 */

	Aggregate.prototype.checkOpts = function () {
		var self = this;

		if (self.fieldCount > 0) {
			if (self.opts.fields == null) {
				log.error('Aggregate ' + self.name + ': Missing `opts.fields`');
				return false;
			}
			else if (!underscore.isArray(self.opts.fields)) {
				log.error('Aggregate ' + self.name + ': `opts.fields` must be an array');
				return false;
			}
			else if (self.opts.fields.length !== self.fieldCount) {
				log.error('Aggregate ' + self.name + ': `opts.fields` must include ' + self.fieldCount + ' elements');
				return false;
			}

			if (self.opts.typeInfo == null) {
				log.error('Aggregate ' + self.name + ': Missing `opts.typeInfo`');
				return false;
			}
			else if (!underscore.isArray(self.opts.typeInfo)) {
				log.error('Aggregate ' + self.name + ': `opts.typeInfo` must be an array');
				return false;
			}
			else if (self.opts.typeInfo.length !== self.fieldCount) {
				log.error('Aggregate ' + self.name + ': `opts.typeInfo` must include ' + self.fieldCount + ' elements');
				return false;
			}
		}

		return true;
	};

	// #checkData {{{2

	/**
	 * Check the data provided to the `calculate` method.
	 *
	 * @return {boolean}
	 * True if everything is OK, false if there is a problem with the data.
	 */

	Aggregate.prototype.checkData = function (data) {
		var self = this;

		if (!underscore.isArray(data)) {
			log.error('Aggregate ' + self.name + ': `data` must be an array');
			return false;
		}

		return true;
	};

	// #getRealValue {{{2

	Aggregate.prototype.getRealValue = function (cell) {
		if (underscore.isString(cell)) {
			return cell;
		}
		else if (underscore.isNumber(cell)) {
			return cell;
		}
		else if (underscore.isObject(cell)) {
			if (cell.value !== undefined) {
				return cell.value;
			}
			else if (cell.orig !== undefined) {
				return cell.orig;
			}
			else {
				throw new Error('Unable to get real value of cell');
			}
		}
	};

	// #getFormattedValue {{{2

	Aggregate.prototype.getFormattedValue = function (cell) {
		var self = this;
		var val = self.getRealValue(cell);
		var colConfig = self.opts.colConfig ? self.opts.colConfig[0] : null;
		var typeInfo = self.opts.typeInfo ? self.opts.typeInfo[0] : null;

		return format(colConfig, typeInfo, cell);
	};

	// #getNumber {{{2

	Aggregate.prototype.getNumber = function (x) {
		if (window.numeral && window.numeral.isNumeral(x)) {
			// Check to see if this is a plain number, or a number wrapped by the Numeral library.  It
			// should always be the latter, but we check anyway, because there's no reason not to.

			return x.value();
		}
		else if (underscore.isString(x)) {
			// We can also handle when it's a number represented as a string.  We'll try to convert it
			// either to an integer or a float.

			if (isInt(x)) {
				return toInt(x);
			}
			else if (isFloat(x)) {
				return toFloat(x);
			}
			else {
				return 0;
			}
		}
		else if (underscore.isNumber(x)) {
			return x;
		}
		else {
			return 0;
		}
	};

	// #getFullName {{{2

	/**
	 * Returns a name for this aggregate function, suitable for display.
	 *
	 * #. If `opts.name` was provided to the constructor, that will be used.
	 * #. If fields are required and some were given, builds a name like "[name] of [field]".
	 * #. Uses the aggregate function name.
	 *
	 * @returns {string} A name suitable for display.
	 */

	Aggregate.prototype.getFullName = function () {
		var self = this;

		if (self.opts.name != null) {
			return self.opts.name;
		}
		else if (self.fieldCount > 0 && underscore.isArray(self.opts.fields) && self.opts.fields.length > 0) {
			return self.name + ' of ' + (
				underscore.map(self.opts.fields, function (field, fieldIdx) {
					var fcc = getPropDef({}, self.opts, 'colConfig', fieldIdx);
					return fcc.displayText || field;
				})
			).join(', ');
		}
		else {
			return self.name;
		}
	};

	// #getType {{{2

	/**
	 * Gets the type of the result of the aggregate function.
	 *
	 * An aggregate function can specify its own type $T_a$, e.g. count is always a number.
	 *
	 * * If fields were supplied, and they are all the same type $T_f$:
	 *    * If that type is in the aggregate function's list of allowed types, then $T_f$ is used.
	 *    * If the aggregate function didn't specify a fixed type, $T_f$ is used.
	 * * If $T_a$ was specified, then it is used.
	 * * The type "string" is used.
	 *
	 * @returns {string} The type of the result of the aggregate function.
	 */

	Aggregate.prototype.getType = function () {
		var self = this;

		// Set the type of the aggregate result.  Sometimes this is fixed (e.g. count is always a number).
		// If that's the case, it's given by the Aggregate instance itself.

		var t = self.type;

		if (getProp(self.opts, 'fields', 'length')) {
			var uniqueTypes = underscore.uniq(underscore.pluck(self.opts.typeInfo, 'type'));
			if (uniqueTypes.length === 1) {
				if (self.allowedTypes && self.allowedTypes.indexOf(uniqueTypes[0]) >= 0) {
					// Using `allowedTypes` lets field types override the fixed type.
					t = uniqueTypes[0];
				}
				else if (t == null) {
					// There is no fixed type, so we must use the field type.
					t = uniqueTypes[0];
				}
			}
		}

		// Default to a string type.

		if (t == null) {
			t = 'string';
		}

		return t;
	};

	// Count {{{1

	var CountAggregate = makeSubclass('CountAggregate', Aggregate, null, {
		name: 'Count',
		fieldCount: 0,
		type: 'number',
		inheritFormatting: false,
		bottomValue: 0
	});

	// #calculate {{{2

	CountAggregate.prototype.calculate = function (data) {
		var self = this;

		if (!self.checkOpts() || !self.checkData(data)) {
			return self.bottomValue;
		}

		return (data && data.length) || self.bottomValue;
	};

	// Count Distinct {{{1

	var CountDistinctAggregate = makeSubclass('CountDistinctAggregate', Aggregate, function () {
		var self = this;

		self.set = {};
		self.super.ctor.apply(self, arguments);
	}, {
		name: 'Count Distinct',
		fieldCount: 1,
		type: 'number',
		inheritFormatting: false,
		bottomValue: 0,
		init: function () {
			return {
				set: {},
				count: 0
			};
		}
	});

	// #calculateStep {{{2

	CountDistinctAggregate.prototype.calculateStep = function (acc, next) {
		var self = this;
		var cell = next[self.opts.fields[0]];
		var key = getNatRep(cell.value);

		if (acc.set[key] == null) {
			acc.set[key] = true;
			acc.count += 1;
		}
		return acc;
	};

	// #calculateDone {{{2

	CountDistinctAggregate.prototype.calculateDone = function (acc) {
		return acc.count;
	};

	// Values {{{1

	var ValuesAggregate = makeSubclass('ValuesAggregate', Aggregate, null, {
		name: 'Values',
		fieldCount: 1,
		inheritFormatting: false,
		type: 'string',
		init: function () {
			return {
				resultIsElement: false,
				values: []
			};
		},
		options: {
			'separator': {
				'displayText': 'Separator'
			}
		}
	});

	// #calculateStep {{{2

	ValuesAggregate.prototype.calculateStep = function (acc, next) {
		var self = this;
		var formatted = self.getFormattedValue(next[self.opts.fields[0]]);

		if (isElement(formatted)) {
			acc.resultIsElement = true;
		}

		acc.values.push(formatted);
		return acc;
	};

	// #calculateDone {{{2

	ValuesAggregate.prototype.calculateDone = function (acc) {
		var self = this;

		if (!acc.resultIsElement) {
			return acc.values.join(self.opts.separator || ', ');
		}
		else {
			var wrapper = jQuery('<div>');
			underscore.each(acc.values, function (elt, i) {
				if (i > 0) {
					wrapper.append(self.opts.separator || ', ');
				}
				// FIXME: Subsequent calls to #calculate() from a different instance of ValuesAggregate can
				// change the elements of acc and therefore wrapper.  I cannot figure out why, so cloning the
				// element will have to do for now.
				wrapper.append(isElement(elt) ? elt.clone() : elt);
			});
			return wrapper;
		}
	};

	// Values w/ Counts {{{1

	var ValuesWithCountsAggregate = makeSubclass('ValuesWithCountsAggregate', Aggregate, null, {
		name: 'Values w/ Counts',
		fieldCount: 1,
		inheritFormatting: false,
		type: 'string',
		init: function () {
			return {
				map: new OrdMap(),
				resultIsElement: false
			}
		},
		options: {
			'separator': {
				'displayText': 'Separator'
			}
		}
	});

	// #calculateStep {{{2

	ValuesWithCountsAggregate.prototype.calculateStep = function (acc, next) {
		var self = this;
		var cell = next[self.opts.fields[0]];
		var key = getNatRep(cell.value);
		var formatted = self.getFormattedValue(cell);

		if (acc.map.isSet(key)) {
			var info = acc.map.get(key);
			info.count += 1;
		}
		else {
			acc.map.set(key, {
				formatted: formatted,
				count: 1
			});
			if (isElement(formatted)) {
				acc.resultIsElement = true;
			}
		}

		return acc;
	};

	// #calculateDone {{{2

	ValuesWithCountsAggregate.prototype.calculateDone = function (acc) {
		var self = this;

		if (acc.resultIsElement) {
			var div = jQuery('<div>');
			acc.map.each(function (v, k, i) {
				if (i > 0) {
					div.append(self.opts.separator || ', ');
				}
				div.append(isElement(v.formatted) ? v.formatted.clone() : v.formatted);
				div.append(' (' + v.count + ')');
			});
			return div;
		}
		else {
			var a = [];

			acc.map.each(function (v, k) {
				a.push(k + ' (' + v.count + ')');
			});

			return a.join(self.opts.separator || ', ');
		}
	};

	// Distinct Values {{{1

	var DistinctValuesAggregate = makeSubclass('DistinctValuesAggregate', ValuesWithCountsAggregate, null, {
		name: 'Distinct Values'
	});

	// #calculateDone {{{2

	DistinctValuesAggregate.prototype.calculateDone = function (acc) {
		var self = this;

		if (acc.resultIsElement) {
			var div = jQuery('<div>');
			acc.map.each(function (v, k, i) {
				if (i > 0) {
					div.append(self.opts.separator || ', ');
				}
				div.append(isElement(v.formatted) ? v.formatted.clone() : v.formatted);
			});
			return div;
		}
		else {
			var a = [];

			acc.map.each(function (v, k) {
				a.push(k);
			});

			return a.join(self.opts.separator || ', ');
		}
	};

	// Sum {{{1

	var SumAggregate = makeSubclass('SumAggregate', Aggregate, null, {
		name: 'Sum',
		fieldCount: 1,
		type: 'number',
		allowedTypes: ['number', 'currency'],
		inheritFormatting: true,
		bottomValue: 0,
		init: function () {
			switch (this.opts.typeInfo[0].internalType) {
			case 'primitive':
				return 0;
			case 'numeral':
				return numeral(0);
			case 'bignumber':
				return bignumber(0);
			}
		}
	});

	// #calculateStep {{{2

	SumAggregate.prototype.calculateStep = function (acc, next) {
		var self = this;
		var val = self.getRealValue(next[self.opts.fields[0]]);

		if (val == null) {
			return acc;
		}

		switch (self.opts.typeInfo[0].internalType) {
		case 'primitive':
			if (Number.isNaN(val)) {
				return acc;
			}
			else {
				self.numItems += 1;
				return acc + val;
			}
		case 'numeral':
			if (Number.isNaN(val) || val.value() === null) {
				return acc;
			}
			else {
				self.numItems += 1;
				return acc.add(val.value());
			}
		case 'bignumber':
			if (val.isNaN()) {
				return acc;
			}
			else {
				self.numItems += 1;
				return acc.plus(val);
			}
		}
	};

	// Average {{{1

	var AverageAggregate = makeSubclass('AverageAggregate', Aggregate, function (opts) {
		var self = this;

		self.sumAgg = new SumAggregate(opts);
		self.super.ctor.apply(self, arguments);
	}, {
		name: 'Average',
		fieldCount: 1,
		type: 'number',
		allowedTypes: ['number', 'currency'],
		inheritFormatting: true,
		bottomValue: 0
	});

	// #calculate {{{2

	AverageAggregate.prototype.calculate = function (data) {
		var self = this;

		if (!self.checkOpts() || !self.checkData(data)) {
			return self.bottomValue;
		}

		// First, compute the SUM using a sum aggregate.  It will keep track of the number of contributing
		// items internally which we can use for division later.

		var num = self.sumAgg.calculate(data);
		var denom = self.sumAgg.numItems;

		// If the SUM ends up being null, NaN, or invalid in any other way, just return the bottom value.
		// Otherwise, perform the average using whatever division method is appropriate for the internal
		// type of the field.

		if (num == null || denom === 0) {
			return self.bottomVal;
		}

		switch (self.opts.typeInfo[0].internalType) {
		case 'primitive':
			if (Number.isNaN(num)) {
				return self.bottomVal;
			}
			else {
				return num / denom;
			}
		case 'numeral':
			if (Number.isNaN(num) || num.value() === null) {
				return self.bottomVal;
			}
			else {
				return num.divide(denom);
			}
		case 'bignumber':
			if (num.isNaN()) {
				return self.bottomVal;
			}
			else {
				return num.div(denom);
			}
		}
	};

	// Min {{{1

	var MinAggregate = makeSubclass('MinAggregate', Aggregate, null, {
		name: 'Min',
		fieldCount: 1,
		inheritFormatting: true
	});

	// #checkOpts {{{2

	MinAggregate.prototype.checkOpts = function () {
		var self = this;

		if (self.opts.typeInfo == null) {
			log.error('Aggregate ' + self.name + ': Missing `opts.typeInfo`');
			return false;
		}

		if (self.opts.compare == null) {
			self.opts.compare = getComparisonFn.byType(self.opts.typeInfo[0].type);
		}

		if (typeof self.opts.compare !== 'function') {
			log.error('Aggregate ' + self.name + ': Missing `opts.compare`');
			return false;
		}

		return self.super.checkOpts();
	};

	// #calculateStep {{{2

	MinAggregate.prototype.calculateStep = function (acc, next) {
		var self = this;

		var val = self.getRealValue(next[self.opts.fields[0]]);
		return self.opts.compare(acc, val) < 0 ? acc : val;
	};

	// Max {{{1

	var MaxAggregate = makeSubclass('MaxAggregate', Aggregate, null, {
		name: 'Max',
		fieldCount: 1,
		inheritFormatting: true
	});

	// #checkOpts {{{2

	MaxAggregate.prototype.checkOpts = function () {
		var self = this;

		if (self.opts.typeInfo == null) {
			log.error('Aggregate ' + self.name + ': Missing `opts.typeInfo`');
			return false;
		}

		if (self.opts.compare == null) {
			self.opts.compare = getComparisonFn.byType(self.opts.typeInfo[0].type);
		}

		if (typeof self.opts.compare !== 'function') {
			log.error('Aggregate ' + self.name + ': Missing `opts.compare`');
			return false;
		}

		return self.super.checkOpts();
	};

	// #calculateStep {{{2

	MaxAggregate.prototype.calculateStep = function (acc, next) {
		var self = this;

		var val = self.getRealValue(next[self.opts.fields[0]]);
		return self.opts.compare(acc, val) < 0 ? val : acc;
	};

	// First {{{1

	var FirstAggregate = makeSubclass('FirstAggregate', Aggregate, null, {
		name: 'First',
		fieldCount: 1,
		inheritFormatting: true
	});

	// #checkData {{{2

	FirstAggregate.prototype.checkData = function (data) {
		var self = this;

		if (data.length === 0) {
			//log.error('Aggregate ' + self.name + ': `data` has no elements');
			return false;
		}

		return self.super.checkData(data);
	};

	// #calculate {{{2

	FirstAggregate.prototype.calculate = function (data) {
		var self = this;

		if (!self.checkOpts() || !self.checkData(data)) {
			return self.bottomValue;
		}

		return self.getRealValue(data[0].rowData[self.opts.fields[0]]);
	};

	// Last {{{1

	var LastAggregate = makeSubclass('LastAggregate', Aggregate, null, {
		name: 'Last',
		fieldCount: 1,
		inheritFormatting: true
	});

	// #checkData {{{2

	LastAggregate.prototype.checkData = function (data) {
		var self = this;

		if (data.length === 0) {
			//log.error('Aggregate ' + self.name + ': `data` has no elements');
			return false;
		}

		return self.super.checkData(data);
	};

	// #calculate {{{2

	LastAggregate.prototype.calculate = function (data) {
		var self = this;

		if (!self.checkOpts() || !self.checkData(data)) {
			return self.bottomValue;
		}

		return self.getRealValue(data[data.length - 1].rowData[self.opts.fields[0]]);
	};

	// Nth {{{1

	var NthAggregate = makeSubclass('NthAggregate', Aggregate, null, {
		name: 'Nth',
		enabled: false,
		fieldCount: 1,
		inheritFormatting: true
	});

	// #checkOpts {{{2

	NthAggregate.prototype.checkOpts = function () {
		var self = this;

		if (self.opts.index == null) {
			log.error('Aggregate ' + self.name + ': Missing `opts.index`');
			return false;
		}

		if (!underscore.isNumber(self.opts.index)) {
			log.error('Aggregate ' + self.name + ': `opts.index` must be a number');
			return false;
		}

		return self.super.checkOpts();
	};

	// #checkData {{{2

	NthAggregate.prototype.checkData = function (data) {
		var self = this;

		if (data.length === 0) {
			//log.error('Aggregate ' + self.name + ': `data` has no elements');
			return false;
		}

		if (data.length <= self.opts.index) {
			log.error('Aggregate ' + self.name + ': `data` has insufficient number of elements');
			return self.bottomValue;
		}

		return self.super.checkData(data);
	};

	// #calculate {{{2

	NthAggregate.prototype.calculate = function (data) {
		var self = this;

		if (!self.checkOpts() || !self.checkData(data)) {
			return self.bottomValue;
		}

		return data[data.length - 1];
	};

	// Sum / Sum {{{1

	var SumOverSumAggregate = makeSubclass('SumOverSumAggregate', Aggregate, null, {
		name: 'Sum/Sum',
		fieldCount: 2,
		fieldInfo: [{
			name: 'Num'
		}, {
			name: 'Denom'
		}],
		type: 'string',
		inheritFormatting: false,
		bottomValue: 0,
		init: function () {
			return { a: 0, b: 0 };
		},
		options: {
			'format': {}
		}
	});

	// #calculateStep {{{2

	SumOverSumAggregate.prototype.calculateStep = function (acc, next) {
		var self = this;

		acc.a += self.getNumber(next[self.opts.fields[0]].value);
		acc.b += self.getNumber(next[self.opts.fields[1]].value);

		return acc;
	};

	// #calculateDone {{{2

	SumOverSumAggregate.prototype.calculateDone = function (obj) {
		var self = this;
		var result = (obj.a + 0.0) / (obj.b + 0.0);

		if (window.sprintf) {
			if (self.opts.format) {
				return sprintf$1.sprintf(self.opts.format, result);
			}
			if (result >= 100) {
				return sprintf$1.sprintf('%d', result);
			}
			else if (result >= 10) {
				return sprintf$1.sprintf('%3.1f', result);
			}
			else if (result >= 1) {
				return sprintf$1.sprintf('%3.2f', result);
			}
			else {
				return sprintf$1.sprintf('%3.3f', result);
			}
		}
		return result;
	};

	// #getFullName {{{2

	SumOverSumAggregate.prototype.getFullName = function () {
		var self = this;

		return 'Sum(' + getPropDef(self.opts.fields[0], self.opts, 'colConfig', 0, 'displayText') + ') / Sum(' + getPropDef(self.opts.fields[1], self.opts, 'colConfig', 1, 'displayText') + ')';
	};

	// Count / Count {{{1

	var CountOverCountAggregate = makeSubclass('CountOverCountAggregate', Aggregate, null, {
		name: 'Count/Count',
		fieldCount: 2,
		fieldInfo: [{
			name: 'Num'
		}, {
			name: 'Denom'
		}],
		type: 'number',
		inheritFormatting: false,
		bottomValue: 0
	});

	// Aggregate Registry {{{1

	var AGGREGATE_REGISTRY = new OrdMap();
	AGGREGATE_REGISTRY.set('count', CountAggregate);
	AGGREGATE_REGISTRY.set('countDistinct', CountDistinctAggregate);
	AGGREGATE_REGISTRY.set('values', ValuesAggregate);
	AGGREGATE_REGISTRY.set('valuesWithCounts', ValuesWithCountsAggregate);
	AGGREGATE_REGISTRY.set('distinctValues', DistinctValuesAggregate);
	AGGREGATE_REGISTRY.set('sum', SumAggregate);
	AGGREGATE_REGISTRY.set('average', AverageAggregate);
	AGGREGATE_REGISTRY.set('min', MinAggregate);
	AGGREGATE_REGISTRY.set('max', MaxAggregate);
	AGGREGATE_REGISTRY.set('first', FirstAggregate);
	AGGREGATE_REGISTRY.set('last', LastAggregate);
	AGGREGATE_REGISTRY.set('nth', NthAggregate);
	AGGREGATE_REGISTRY.set('sumOverSum', SumOverSumAggregate);

	// AggregateInfo {{{1

	/**
	 * Create a new AggregateInfo instance.
	 *
	 * @param {string} aggType
	 * What kind of aggregate to construct.
	 *
	 * @param {View~AggregateSpec} spec
	 * The specification of the aggregate function.
	 *
	 * @param {number} [aggNum]
	 * What number this aggregate function is.  Optional, because this information is not useful in all
	 * contexts (e.g. footer aggregates, because there can only ever be one for each field).
	 *
	 * @param {OrdMap} [colConfig]
	 * Column configuration for all fields; requirement depends upon the aggregate function.
	 *
	 * @param {OrdMap} [typeInfo]
	 * Type information for all fields; requirement depends upon the aggregate function, but is strongly
	 * recommended (only some basic aggregate functions like "count" don't need it).
	 *
	 * @param {function} [decode]
	 * A function which is used to decode all the data in the fields over which the aggregate function
	 * is applied.
	 *
	 * @class
	 *
	 * Represents information about an aggregate function.
	 *
	 * @property {number} aggNum
	 * The aggregate number; used to correlate with the results.
	 *
	 * @property {string} fun
	 * Internal name of the aggregate function, maps to a key in `AGGREGATE_REGISTRY`.
	 *
	 * @property {string} name
	 * Display text for the aggregate function.
	 *
	 * @property {boolean} isHidden
	 * If true, then the aggregate function should not be shown in the grid.
	 *
	 * @property {Array.<string>} fields
	 * An array of the fields to which the aggregate function applies.  For functions that don't require
	 * any fields, this will be an empty array.
	 *
	 * @property {Array.<Grid~ColConfig>} colConfig
	 * An array of column configuration objects which correspond to `fields`.
	 *
	 * @property {Array.<Source~TypeInfo>} typeInfo
	 * An array of type information objects which correspond to `fields`.
	 *
	 * @property {Aggregate} instance
	 * The actual aggregate function instance which was used to compute the results.
	 *
	 * @property {boolean} debug
	 * If true, then debugging messages are output for this aggregate.
	 */

	var AggregateInfo = makeSubclass('AggregateInfo', Object, function (aggType, spec, aggNum, colConfig, typeInfo, decode) {
		var self = this;

		self.aggNum = aggNum;
		self.aggType = aggType;
		self.fun = spec.fun;
		self.name = spec.name;
		self.isHidden = spec.isHidden;
		self.fields = [];
		self.colConfig = [];
		self.typeInfo = [];
		self.debug = spec.debug;

		if (typeof aggType !== 'string') {
			throw new Error('Call Error: `aggType` must be a string');
		}

		if (!underscore.isObject(spec)) {
			throw new Error('Call Error: `spec` must be an object');
		}
		if (typeof spec.fun !== 'string') {
			throw new Error('Call Error: `spec.fun` must be a string');
		}
		if (spec.fields != null && !underscore.isArray(spec.fields)) {
			throw new Error('Call Error: `spec.fields` must be null or an array')
		}

		if (aggNum != null && typeof aggNum !== 'number') {
			throw new Error('Call Error: `aggNum` must be null or a number');
		}

		if (colConfig != null && !(colConfig instanceof OrdMap)) {
			throw new Error('Call Error: `colConfig` must be null or an OrdMap instance');
		}

		if (typeInfo != null && !(typeInfo instanceof OrdMap)) {
			throw new Error('Call Error: `typeInfo` must be null or an OrdMap instance');
		}

		if (decode != null && typeof decode !== 'function') {
			throw new Error('Call Error: `decode` must be null or a function');
		}

		var aggClass = AGGREGATE_REGISTRY.get(spec.fun);

		if (aggClass == null) {
			throw new Error('No such aggregate function: "' + spec.fun + '"' +
				(spec.name ? ' (output name = "' + spec.name + '")' : ''));
		}

		var ctorOpts = {
			name: spec.name
		};

		if (spec.fields) {
			self.fields = spec.fields;
		}

		// Check to see if the number of fields supplied matches the number requested by the aggregate
		// function class.

		if (self.fields.length !== aggClass.prototype.fieldCount) {
			log.warn('Creating ' + aggType + '[' + aggNum + '] aggregate function "' + spec.fun + '" to be applied over fields ' + JSON.stringify(self.fields) + ', which doesn\'t match the number of fields supported by the aggregate function (' + aggClass.prototype.fieldCount + ')... expect trouble.');
		}

		if (self.fields.length > 0) {
			// Set the colConfig array for the supplied fields.

			if (colConfig != null) {
				self.colConfig = underscore.map(self.fields, function (f) {
					return colConfig.get(f);
				});
			}
			else {
				log.warn('Creating ' + aggType + '[' + aggNum + '] aggregate function "' + spec.fun + '" to be applied over fields ' + JSON.stringify(self.fields) + ', but no column config was provided.');
			}

			// Set the typeInfo array for the supplied fields.

			if (typeInfo != null) {
				self.typeInfo = underscore.map(self.fields, function (f) {
					return typeInfo.get(f);
				});
			}
			else {
				log.warn('Creating ' + aggType + '[' + aggNum + '] aggregate function "' + spec.fun + '" to be applied over fields ' + JSON.stringify(self.fields) + ', but no type info was provided.');
			}

			// Perform type decoding if needed, before we calculate the aggregate results.  This is
			// needed when doing aggregates like "values" and "distinct values" to make sure they're
			// formatted right by the aggregate function itself.

			underscore.each(self.typeInfo, function (fti, i) {
				if (fti == null) {
					throw new Error('Aggregate function applied to unknown field: "' + self.fields[i] + '"');
				}

				if (fti.needsDecoding) {
					if (decode != null) {
						decode('AGGREGATE', fti);
					}
					else {
						log.warn('Unable to decode field "' + fti.field + '" on demand for aggregate function, no decoding function provided.');
					}
				}
			});

			ctorOpts.fields = self.fields;
			ctorOpts.isHidden = self.isHidden;
			ctorOpts.colConfig = self.colConfig;
			ctorOpts.typeInfo = self.typeInfo;
		}

		underscore.extend(ctorOpts, spec.opts);

		self.instance = new aggClass(ctorOpts);
	});

	/**
	 * @file
	 * Implements parameters and filters that can be sent to the origin by a {@link Source}.
	 *
	 * ## Classes
	 *
	 * - {@link Filter}
	 * - {@link FilterSet}
	 * - {@link FilterInput}
	 * - {@link ParamInput}
	 */

	// JSDoc {{{1

	/**
	 * @typedef {object} Filter~Config
	 *
	 * @property {string} inputName Name of an input element from a form.
	 *
	 * @property {string} type What kind of widget to get input from.  If this is undefined, the default
	 * value will be used for storing (from the page), and loading (into the page) will do nothing.
	 *
	 * @property {boolean} required If true, an error will be issued if this filter is used on a data
	 * source, when the user has not entered anything into the input element.
	 *
	 * @property {string} method How the input should be sent to the server.  Allowed values: [cgi,
	 * json_where, json_having].
	 *
	 * @property {string} paramName When method = "cgi", the name of the CGI parameter to send.
	 *
	 * @property {any} value The value that will be sent to the server.
	 *
	 * @property {any} internalValue An internal representation of the value sent (e.g. an object
	 * storing extra information).
	 *
	 * @property {any} defaultValue A default value to send when the user has not specified anything.
	 *
	 * @property {object} json When method = "json_where" or method = "json_having", specifies details
	 * about that method.
	 *
	 * @property {string} json.name Name of the constraint set.
	 *
	 * @property {string} json.column Name of the column to add a constraint for.
	 *
	 * @property {string} json.operator Operator to use for the constraint.  Allowed values: [$eq, $ne,
	 * $in, $nin, $gt, $gte, $lt, $lte, $like].
	 *
	 * @property {string} json.operand When absent, the user's input is sent as the value.  When
	 * present, this is sent instead, and any empty array is replaced with the user's input.
	 */

	// FilterError {{{1

	/**
	 * @class
	 */

	var FilterError = makeSubclass('FilterError', Error, function (msg) {
		this.message = msg;
	});

	// Filter {{{1

	// Constructor {{{2

	/**
	 * Create a new Filter.
	 *
	 * @param {Filter~Config} config
	 * Specify the properties of this Filter.
	 *
	 * @class
	 *
	 * Represents a value that can be sent to an origin by a {@link Source}.  Usually (but not always)
	 * associated with some input element in the page where the user provides the value.
	 *
	 * @property {string} inputName Name of an input element from a form.
	 *
	 * @property {string} type What kind of widget to get input from.  If this is undefined, the default
	 * value will be used for storing (from the page), and loading (into the page) will do nothing.
	 *
	 * @property {boolean} required If true, an error will be issued if this filter is used on a data
	 * source, when the user has not entered anything into the input element.
	 *
	 * @property {string} method How the input should be sent to the server.  Allowed values: [cgi,
	 * json_where, json_having].
	 *
	 * @property {string} paramName When method = "cgi", the name of the CGI parameter to send.
	 *
	 * @property {object} json When method = "json_where" or method = "json_having", specifies details
	 * about that method.
	 *
	 * @property {string} json.name Name of the constraint set.
	 *
	 * @property {string} json.column Name of the column to add a constraint for.
	 *
	 * @property {string} json.operator Operator to use for the constraint.  Allowed values: [$eq, $ne,
	 * $in, $nin, $gt, $gte, $lt, $lte, $like].
	 *
	 * @property {string} json.operand When absent, the user's input is sent as the value.  When
	 * present, this is sent instead, and any empty array is replaced with the user's input.
	 *
	 * @property {any} value The value that will be sent to the server.
	 *
	 * @property {any} internalValue An internal representation of the value sent (e.g. an object
	 * storing extra information).
	 *
	 * @property {any} defaultValue A default value to send when the user has not specified anything.
	 */

	var Filter = function (config) {
		var self = this
			;

		if (config.inputName && !config.paramName) {
			config.paramName = config.inputName;
		}
		else if (config.paramName && !config.inputName) {
			config.inputName = config.paramName;
		}

		underscore.defaults(config, {
			required: false,
			defaultValue: null
		});

		underscore.extend(self, config);

		// Make sure that if we're sending multiple values using JSON, that the operator we're using is
		// one that accepts multiple values (either "$in" or "$nin").  If we don't do this check, the
		// array of values will be interpreted as a function expression.

		if (self.type === 'multi-autocomplete'
			&& (self.method === 'json_where' || self.method === 'json_having')
			&& (self.json.operator !== '$in' && self.json.operator !== '$nin')) {
				throw new FilterError('Filter "' + self.paramName + '" is a multi-autocomplete, so the operator must be either "$in" or "$nin" (right now it\'s "' + self.json.operator + '").');
			}
	};

	// #store {{{2

	/**
	 * Store a value in this filter from the form.
	 */

	Filter.prototype.store = function (id) {
		var form = id ? document.getElementById(id) : null;
		var findInput = form ? function (s) {
			return jQuery(form).find(s);
		} : jQuery;
		var self = this;

		if (self.type === undefined) {
			self.value = typeof self.defaultValue === 'function'
				? self.defaultValue()
				: self.defaultValue;
		}
		else {
			switch (self.type) {
			case 'hidden':
			case 'text':
				self.value = findInput('input[name="' + self.inputName + '"]').val();
				break;
			case 'textarea':
				self.value = findInput('textarea[name="' + self.inputName + '"]').val();
				break;
			case 'date':
				self.internalValue = {};
				var x = underscore.map(['YEAR', 'MONTH', 'DAY'], function (elt) {
					var value = findInput('[name="' + self.inputName + elt + '"]')[0].value;
					self.internalValue[elt] = value;
					return value;
				}).join('-');
				self.value = (x === '--' ? '' : x);
				break;
			case 'checkbox':
				self.value = underscore.map(findInput('input[name="' + self.inputName + '"]:checkbox:checked'), function (x) {
					return findInput(x).val();
				});
				break;
			case 'toggle-checkbox':
				self.value = findInput('input[name="' + self.inputName + '"]').prop('checked') ? 'on' : 'off';
				break;
			case 'radio':
				self.value = findInput('input[name="' + self.inputName + '"]:radio:checked').val();
				break;
			case 'select':
				self.value = findInput('select[name="' + self.inputName + '"]').val();
				break;
			case 'autocomplete':
				throw new Error();
			case 'multi-autocomplete':
				self.value = [];
				self.internalValue = [];
				underscore.each(findInput('input[name="' + self.inputName + '"]'), function (elt, i) {
					self.value[i] = jQuery(elt).val();
					self.internalValue[i] = jQuery(elt).parent().text();
				});
				break;
			case 'form':
				var obj = {};
				findInput('input').each(function (i, elt) {
					var j = jQuery(elt)
						, name = j.attr('name')
						, type = j.attr('type');
					if (name == null) {
						return;
					}
					switch (type) {
					case 'hidden':
					case 'text':
						obj[name] = j.val();
						break;
					case 'checkbox':
					case 'radio':
						if (j.prop('checked')) {
							if (obj[j.attr('name')] == null) {
								obj[name] = [];
							}
							obj[name].push(j.val());
						}
						break;
					}
				});
				findInput('select,textarea').each(function (i, elt) {
					var j = jQuery(elt)
						, name = j.attr('name');
					if (name == null) {
						return;
					}
					obj[name] = j.val();
				});
				self.value = obj;
				break;
			default:
				throw 'Invalid parameter specification: unknown input type "' + self.type + '"';
			}
		}

		debug.info('FILTER // STORE', 'Input Type = %s, Input Name = %s, Param Name = %s, Value = %s', self.type, self.inputName, self.paramName, self.value);

		// if (self.required && (self.value === '' || self.value === [])) {
		//	throw new MissingRequiredParameterError(self.paramName);
		// }
	};

	// #load {{{2

	/**
	 * Loads a filter from memory into a form in the page. Any existing content in the form is cleared
	 * first. This is a lot more complicated than it sounds, because every type has to be loaded
	 * differently.
	 *
	 * @param {string} [id]
	 * The ID of the form to populate.  If missing, look for inputs on the whole page.
	 *
	 * @param {object} [opts] Additional configuration options:
	 *
	 * @param {boolean} [opts.animate=false]
	 * If true, use an animation to pulse the background color of the input that's being changed from
	 * its currently value. When this is true, the values `bgAccentIn` and `bgAccountOut` must also be
	 * provided.
	 *
	 * @param {string} [opts.bgAccentIn]
	 * Hex string for the color to use for fading into the animation (e.g. if you want something to
	 * highlight in yellow briefly and then go back to white, use a yellow color here).
	 *
	 * @param {string} [opts.bgAccentOut]
	 * Hex string for the color to use for fading out of the animation (in the example above, you'd use
	 * white). Also supports the special value "transparent" to remove the highlight.
	 */

	Filter.prototype.load = function (id, opts) {
		var self = this;

		if (self.type === undefined) {
			return;
		}

		opts = opts || {};
		var form = id ? document.getElementById(id) : null;

		var findInput = form ? function (s) {
			return jQuery(form).find(s);
		} : jQuery;

		underscore.defaults(opts, {
			fade: false
		});

		if (opts.fade && !(underscore.isString(opts.bgAccentIn) && underscore.isString(opts.bgAccentOut))) {
			throw 'Cannot load filter with fading without specifying bgAccent[In|Out] properties';
		}

		var fade = {
			backgroundColor: jQuery.Color(opts.bgAccentIn)
		};

		function unfade() {
			jQuery(this).animate({
				backgroundColor: jQuery.Color(opts.bgAccentOut)
			}, 500);
		}

		switch (self.type) {
		case 'hidden':
			(function () {
				var nodes = findInput('input[name="' + self.inputName + '"]');
				nodes.val(self.value ? self.value : (self.defaultValue ? self.defaultValue : ''));
			})();
			break;
		case 'text':
			(function () {
				var nodes = findInput('input[name="' + self.inputName + '"]');
				if (opts.fade && nodes.val() !== self.value) {
					nodes.animate(fade, 500, unfade);
				}
				nodes.val(self.value ? self.value : (self.defaultValue ? self.defaultValue : ''));
			})();
			break;
		case 'date':
			underscore.each(['YEAR', 'MONTH', 'DAY'], function (elt) {
				var nodes = findInput('input[name="' + self.inputName + elt + '"]');
				nodes.val(underscore.isObject(self.internalValue) && underscore.isString(self.internalValue[elt]) && self.internalValue[elt] !== '' ? self.internalValue[elt] : (self.defaultValue ? self.defaultValue : ''));
				if (opts.fade) {
					nodes.animate(fade, 500, unfade);
				}
			});
			break;
		case 'checkbox':
			(function () {
				var curNodes = findInput('input[name="' + self.inputName + '"]:checkbox:checked');
				var curValues = {};
				underscore.each(curNodes, function (node) {
					curValues[jQuery(node).val()] = node;
				});
				curNodes.prop('checked', false);
				underscore.each(self.value, function (x) {
					var nodes = findInput('input[name="' + self.inputName + '"]:checkbox[value="' + x + '"]');
					nodes.prop('checked', true);
					delete curValues[x];
					if (opts.fade) {
						nodes.parent('label').animate(fade, 500, unfade);
					}
				});
				if (opts.fade) {
					underscore.each(curValues, function (node) {
						var label = jQuery(node).parent('label');
						// _.each(['Top', 'Bottom', 'Left', 'Right'], function (side) {
						//	 label.css('border' + side + 'Width', '2px');
						//	 label.css('border' + side + 'Style', 'dashed');
						//	 label.css('border' + side + 'Color', '#000000');
						// });
						label.animate(fade, 500, unfade);
					});
				}
			})();
			break;
		case 'toggle-checkbox':
			(function () {
				var node = findInput('input[name="' + self.inputName + '"]');
				var curValue = node.prop('checked') ? 'on' : 'off';
				node.prop('checked', self.value === 'on');
				if (opts.fade && curValue !== self.value) {
					node.parent('label').animate(fade, 500, unfade);
				}
			})();
			break;
		case 'radio':
			(function () {
				var nodes = findInput('input[name="' + self.inputName + '"]:radio[value="' + self.value + '"]');
				nodes.prop('checked', true);
				if (opts.fade) {
					nodes.parent('label').animate(fade, 500, unfade);
				}
			})();
			break;
		case 'select':
			(function () {
				var nodes = findInput('select[name="' + self.inputName + '"]');
				var oldVal = nodes.val();
				nodes.val(self.value);
				if (opts.fade && oldVal !== self.value) {
					nodes.parent().animate(fade, 500, unfade);
				}
			})();
			break;
		case 'autocomplete':
			return new Error();
		case 'multi-autocomplete':
			(function () {
				if (!underscore.isObject(window[self.inputName + '_ac'])) {
					throw 'Autocomplete object "' + self.inputName + '" does not exist';
				}
				// window[self.inputName + '_ac'].multiClear(); // Doesn't work!
				window[self.inputName + '_ac'].storedvalues = [];
				jQuery(document.getElementById(self.inputName + '_ac_div')).children().remove();
				underscore.each(self.value, function (v, i) {
					window[self.inputName + '_ac'].multiAddValue(v, self.internalValue[i]);
				});
				if (opts.fade) {
					jQuery(document.getElementById(self.inputName + '_ac_div')).animate(fade, 500, unfade);
				}
			})();
			break;
		default:
			throw 'Invalid parameter specification: unknown input type "' + self.type + '"';
		}
	};

	// #buildInput {{{2

	/**
	 * Constructs a hidden input within the specified form which can be used to submit the filter's
	 * value to the server.
	 *
	 * @param {Element|jQuery} form
	 * DOM node (optionally wrapped by jQuery) of the form element in which to place the input.
	 */

	Filter.prototype.buildInput = function (form) {
		var self = this;
		var val = underscore.isArray(this.value) ? this.value : [this.value];
		underscore.each(val, function (v) {
			jQuery('<input>').attr({
				type: 'hidden',
				name: self.paramName,
				value: v
			}).appendTo(form);
		});
	};

	// #addJsonParam {{{2

	/**
	 * Add the value of this Filter to the specified JSON object.
	 *
	 * @param {object} obj
	 * The object to which this Filter will add itself.
	 */

	Filter.prototype.addJsonParam = function (obj) {
		var self = this
			, operand;

		if (self.json == null) {
			throw new FilterError('Missing configuration object for JSON grid parameter.');
		}

		if (self.json.name == null || self.json.name === '') {
			throw new FilterError('Missing constraint set name for JSON grid parameter.');
		}

		if (self.json.column == null || self.json.column === '') {
			throw new FilterError('Missing column name for JSON grid parameter.');
		}

		if (self.json.operator == null || self.json.operator === '') {
			self.json.operator = '$eq';
		}

		var name = self.json.name;
		var column = self.json.column;
		var operator = self.json.operator;

		// When there's no value, remove it from the JSON object that we might have already constructed
		// (e.g. if loading the grid a second time) and make sure we don't end up with any empty stuff.

		if (self.value === null || (self.type === 'date' && self.value === '') || (self.type === 'multi-autocomplete' && self.value.length === 0)) {
			if (getProp(obj, name, column, operator)) {
				delete obj[name][column][operator];
				if (isEmpty(obj[name][column])) {
					delete obj[name][column];
				}
				if (isEmpty(obj[name])) {
					delete obj[name];
				}
			}
			return;
		}

		// Handle when the operand is an array, in which case we replace any instance of the empty array
		// with the value of the parameter.  A good example of this is how we modify a date to make it a
		// time for the end of the day: ['concat', [], ' 23:59:59'].

		if (underscore.isArray(self.json.operand)) {
			operand = arrayCopy(self.json.operand);
			underscore.each(operand, function (elt, i) {
				if (underscore.isArray(elt) && elt.length === 0) {
					operand[i] = self.value;
				}
			});
		}
		else {
			operand = self.json.operand == null ? self.value : self.json.operand;
		}

		setProp(operand, obj, name, column, operator);
	};

	// #toParams {{{2

	/**
	 * Convert this filter into a parameter that can be sent to a system report.  If this filter is
	 * going to be used for a JSON WHERE or JSON HAVING clause, that is handled as well.
	 *
	 * When this filter is being sent using CGI, the parameters object records the parameter name and
	 * the value of the filter.  If this filter is being sent as a JSON clause, the appropriate
	 * property (either [json_where] or [json_having]) is updated.  In this latter case, somebody will
	 * have to encode the object as a string before sending it to the server.
	 *
	 * @param {object} params The object containing the parameters that will be sent to the server.
	 */
	Filter.prototype.toParams = function (params) {
		var self = this;

		self.store();

		switch (self.method) {
		case 'json_where':
			params.report_json_where = params.report_json_where || {};
			self.addJsonParam(params.report_json_where);
			break;
		case 'json_having':
			params.report_json_having = params.report_json_having || {};
			self.addJsonParam(params.report_json_having);
			break;
		case 'cgi':
			if (self.type === 'form') {
				underscore.each(self.value, function (v, k) {
					params[k] = v;
				});
			}
			else {
				params[self.paramName] = self.value;
			}
			break;
		default:
			throw 'INVALID METHOD';
		}
	};

	// ParamInputError {{{1

	var ParamInputError = makeSubclass('ParamInputError', Error, function (msg) {
		this.message = msg;
	});

	// ParamInput {{{1

	// Constructor {{{2

	/**
	 * @typedef ParamInput~ctor_opts
	 *
	 * @property {string} inputName
	 *
	 * @property {string} inputType
	 *
	 * @property {string} reportMethod
	 *
	 * @property {object} cgi
	 *
	 * @property {string} cgi.name
	 *
	 * @property {string} cgi.value
	 *
	 * @property {object} json
	 *
	 * @property {string} json.name
	 *
	 * @property {string} json.column
	 *
	 * @property {string} json.operator
	 *
	 * @property {string} json.operand
	 */

	/**
	 * The ParamInput class contains the idea that parameters for data sources can come from user
	 * inputs.  Multiple types of inputs are supported, such as multi-autocompletes and date inputs.
	 * There is also a special case for no input at all, in which case the value is hardcoded by the
	 * developer (e.g. for providing a "baseline" JSON WHERE clause to a model report).
	 *
	 * Right now this is mostly a wrapper around a Filter, but ParamInputs are a little more generic and
	 * probably will become the de facto way of doing this from here on.
	 *
	 * @param {string} sourceType What type of data source we are working with.  Must be one of: report,
	 * json, local.
	 *
	 * @param {ParamInput~ctor_opts} opts Various options controlling the behavior of the resulting ParamInput
	 * instance.
	 *
	 * @class
	 *
	 * @property {string} inputName
	 * @property {string} inputType
	 * @property {string} reportMethod
	 * @property {string} cgiName
	 * @property {string} cgiValue
	 * @property {string} jsonName
	 * @property {string} jsonColumn
	 * @property {string} jsonOperator
	 * @property {string} jsonOperand
	 */

	var ParamInput = function (sourceType, opts) {
		var self = this
			, filterOpts = {};

		self.inputName = opts.inputName;
		self.inputType = opts.inputType;

		switch (sourceType) {
		case 'report':
			self.reportMethod = opts.reportMethod;

			filterOpts = {
				type: self.inputType,
				method: self.reportMethod,
				inputName: self.inputName,
			};

			switch (self.reportMethod) {
			case 'cgi':
				self.cgiName = opts.cgi.name;
				self.cgiValue = opts.cgi.value;

				filterOpts.paramName = self.cgiName; // TODO: Remove after self.filter is gone.
				filterOpts.defaultValue = self.cgiValue;

				break;
			case 'json_where':
			case 'json_having':
				self.jsonName = opts.json.name;
				self.jsonColumn = opts.json.column;
				self.jsonOperator = opts.json.operator;
				self.jsonOperand = opts.json.operand;

				filterOpts.json = { // TODO: Remove after self.filter is gone.
					name: self.jsonName,
					column: self.jsonColumn,
					operator: self.jsonOperator,
					operand: self.jsonOperand
				};

				break;
			default:
				throw new ParamInputError('Unrecognized report method "' + opts.reportMethod + '". ' +
					'Must be "cgi", "json_where", or "json_having".');
			}

			break;
		case 'json':
			throw new ParamInputError('Parameter inputs not allowed for JSON API data.');
		case 'local':
			throw new ParamInputError('Parameter inputs not allowed for local data.');
		default:
			throw new ParamInputError('Unrecognized source type "' + sourceType + '". ' +
				'Must be "report", "json", or "local".');
		}

		self.filter = new Filter(filterOpts);
	};

	delegate(ParamInput, 'filter', ['toParams']);

	var papaparse = createCommonjsModule(function (module, exports) {
	/* @license
	Papa Parse
	v4.6.3
	https://github.com/mholt/PapaParse
	License: MIT
	*/

	// Polyfills
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray#Polyfill
	if (!Array.isArray)
	{
		Array.isArray = function(arg) {
			return Object.prototype.toString.call(arg) === '[object Array]';
		};
	}

	(function(root, factory)
	{
		/* globals define */
		{
			// Node. Does not work with strict CommonJS, but
			// only CommonJS-like environments that support module.exports,
			// like Node.
			module.exports = factory();
		}
	}(commonjsGlobal, function()
	{

		var global = (function() {
			// alternative method, similar to `Function('return this')()`
			// but without using `eval` (which is disabled when
			// using Content Security Policy).

			if (typeof self !== 'undefined') { return self; }
			if (typeof window !== 'undefined') { return window; }
			if (typeof global !== 'undefined') { return global; }

			// When running tests none of the above have been defined
			return {};
		})();

		var IS_WORKER = !global.document && !!global.postMessage,
			IS_PAPA_WORKER = IS_WORKER && /(\?|&)papaworker(=|&|$)/.test(global.location.search),
			LOADED_SYNC = false, AUTO_SCRIPT_PATH;
		var workers = {}, workerIdCounter = 0;

		var Papa = {};

		Papa.parse = CsvToJson;
		Papa.unparse = JsonToCsv;

		Papa.RECORD_SEP = String.fromCharCode(30);
		Papa.UNIT_SEP = String.fromCharCode(31);
		Papa.BYTE_ORDER_MARK = '\ufeff';
		Papa.BAD_DELIMITERS = ['\r', '\n', '"', Papa.BYTE_ORDER_MARK];
		Papa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;
		Papa.SCRIPT_PATH = null;	// Must be set by your code if you use workers and this lib is loaded asynchronously
		Papa.NODE_STREAM_INPUT = 1;

		// Configurable chunk sizes for local and remote files, respectively
		Papa.LocalChunkSize = 1024 * 1024 * 10;	// 10 MB
		Papa.RemoteChunkSize = 1024 * 1024 * 5;	// 5 MB
		Papa.DefaultDelimiter = ',';			// Used if not specified and detection fails

		// Exposed for testing and development only
		Papa.Parser = Parser;
		Papa.ParserHandle = ParserHandle;
		Papa.NetworkStreamer = NetworkStreamer;
		Papa.FileStreamer = FileStreamer;
		Papa.StringStreamer = StringStreamer;
		Papa.ReadableStreamStreamer = ReadableStreamStreamer;
		if (typeof PAPA_BROWSER_CONTEXT === 'undefined') {
			Papa.DuplexStreamStreamer = DuplexStreamStreamer;
		}

		if (global.jQuery)
		{
			var $ = global.jQuery;
			$.fn.parse = function(options)
			{
				var config = options.config || {};
				var queue = [];

				this.each(function(idx)
				{
					var supported = $(this).prop('tagName').toUpperCase() === 'INPUT'
									&& $(this).attr('type').toLowerCase() === 'file'
									&& global.FileReader;

					if (!supported || !this.files || this.files.length === 0)
						return true;	// continue to next input element

					for (var i = 0; i < this.files.length; i++)
					{
						queue.push({
							file: this.files[i],
							inputElem: this,
							instanceConfig: $.extend({}, config)
						});
					}
				});

				parseNextFile();	// begin parsing
				return this;		// maintains chainability


				function parseNextFile()
				{
					if (queue.length === 0)
					{
						if (isFunction(options.complete))
							options.complete();
						return;
					}

					var f = queue[0];

					if (isFunction(options.before))
					{
						var returned = options.before(f.file, f.inputElem);

						if (typeof returned === 'object')
						{
							if (returned.action === 'abort')
							{
								error('AbortError', f.file, f.inputElem, returned.reason);
								return;	// Aborts all queued files immediately
							}
							else if (returned.action === 'skip')
							{
								fileComplete();	// parse the next file in the queue, if any
								return;
							}
							else if (typeof returned.config === 'object')
								f.instanceConfig = $.extend(f.instanceConfig, returned.config);
						}
						else if (returned === 'skip')
						{
							fileComplete();	// parse the next file in the queue, if any
							return;
						}
					}

					// Wrap up the user's complete callback, if any, so that ours also gets executed
					var userCompleteFunc = f.instanceConfig.complete;
					f.instanceConfig.complete = function(results)
					{
						if (isFunction(userCompleteFunc))
							userCompleteFunc(results, f.file, f.inputElem);
						fileComplete();
					};

					Papa.parse(f.file, f.instanceConfig);
				}

				function error(name, file, elem, reason)
				{
					if (isFunction(options.error))
						options.error({name: name}, file, elem, reason);
				}

				function fileComplete()
				{
					queue.splice(0, 1);
					parseNextFile();
				}
			};
		}


		if (IS_PAPA_WORKER)
		{
			global.onmessage = workerThreadReceivedMessage;
		}
		else if (Papa.WORKERS_SUPPORTED)
		{
			AUTO_SCRIPT_PATH = getScriptPath();

			// Check if the script was loaded synchronously
			if (!document.body)
			{
				// Body doesn't exist yet, must be synchronous
				LOADED_SYNC = true;
			}
			else
			{
				document.addEventListener('DOMContentLoaded', function() {
					LOADED_SYNC = true;
				}, true);
			}
		}




		function CsvToJson(_input, _config)
		{
			_config = _config || {};
			var dynamicTyping = _config.dynamicTyping || false;
			if (isFunction(dynamicTyping)) {
				_config.dynamicTypingFunction = dynamicTyping;
				// Will be filled on first row call
				dynamicTyping = {};
			}
			_config.dynamicTyping = dynamicTyping;

			_config.transform = isFunction(_config.transform) ? _config.transform : false;

			if (_config.worker && Papa.WORKERS_SUPPORTED)
			{
				var w = newWorker();

				w.userStep = _config.step;
				w.userChunk = _config.chunk;
				w.userComplete = _config.complete;
				w.userError = _config.error;

				_config.step = isFunction(_config.step);
				_config.chunk = isFunction(_config.chunk);
				_config.complete = isFunction(_config.complete);
				_config.error = isFunction(_config.error);
				delete _config.worker;	// prevent infinite loop

				w.postMessage({
					input: _input,
					config: _config,
					workerId: w.id
				});

				return;
			}

			var streamer = null;
			if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined')
			{
				// create a node Duplex stream for use
				// with .pipe
				streamer = new DuplexStreamStreamer(_config);
				return streamer.getStream();
			}
			else if (typeof _input === 'string')
			{
				if (_config.download)
					streamer = new NetworkStreamer(_config);
				else
					streamer = new StringStreamer(_config);
			}
			else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on))
			{
				streamer = new ReadableStreamStreamer(_config);
			}
			else if ((global.File && _input instanceof File) || _input instanceof Object)	// ...Safari. (see issue #106)
				streamer = new FileStreamer(_config);

			return streamer.stream(_input);
		}






		function JsonToCsv(_input, _config)
		{
			// Default configuration

			/** whether to surround every datum with quotes */
			var _quotes = false;

			/** whether to write headers */
			var _writeHeader = true;

			/** delimiting character(s) */
			var _delimiter = ',';

			/** newline character(s) */
			var _newline = '\r\n';

			/** quote character */
			var _quoteChar = '"';

			/** whether to skip empty lines */
			var _skipEmptyLines = false;

			unpackConfig();

			var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');

			if (typeof _input === 'string')
				_input = JSON.parse(_input);

			if (Array.isArray(_input))
			{
				if (!_input.length || Array.isArray(_input[0]))
					return serialize(null, _input, _skipEmptyLines);
				else if (typeof _input[0] === 'object')
					return serialize(objectKeys(_input[0]), _input, _skipEmptyLines);
			}
			else if (typeof _input === 'object')
			{
				if (typeof _input.data === 'string')
					_input.data = JSON.parse(_input.data);

				if (Array.isArray(_input.data))
				{
					if (!_input.fields)
						_input.fields =  _input.meta && _input.meta.fields;

					if (!_input.fields)
						_input.fields =  Array.isArray(_input.data[0])
							? _input.fields
							: objectKeys(_input.data[0]);

					if (!(Array.isArray(_input.data[0])) && typeof _input.data[0] !== 'object')
						_input.data = [_input.data];	// handles input like [1,2,3] or ['asdf']
				}

				return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);
			}

			// Default (any valid paths should return before this)
			throw 'exception: Unable to serialize unrecognized input';


			function unpackConfig()
			{
				if (typeof _config !== 'object')
					return;

				if (typeof _config.delimiter === 'string'
	                && !Papa.BAD_DELIMITERS.filter(function(value) { return _config.delimiter.indexOf(value) !== -1; }).length)
				{
					_delimiter = _config.delimiter;
				}

				if (typeof _config.quotes === 'boolean'
					|| Array.isArray(_config.quotes))
					_quotes = _config.quotes;

				if (typeof _config.skipEmptyLines === 'boolean'
					|| typeof _config.skipEmptyLines === 'string')
					_skipEmptyLines = _config.skipEmptyLines;

				if (typeof _config.newline === 'string')
					_newline = _config.newline;

				if (typeof _config.quoteChar === 'string')
					_quoteChar = _config.quoteChar;

				if (typeof _config.header === 'boolean')
					_writeHeader = _config.header;
			}


			/** Turns an object's keys into an array */
			function objectKeys(obj)
			{
				if (typeof obj !== 'object')
					return [];
				var keys = [];
				for (var key in obj)
					keys.push(key);
				return keys;
			}

			/** The double for loop that iterates the data and writes out a CSV string including header row */
			function serialize(fields, data, skipEmptyLines)
			{
				var csv = '';

				if (typeof fields === 'string')
					fields = JSON.parse(fields);
				if (typeof data === 'string')
					data = JSON.parse(data);

				var hasHeader = Array.isArray(fields) && fields.length > 0;
				var dataKeyedByField = !(Array.isArray(data[0]));

				// If there a header row, write it first
				if (hasHeader && _writeHeader)
				{
					for (var i = 0; i < fields.length; i++)
					{
						if (i > 0)
							csv += _delimiter;
						csv += safe(fields[i], i);
					}
					if (data.length > 0)
						csv += _newline;
				}

				// Then write out the data
				for (var row = 0; row < data.length; row++)
				{
					var maxCol = hasHeader ? fields.length : data[row].length;

					var emptyLine = false;
					var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;
					if (skipEmptyLines && !hasHeader)
					{
						emptyLine = skipEmptyLines === 'greedy' ? data[row].join('').trim() === '' : data[row].length === 1 && data[row][0].length === 0;
					}
					if (skipEmptyLines === 'greedy' && hasHeader) {
						var line = [];
						for (var c = 0; c < maxCol; c++) {
							var cx = dataKeyedByField ? fields[c] : c;
							line.push(data[row][cx]);
						}
						emptyLine = line.join('').trim() === '';
					}
					if (!emptyLine)
					{
						for (var col = 0; col < maxCol; col++)
						{
							if (col > 0 && !nullLine)
								csv += _delimiter;
							var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
							csv += safe(data[row][colIdx], col);
						}
						if (row < data.length - 1 && (!skipEmptyLines || (maxCol > 0 && !nullLine)))
						{
							csv += _newline;
						}
					}
				}
				return csv;
			}

			/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */
			function safe(str, col)
			{
				if (typeof str === 'undefined' || str === null)
					return '';

				if (str.constructor === Date)
					return JSON.stringify(str).slice(1, 25);

				str = str.toString().replace(quoteCharRegex, _quoteChar + _quoteChar);

				var needsQuotes = (typeof _quotes === 'boolean' && _quotes)
								|| (Array.isArray(_quotes) && _quotes[col])
								|| hasAny(str, Papa.BAD_DELIMITERS)
								|| str.indexOf(_delimiter) > -1
								|| str.charAt(0) === ' '
								|| str.charAt(str.length - 1) === ' ';

				return needsQuotes ? _quoteChar + str + _quoteChar : str;
			}

			function hasAny(str, substrings)
			{
				for (var i = 0; i < substrings.length; i++)
					if (str.indexOf(substrings[i]) > -1)
						return true;
				return false;
			}
		}

		/** ChunkStreamer is the base prototype for various streamer implementations. */
		function ChunkStreamer(config)
		{
			this._handle = null;
			this._finished = false;
			this._completed = false;
			this._input = null;
			this._baseIndex = 0;
			this._partialLine = '';
			this._rowCount = 0;
			this._start = 0;
			this._nextChunk = null;
			this.isFirstChunk = true;
			this._completeResults = {
				data: [],
				errors: [],
				meta: {}
			};
			replaceConfig.call(this, config);

			this.parseChunk = function(chunk, isFakeChunk)
			{
				// First chunk pre-processing
				if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))
				{
					var modifiedChunk = this._config.beforeFirstChunk(chunk);
					if (modifiedChunk !== undefined)
						chunk = modifiedChunk;
				}
				this.isFirstChunk = false;

				// Rejoin the line we likely just split in two by chunking the file
				var aggregate = this._partialLine + chunk;
				this._partialLine = '';

				var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);

				if (this._handle.paused() || this._handle.aborted())
					return;

				var lastIndex = results.meta.cursor;

				if (!this._finished)
				{
					this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
					this._baseIndex = lastIndex;
				}

				if (results && results.data)
					this._rowCount += results.data.length;

				var finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);

				if (IS_PAPA_WORKER)
				{
					global.postMessage({
						results: results,
						workerId: Papa.WORKER_ID,
						finished: finishedIncludingPreview
					});
				}
				else if (isFunction(this._config.chunk) && !isFakeChunk)
				{
					this._config.chunk(results, this._handle);
					if (this._handle.paused() || this._handle.aborted())
						return;
					results = undefined;
					this._completeResults = undefined;
				}

				if (!this._config.step && !this._config.chunk) {
					this._completeResults.data = this._completeResults.data.concat(results.data);
					this._completeResults.errors = this._completeResults.errors.concat(results.errors);
					this._completeResults.meta = results.meta;
				}

				if (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {
					this._config.complete(this._completeResults, this._input);
					this._completed = true;
				}

				if (!finishedIncludingPreview && (!results || !results.meta.paused))
					this._nextChunk();

				return results;
			};

			this._sendError = function(error)
			{
				if (isFunction(this._config.error))
					this._config.error(error);
				else if (IS_PAPA_WORKER && this._config.error)
				{
					global.postMessage({
						workerId: Papa.WORKER_ID,
						error: error,
						finished: false
					});
				}
			};

			function replaceConfig(config)
			{
				// Deep-copy the config so we can edit it
				var configCopy = copy(config);
				configCopy.chunkSize = parseInt(configCopy.chunkSize);	// parseInt VERY important so we don't concatenate strings!
				if (!config.step && !config.chunk)
					configCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196
				this._handle = new ParserHandle(configCopy);
				this._handle.streamer = this;
				this._config = configCopy;	// persist the copy to the caller
			}
		}


		function NetworkStreamer(config)
		{
			config = config || {};
			if (!config.chunkSize)
				config.chunkSize = Papa.RemoteChunkSize;
			ChunkStreamer.call(this, config);

			var xhr;

			if (IS_WORKER)
			{
				this._nextChunk = function()
				{
					this._readChunk();
					this._chunkLoaded();
				};
			}
			else
			{
				this._nextChunk = function()
				{
					this._readChunk();
				};
			}

			this.stream = function(url)
			{
				this._input = url;
				this._nextChunk();	// Starts streaming
			};

			this._readChunk = function()
			{
				if (this._finished)
				{
					this._chunkLoaded();
					return;
				}

				xhr = new XMLHttpRequest();

				if (this._config.withCredentials)
				{
					xhr.withCredentials = this._config.withCredentials;
				}

				if (!IS_WORKER)
				{
					xhr.onload = bindFunction(this._chunkLoaded, this);
					xhr.onerror = bindFunction(this._chunkError, this);
				}

				xhr.open('GET', this._input, !IS_WORKER);
				// Headers can only be set when once the request state is OPENED
				if (this._config.downloadRequestHeaders)
				{
					var headers = this._config.downloadRequestHeaders;

					for (var headerName in headers)
					{
						xhr.setRequestHeader(headerName, headers[headerName]);
					}
				}

				if (this._config.chunkSize)
				{
					var end = this._start + this._config.chunkSize - 1;	// minus one because byte range is inclusive
					xhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);
					xhr.setRequestHeader('If-None-Match', 'webkit-no-cache'); // https://bugs.webkit.org/show_bug.cgi?id=82672
				}

				try {
					xhr.send();
				}
				catch (err) {
					this._chunkError(err.message);
				}

				if (IS_WORKER && xhr.status === 0)
					this._chunkError();
				else
					this._start += this._config.chunkSize;
			};

			this._chunkLoaded = function()
			{
				if (xhr.readyState !== 4)
					return;

				if (xhr.status < 200 || xhr.status >= 400)
				{
					this._chunkError();
					return;
				}

				this._finished = !this._config.chunkSize || this._start > getFileSize(xhr);
				this.parseChunk(xhr.responseText);
			};

			this._chunkError = function(errorMessage)
			{
				var errorText = xhr.statusText || errorMessage;
				this._sendError(new Error(errorText));
			};

			function getFileSize(xhr)
			{
				var contentRange = xhr.getResponseHeader('Content-Range');
				if (contentRange === null) { // no content range, then finish!
					return -1;
				}
				return parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));
			}
		}
		NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);
		NetworkStreamer.prototype.constructor = NetworkStreamer;


		function FileStreamer(config)
		{
			config = config || {};
			if (!config.chunkSize)
				config.chunkSize = Papa.LocalChunkSize;
			ChunkStreamer.call(this, config);

			var reader, slice;

			// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862
			// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76
			var usingAsyncReader = typeof FileReader !== 'undefined';	// Safari doesn't consider it a function - see issue #105

			this.stream = function(file)
			{
				this._input = file;
				slice = file.slice || file.webkitSlice || file.mozSlice;

				if (usingAsyncReader)
				{
					reader = new FileReader();		// Preferred method of reading files, even in workers
					reader.onload = bindFunction(this._chunkLoaded, this);
					reader.onerror = bindFunction(this._chunkError, this);
				}
				else
					reader = new FileReaderSync();	// Hack for running in a web worker in Firefox

				this._nextChunk();	// Starts streaming
			};

			this._nextChunk = function()
			{
				if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))
					this._readChunk();
			};

			this._readChunk = function()
			{
				var input = this._input;
				if (this._config.chunkSize)
				{
					var end = Math.min(this._start + this._config.chunkSize, this._input.size);
					input = slice.call(input, this._start, end);
				}
				var txt = reader.readAsText(input, this._config.encoding);
				if (!usingAsyncReader)
					this._chunkLoaded({ target: { result: txt } });	// mimic the async signature
			};

			this._chunkLoaded = function(event)
			{
				// Very important to increment start each time before handling results
				this._start += this._config.chunkSize;
				this._finished = !this._config.chunkSize || this._start >= this._input.size;
				this.parseChunk(event.target.result);
			};

			this._chunkError = function()
			{
				this._sendError(reader.error);
			};

		}
		FileStreamer.prototype = Object.create(ChunkStreamer.prototype);
		FileStreamer.prototype.constructor = FileStreamer;


		function StringStreamer(config)
		{
			config = config || {};
			ChunkStreamer.call(this, config);

			var remaining;
			this.stream = function(s)
			{
				remaining = s;
				return this._nextChunk();
			};
			this._nextChunk = function()
			{
				if (this._finished) return;
				var size = this._config.chunkSize;
				var chunk = size ? remaining.substr(0, size) : remaining;
				remaining = size ? remaining.substr(size) : '';
				this._finished = !remaining;
				return this.parseChunk(chunk);
			};
		}
		StringStreamer.prototype = Object.create(StringStreamer.prototype);
		StringStreamer.prototype.constructor = StringStreamer;


		function ReadableStreamStreamer(config)
		{
			config = config || {};

			ChunkStreamer.call(this, config);

			var queue = [];
			var parseOnData = true;
			var streamHasEnded = false;

			this.pause = function()
			{
				ChunkStreamer.prototype.pause.apply(this, arguments);
				this._input.pause();
			};

			this.resume = function()
			{
				ChunkStreamer.prototype.resume.apply(this, arguments);
				this._input.resume();
			};

			this.stream = function(stream)
			{
				this._input = stream;

				this._input.on('data', this._streamData);
				this._input.on('end', this._streamEnd);
				this._input.on('error', this._streamError);
			};

			this._checkIsFinished = function()
			{
				if (streamHasEnded && queue.length === 1) {
					this._finished = true;
				}
			};

			this._nextChunk = function()
			{
				this._checkIsFinished();
				if (queue.length)
				{
					this.parseChunk(queue.shift());
				}
				else
				{
					parseOnData = true;
				}
			};

			this._streamData = bindFunction(function(chunk)
			{
				try
				{
					queue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));

					if (parseOnData)
					{
						parseOnData = false;
						this._checkIsFinished();
						this.parseChunk(queue.shift());
					}
				}
				catch (error)
				{
					this._streamError(error);
				}
			}, this);

			this._streamError = bindFunction(function(error)
			{
				this._streamCleanUp();
				this._sendError(error);
			}, this);

			this._streamEnd = bindFunction(function()
			{
				this._streamCleanUp();
				streamHasEnded = true;
				this._streamData('');
			}, this);

			this._streamCleanUp = bindFunction(function()
			{
				this._input.removeListener('data', this._streamData);
				this._input.removeListener('end', this._streamEnd);
				this._input.removeListener('error', this._streamError);
			}, this);
		}
		ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
		ReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;


		function DuplexStreamStreamer(_config) {
			var Duplex = stream.Duplex;
			var config = copy(_config);
			var parseOnWrite = true;
			var writeStreamHasFinished = false;
			var parseCallbackQueue = [];
			var stream$1 = null;

			this._onCsvData = function(results)
			{
				var data = results.data;
				for (var i = 0; i < data.length; i++) {
					if (!stream$1.push(data[i]) && !this._handle.paused()) {
						// the writeable consumer buffer has filled up
						// so we need to pause until more items
						// can be processed
						this._handle.pause();
					}
				}
			};

			this._onCsvComplete = function()
			{
				// node will finish the read stream when
				// null is pushed
				stream$1.push(null);
			};

			config.step = bindFunction(this._onCsvData, this);
			config.complete = bindFunction(this._onCsvComplete, this);
			ChunkStreamer.call(this, config);

			this._nextChunk = function()
			{
				if (writeStreamHasFinished && parseCallbackQueue.length === 1) {
					this._finished = true;
				}
				if (parseCallbackQueue.length) {
					parseCallbackQueue.shift()();
				} else {
					parseOnWrite = true;
				}
			};

			this._addToParseQueue = function(chunk, callback)
			{
				// add to queue so that we can indicate
				// completion via callback
				// node will automatically pause the incoming stream
				// when too many items have been added without their
				// callback being invoked
				parseCallbackQueue.push(bindFunction(function() {
					this.parseChunk(typeof chunk === 'string' ? chunk : chunk.toString(config.encoding));
					if (isFunction(callback)) {
						return callback();
					}
				}, this));
				if (parseOnWrite) {
					parseOnWrite = false;
					this._nextChunk();
				}
			};

			this._onRead = function()
			{
				if (this._handle.paused()) {
					// the writeable consumer can handle more data
					// so resume the chunk parsing
					this._handle.resume();
				}
			};

			this._onWrite = function(chunk, encoding, callback)
			{
				this._addToParseQueue(chunk, callback);
			};

			this._onWriteComplete = function()
			{
				writeStreamHasFinished = true;
				// have to write empty string
				// so parser knows its done
				this._addToParseQueue('');
			};

			this.getStream = function()
			{
				return stream$1;
			};
			stream$1 = new Duplex({
				readableObjectMode: true,
				decodeStrings: false,
				read: bindFunction(this._onRead, this),
				write: bindFunction(this._onWrite, this)
			});
			stream$1.once('finish', bindFunction(this._onWriteComplete, this));
		}
		if (typeof PAPA_BROWSER_CONTEXT === 'undefined') {
			DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
			DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;
		}


		// Use one ParserHandle per entire CSV file or string
		function ParserHandle(_config)
		{
			// One goal is to minimize the use of regular expressions...
			var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
			var ISO_DATE = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;

			var self = this;
			var _stepCounter = 0;	// Number of times step was called (number of rows parsed)
			var _rowCounter = 0;	// Number of rows that have been parsed so far
			var _input;				// The input being parsed
			var _parser;			// The core parser being used
			var _paused = false;	// Whether we are paused or not
			var _aborted = false;	// Whether the parser has aborted or not
			var _delimiterError;	// Temporary state between delimiter detection and processing results
			var _fields = [];		// Fields are from the header row of the input, if there is one
			var _results = {		// The last results returned from the parser
				data: [],
				errors: [],
				meta: {}
			};

			if (isFunction(_config.step))
			{
				var userStep = _config.step;
				_config.step = function(results)
				{
					_results = results;

					if (needsHeaderRow())
						processResults();
					else	// only call user's step function after header row
					{
						processResults();

						// It's possbile that this line was empty and there's no row here after all
						if (_results.data.length === 0)
							return;

						_stepCounter += results.data.length;
						if (_config.preview && _stepCounter > _config.preview)
							_parser.abort();
						else
							userStep(_results, self);
					}
				};
			}

			/**
			 * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
			 * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
			 * when an input comes in multiple chunks, like from a file.
			 */
			this.parse = function(input, baseIndex, ignoreLastRow)
			{
				var quoteChar = _config.quoteChar || '"';
				if (!_config.newline)
					_config.newline = guessLineEndings(input, quoteChar);

				_delimiterError = false;
				if (!_config.delimiter)
				{
					var delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments);
					if (delimGuess.successful)
						_config.delimiter = delimGuess.bestDelimiter;
					else
					{
						_delimiterError = true;	// add error after parsing (otherwise it would be overwritten)
						_config.delimiter = Papa.DefaultDelimiter;
					}
					_results.meta.delimiter = _config.delimiter;
				}
				else if(isFunction(_config.delimiter))
				{
					_config.delimiter = _config.delimiter(input);
					_results.meta.delimiter = _config.delimiter;
				}

				var parserConfig = copy(_config);
				if (_config.preview && _config.header)
					parserConfig.preview++;	// to compensate for header row

				_input = input;
				_parser = new Parser(parserConfig);
				_results = _parser.parse(_input, baseIndex, ignoreLastRow);
				processResults();
				return _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });
			};

			this.paused = function()
			{
				return _paused;
			};

			this.pause = function()
			{
				_paused = true;
				_parser.abort();
				_input = _input.substr(_parser.getCharIndex());
			};

			this.resume = function()
			{
				_paused = false;
				self.streamer.parseChunk(_input, true);
			};

			this.aborted = function()
			{
				return _aborted;
			};

			this.abort = function()
			{
				_aborted = true;
				_parser.abort();
				_results.meta.aborted = true;
				if (isFunction(_config.complete))
					_config.complete(_results);
				_input = '';
			};

			function testEmptyLine(s) {
				return _config.skipEmptyLines === 'greedy' ? s.join('').trim() === '' : s.length === 1 && s[0].length === 0;
			}

			function processResults()
			{
				if (_results && _delimiterError)
				{
					addError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \'' + Papa.DefaultDelimiter + '\'');
					_delimiterError = false;
				}

				if (_config.skipEmptyLines)
				{
					for (var i = 0; i < _results.data.length; i++)
						if (testEmptyLine(_results.data[i]))
							_results.data.splice(i--, 1);
				}

				if (needsHeaderRow())
					fillHeaderFields();

				return applyHeaderAndDynamicTypingAndTransformation();
			}

			function needsHeaderRow()
			{
				return _config.header && _fields.length === 0;
			}

			function fillHeaderFields()
			{
				if (!_results)
					return;
				for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
					for (var j = 0; j < _results.data[i].length; j++)
					{
						var header = _results.data[i][j];

						if (_config.trimHeaders) {
							header = header.trim();
						}

						_fields.push(header);
					}
				_results.data.splice(0, 1);
			}

			function shouldApplyDynamicTyping(field) {
				// Cache function values to avoid calling it for each row
				if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {
					_config.dynamicTyping[field] = _config.dynamicTypingFunction(field);
				}
				return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;
			}

			function parseDynamic(field, value)
			{
				if (shouldApplyDynamicTyping(field))
				{
					if (value === 'true' || value === 'TRUE')
						return true;
					else if (value === 'false' || value === 'FALSE')
						return false;
					else if (FLOAT.test(value))
						return parseFloat(value);
					else if (ISO_DATE.test(value))
						return new Date(value);
					else
						return (value === '' ? null : value);
				}
				return value;
			}

			function applyHeaderAndDynamicTypingAndTransformation()
			{
				if (!_results || (!_config.header && !_config.dynamicTyping && !_config.transform))
					return _results;

				for (var i = 0; i < _results.data.length; i++)
				{
					var row = _config.header ? {} : [];

					var j;
					for (j = 0; j < _results.data[i].length; j++)
					{
						var field = j;
						var value = _results.data[i][j];

						if (_config.header)
							field = j >= _fields.length ? '__parsed_extra' : _fields[j];

						if (_config.transform)
							value = _config.transform(value,field);

						value = parseDynamic(field, value);

						if (field === '__parsed_extra')
						{
							row[field] = row[field] || [];
							row[field].push(value);
						}
						else
							row[field] = value;
					}

					_results.data[i] = row;

					if (_config.header)
					{
						if (j > _fields.length)
							addError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);
						else if (j < _fields.length)
							addError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);
					}
				}

				if (_config.header && _results.meta)
					_results.meta.fields = _fields;

				_rowCounter += _results.data.length;
				return _results;
			}

			function guessDelimiter(input, newline, skipEmptyLines, comments)
			{
				var delimChoices = [',', '\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];
				var bestDelim, bestDelta, fieldCountPrevRow;

				for (var i = 0; i < delimChoices.length; i++)
				{
					var delim = delimChoices[i];
					var delta = 0, avgFieldCount = 0, emptyLinesCount = 0;
					fieldCountPrevRow = undefined;

					var preview = new Parser({
						comments: comments,
						delimiter: delim,
						newline: newline,
						preview: 10
					}).parse(input);

					for (var j = 0; j < preview.data.length; j++)
					{
						if (skipEmptyLines && testEmptyLine(preview.data[j]))
						{
							emptyLinesCount++;
							continue;
						}
						var fieldCount = preview.data[j].length;
						avgFieldCount += fieldCount;

						if (typeof fieldCountPrevRow === 'undefined')
						{
							fieldCountPrevRow = 0;
							continue;
						}
						else if (fieldCount > 1)
						{
							delta += Math.abs(fieldCount - fieldCountPrevRow);
							fieldCountPrevRow = fieldCount;
						}
					}

					if (preview.data.length > 0)
						avgFieldCount /= (preview.data.length - emptyLinesCount);

					if ((typeof bestDelta === 'undefined' || delta > bestDelta)
						&& avgFieldCount > 1.99)
					{
						bestDelta = delta;
						bestDelim = delim;
					}
				}

				_config.delimiter = bestDelim;

				return {
					successful: !!bestDelim,
					bestDelimiter: bestDelim
				};
			}

			function guessLineEndings(input, quoteChar)
			{
				input = input.substr(0, 1024 * 1024);	// max length 1 MB
				// Replace all the text inside quotes
				var re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');
				input = input.replace(re, '');

				var r = input.split('\r');

				var n = input.split('\n');

				var nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);

				if (r.length === 1 || nAppearsFirst)
					return '\n';

				var numWithN = 0;
				for (var i = 0; i < r.length; i++)
				{
					if (r[i][0] === '\n')
						numWithN++;
				}

				return numWithN >= r.length / 2 ? '\r\n' : '\r';
			}

			function addError(type, code, msg, row)
			{
				_results.errors.push({
					type: type,
					code: code,
					message: msg,
					row: row
				});
			}
		}

		/** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */
		function escapeRegExp(string)
		{
			return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
		}

		/** The core parser implements speedy and correct CSV parsing */
		function Parser(config)
		{
			// Unpack the config object
			config = config || {};
			var delim = config.delimiter;
			var newline = config.newline;
			var comments = config.comments;
			var step = config.step;
			var preview = config.preview;
			var fastMode = config.fastMode;
			var quoteChar;
			/** Allows for no quoteChar by setting quoteChar to undefined in config */
			if (config.quoteChar === undefined) {
				quoteChar = '"';
			} else {
				quoteChar = config.quoteChar;
			}
			var escapeChar = quoteChar;
			if (config.escapeChar !== undefined) {
				escapeChar = config.escapeChar;
			}

			// Delimiter must be valid
			if (typeof delim !== 'string'
				|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)
				delim = ',';

			// Comment character must be valid
			if (comments === delim)
				throw 'Comment character same as delimiter';
			else if (comments === true)
				comments = '#';
			else if (typeof comments !== 'string'
				|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)
				comments = false;

			// Newline must be valid: \r, \n, or \r\n
			if (newline !== '\n' && newline !== '\r' && newline !== '\r\n')
				newline = '\n';

			// We're gonna need these at the Parser scope
			var cursor = 0;
			var aborted = false;

			this.parse = function(input, baseIndex, ignoreLastRow)
			{
				// For some reason, in Chrome, this speeds things up (!?)
				if (typeof input !== 'string')
					throw 'Input must be a string';

				// We don't need to compute some of these every time parse() is called,
				// but having them in a more local scope seems to perform better
				var inputLen = input.length,
					delimLen = delim.length,
					newlineLen = newline.length,
					commentsLen = comments.length;
				var stepIsFunction = isFunction(step);

				// Establish starting state
				cursor = 0;
				var data = [], errors = [], row = [], lastCursor = 0;

				if (!input)
					return returnable();

				if (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))
				{
					var rows = input.split(newline);
					for (var i = 0; i < rows.length; i++)
					{
						row = rows[i];
						cursor += row.length;
						if (i !== rows.length - 1)
							cursor += newline.length;
						else if (ignoreLastRow)
							return returnable();
						if (comments && row.substr(0, commentsLen) === comments)
							continue;
						if (stepIsFunction)
						{
							data = [];
							pushRow(row.split(delim));
							doStep();
							if (aborted)
								return returnable();
						}
						else
							pushRow(row.split(delim));
						if (preview && i >= preview)
						{
							data = data.slice(0, preview);
							return returnable(true);
						}
					}
					return returnable();
				}

				var nextDelim = input.indexOf(delim, cursor);
				var nextNewline = input.indexOf(newline, cursor);
				var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');
				var quoteSearch;

				// Parser loop
				for (;;)
				{
					// Field has opening quote
					if (input[cursor] === quoteChar)
					{
						// Start our search for the closing quote where the cursor is
						quoteSearch = cursor;

						// Skip the opening quote
						cursor++;

						for (;;)
						{
							// Find closing quote
							quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);

							//No other quotes are found - no other delimiters
							if (quoteSearch === -1)
							{
								if (!ignoreLastRow) {
									// No closing quote... what a pity
									errors.push({
										type: 'Quotes',
										code: 'MissingQuotes',
										message: 'Quoted field unterminated',
										row: data.length,	// row has yet to be inserted
										index: cursor
									});
								}
								return finish();
							}

							// Closing quote at EOF
							if (quoteSearch === inputLen - 1)
							{
								var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
								return finish(value);
							}

							// If this quote is escaped, it's part of the data; skip it
							// If the quote character is the escape character, then check if the next character is the escape character
							if (quoteChar === escapeChar &&  input[quoteSearch + 1] === escapeChar)
							{
								quoteSearch++;
								continue;
							}

							// If the quote character is not the escape character, then check if the previous character was the escape character
							if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar)
							{
								continue;
							}

							// Check up to nextDelim or nextNewline, whichever is closest
							var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);
							var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);

							// Closing quote followed by delimiter or 'unnecessary spaces + delimiter'
							if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim)
							{
								row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
								cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;
								nextDelim = input.indexOf(delim, cursor);
								nextNewline = input.indexOf(newline, cursor);
								break;
							}

							var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);

							// Closing quote followed by newline or 'unnecessary spaces + newLine'
							if (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline)
							{
								row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
								saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);
								nextDelim = input.indexOf(delim, cursor);	// because we may have skipped the nextDelim in the quoted field

								if (stepIsFunction)
								{
									doStep();
									if (aborted)
										return returnable();
								}

								if (preview && data.length >= preview)
									return returnable(true);

								break;
							}


							// Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string
							errors.push({
								type: 'Quotes',
								code: 'InvalidQuotes',
								message: 'Trailing quote on quoted field is malformed',
								row: data.length,	// row has yet to be inserted
								index: cursor
							});

							quoteSearch++;
							continue;

						}

						continue;
					}

					// Comment found at start of new line
					if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)
					{
						if (nextNewline === -1)	// Comment ends at EOF
							return returnable();
						cursor = nextNewline + newlineLen;
						nextNewline = input.indexOf(newline, cursor);
						nextDelim = input.indexOf(delim, cursor);
						continue;
					}

					// Next delimiter comes before next newline, so we've reached end of field
					if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))
					{
						row.push(input.substring(cursor, nextDelim));
						cursor = nextDelim + delimLen;
						nextDelim = input.indexOf(delim, cursor);
						continue;
					}

					// End of row
					if (nextNewline !== -1)
					{
						row.push(input.substring(cursor, nextNewline));
						saveRow(nextNewline + newlineLen);

						if (stepIsFunction)
						{
							doStep();
							if (aborted)
								return returnable();
						}

						if (preview && data.length >= preview)
							return returnable(true);

						continue;
					}

					break;
				}


				return finish();


				function pushRow(row)
				{
					data.push(row);
					lastCursor = cursor;
				}

				/**
	             * checks if there are extra spaces after closing quote and given index without any text
	             * if Yes, returns the number of spaces
	             */
				function extraSpaces(index) {
					var spaceLength = 0;
					if (index !== -1) {
						var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);
						if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {
							spaceLength = textBetweenClosingQuoteAndIndex.length;
						}
					}
					return spaceLength;
				}

				/**
				 * Appends the remaining input from cursor to the end into
				 * row, saves the row, calls step, and returns the results.
				 */
				function finish(value)
				{
					if (ignoreLastRow)
						return returnable();
					if (typeof value === 'undefined')
						value = input.substr(cursor);
					row.push(value);
					cursor = inputLen;	// important in case parsing is paused
					pushRow(row);
					if (stepIsFunction)
						doStep();
					return returnable();
				}

				/**
				 * Appends the current row to the results. It sets the cursor
				 * to newCursor and finds the nextNewline. The caller should
				 * take care to execute user's step function and check for
				 * preview and end parsing if necessary.
				 */
				function saveRow(newCursor)
				{
					cursor = newCursor;
					pushRow(row);
					row = [];
					nextNewline = input.indexOf(newline, cursor);
				}

				/** Returns an object with the results, errors, and meta. */
				function returnable(stopped)
				{
					return {
						data: data,
						errors: errors,
						meta: {
							delimiter: delim,
							linebreak: newline,
							aborted: aborted,
							truncated: !!stopped,
							cursor: lastCursor + (baseIndex || 0)
						}
					};
				}

				/** Executes the user's step function and resets data & errors. */
				function doStep()
				{
					step(returnable());
					data = [];
					errors = [];
				}
			};

			/** Sets the abort flag */
			this.abort = function()
			{
				aborted = true;
			};

			/** Gets the cursor position */
			this.getCharIndex = function()
			{
				return cursor;
			};
		}


		// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code
		// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358
		function getScriptPath()
		{
			var scripts = document.getElementsByTagName('script');
			return scripts.length ? scripts[scripts.length - 1].src : '';
		}

		function newWorker()
		{
			if (!Papa.WORKERS_SUPPORTED)
				return false;
			if (!LOADED_SYNC && Papa.SCRIPT_PATH === null)
				throw new Error(
					'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +
					'You need to set Papa.SCRIPT_PATH manually.'
				);
			var workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;
			// Append 'papaworker' to the search string to tell papaparse that this is our worker.
			workerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';
			var w = new global.Worker(workerUrl);
			w.onmessage = mainThreadReceivedMessage;
			w.id = workerIdCounter++;
			workers[w.id] = w;
			return w;
		}

		/** Callback when main thread receives a message */
		function mainThreadReceivedMessage(e)
		{
			var msg = e.data;
			var worker = workers[msg.workerId];
			var aborted = false;

			if (msg.error)
				worker.userError(msg.error, msg.file);
			else if (msg.results && msg.results.data)
			{
				var abort = function() {
					aborted = true;
					completeWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });
				};

				var handle = {
					abort: abort,
					pause: notImplemented,
					resume: notImplemented
				};

				if (isFunction(worker.userStep))
				{
					for (var i = 0; i < msg.results.data.length; i++)
					{
						worker.userStep({
							data: [msg.results.data[i]],
							errors: msg.results.errors,
							meta: msg.results.meta
						}, handle);
						if (aborted)
							break;
					}
					delete msg.results;	// free memory ASAP
				}
				else if (isFunction(worker.userChunk))
				{
					worker.userChunk(msg.results, handle, msg.file);
					delete msg.results;
				}
			}

			if (msg.finished && !aborted)
				completeWorker(msg.workerId, msg.results);
		}

		function completeWorker(workerId, results) {
			var worker = workers[workerId];
			if (isFunction(worker.userComplete))
				worker.userComplete(results);
			worker.terminate();
			delete workers[workerId];
		}

		function notImplemented() {
			throw 'Not implemented.';
		}

		/** Callback when worker thread receives a message */
		function workerThreadReceivedMessage(e)
		{
			var msg = e.data;

			if (typeof Papa.WORKER_ID === 'undefined' && msg)
				Papa.WORKER_ID = msg.workerId;

			if (typeof msg.input === 'string')
			{
				global.postMessage({
					workerId: Papa.WORKER_ID,
					results: Papa.parse(msg.input, msg.config),
					finished: true
				});
			}
			else if ((global.File && msg.input instanceof File) || msg.input instanceof Object)	// thank you, Safari (see issue #106)
			{
				var results = Papa.parse(msg.input, msg.config);
				if (results)
					global.postMessage({
						workerId: Papa.WORKER_ID,
						results: results,
						finished: true
					});
			}
		}

		/** Makes a deep copy of an array or object (mostly) */
		function copy(obj)
		{
			if (typeof obj !== 'object' || obj === null)
				return obj;
			var cpy = Array.isArray(obj) ? [] : {};
			for (var key in obj)
				cpy[key] = copy(obj[key]);
			return cpy;
		}

		function bindFunction(f, self)
		{
			return function() { f.apply(self, arguments); };
		}

		function isFunction(func)
		{
			return typeof func === 'function';
		}

		return Papa;
	}));
	});

	// Imports {{{1

	// SourceError {{{1

	var SourceError = makeSubclass('SourceError', Error, function (msg) {
		this.message = msg;
	});

	// LocalSource {{{1
	// Constructor {{{2

	var LocalSource = makeSubclass('LocalSource', Object, function (spec) {
		var self = this;

		self.varName = spec.varName;

		/*
		if (self.cache == null) {
			throw new InvalidSourceError('Local variable "' + self.varName + '" does not exist.');
		}

		if (!_.isArray(self.cache.data)) {
			throw new InvalidSourceError(self.varName + '.data is not an array.');
		}

		if (self.cache.typeInfo == null) {
			self.warning('No type information found in local data (' + self.varName + '.typeInfo is missing).');
		}
		*/

		self.cache = {
			data: deepCopy(window[self.varName].data),
			typeInfo: new OrdMap()
		};

		if (underscore.isArray(window[self.varName].typeInfo)) {
			underscore.each(window[self.varName].typeInfo, function (fti) {
				self.cache.typeInfo.set(fti.field, fti);
			});
		}
		else {
			underscore.each(window[self.varName].typeInfo, function (fti, field) {
				fti.field = field;
				self.cache.typeInfo.set(field, fti);
			});
		}
	});

	// #getData {{{2

	LocalSource.prototype.getData = function (params, cont) {
		var self = this;

		return cont(true, self.cache.data);
	};

	// #getTypeInfo {{{2

	LocalSource.prototype.getTypeInfo = function (cont) {
		var self = this;

		return cont(true, self.cache.typeInfo);
	};

	// #clearCachedData {{{2

	LocalSource.prototype.clearCachedData = function () {
		var self = this;

		self.cache = null;
	};

	// #getName {{{2

	LocalSource.prototype.getName = function () {
		var self = this;

		return self.varName;
	};

	// HttpSource {{{1
	// Constructor {{{2

	var HttpSource = makeSubclass('HttpSource', Object, function (spec, userTypeInfo) {
		var self = this;

		self.url = spec.url;
		self.method = spec.method || 'GET';
		self.dataType = spec.dataType;

		self.cache = null;
		self.userTypeInfo = userTypeInfo;
	});

	// #parseData {{{2

	HttpSource.prototype.parseData = function (data) {
		var result = {
				data: [],
				typeInfo: new OrdMap()
			};

		//debug.info('DATA SOURCE // HTTP // PARSER', 'Data = ' + ((data instanceof XMLDocument) ? '%o' : '%O'), data);

		if (data instanceof Document) {
			var root = jQuery(data).children('root');
			if (!root.is('root')) {
				throw new SourceError('HTTP Data Source / XML Parser / Missing (root) element');
			}

			data = root.children('data');
			if (data.length === 0) {
				throw new SourceError('HTTP Data Source / XML Parser / Missing (root > data) element');
			}
			else if (data.length > 1) {
				throw new SourceError('HTTP Data Source / XML Parser / Too many (root > data) elements');
			}

			data.children('item').each(function (_itemIndex, item) {
				item = jQuery(item);
				var row = {};
				item.children().each(function (_fieldIndex, field) {
					field = jQuery(field);
					row[field.prop('tagName')] = field.text();
				});
				result.data.push(row);
			});

			var typeInfo = root.children('typeInfo');
			if (typeInfo.length === 0) {
				throw new SourceError('HTTP Data Source / XML Parser / Missing (root > typeInfo) element');
			}
			else if (typeInfo.length > 1) {
				throw new SourceError('HTTP Data Source / XML Parser / Too many (root > typeInfo) elements');
			}

			typeInfo.children().each(function (_fieldIndex, field) {
				field = jQuery(field);
				var fieldName = field.prop('tagName');
				result.typeInfo.set(fieldName, {});
				if (field.children().length === 0) {
					result.typeInfo.get(fieldName).type = field.text();
				}
				else {
					var type = field.children('type');
					if (type.length === 0) {
						throw new SourceError('HTTP Data Source / XML Parser / Missing (root > typeInfo > ' + fieldName + ' > type) element');
					}
					else if (type.length > 1) {
						throw new SourceError('HTTP Data Source / XML Parser / Too many (root > typeInfo > ' + fieldName + ' > type) elements');
					}
					else if (type.children().length > 0) {
						throw new SourceError('HTTP Data Source / XML Parser / (root > typeInfo > ' + fieldName + ' > type) element cannot have children');
					}

					result.typeInfo.get(fieldName).type = type.text();

					var format = field.children('format');
					if (format.length > 1) {
						throw new SourceError('HTTP Data Source / XML Parser / Too many (root > typeInfo > ' + fieldName + ' > format) elements');
					}
					else if (format.length === 1) {
						if (format.children().length > 0) {
							throw new SourceError('HTTP Data Source / XML Parser / (root > typeInfo > ' + fieldName + ' > format) element cannot have children');
						}
						result.typeInfo.get(fieldName).format = format.text();
					}
				}
			});
		}
		else if (typeof data === 'string') {
			var decoded = papaparse.parse(data, { skipEmptyLines: true })
				, fields = decoded.data[0];

			underscore.each(decoded.data.slice(1), function (row) {
				var newRow = {};
				underscore.each(row, function (colVal, colIdx) {
					newRow[fields[colIdx]] = colVal;
				});
				result.data.push(newRow);
			});

			underscore.each(fields, function (f) {
				result.typeInfo.set(f, {
					type: 'string'
				});
			});
		}
		else {
			if (data.data === undefined) {
				throw new SourceError('HTTP Data Source / JSON Parser / Missing (data) property');
			}
			else if (!underscore.isArray(data.data)) {
				throw new SourceError('HTTP Data Source / JSON Parser / (data) property must be an array');
			}

			if (data.typeInfo === undefined) {
				throw new SourceError('HTTP Data Source / JSON Parser / Missing (typeInfo) property');
			}

			underscore.each(data.typeInfo, function (fti) {
				var field = fti.field;
				delete fti.field;
				result.typeInfo.set(field, fti);
			});

			for (var rowNum = 0; rowNum < data.data.length; rowNum += 1) {
				if (underscore.isArray(data.data[rowNum])) {
					var newRow = {};
					result.typeInfo.each(function (fti, field, i) {
						newRow[field] = data.data[rowNum][i];
					});
					data.data[rowNum] = newRow;
				}
			}

			result.data = data.data;
		}

		return result;
	};

	// #getData {{{2

	HttpSource.prototype.getData = function (params, cont) {
		var self = this;

		if (self.cache != null) {
			return cont(true, self.cache.data);
		}

		var al = logAsync('HttpSource#getData');
		self.xhr = jQuery.ajax(self.url, {
			method: self.method,
			data: params,
			traditional: true,
			dataType: self.dataType,
			error: function (jqXHR, textStatus, errorThrown) {
				al.finish();
				log.error('HTTP Data Source / AJAX Error / ' + errorThrown);
				return cont(false);
			},
			success: function (data, textStatus, jqXHR) {
				al.finish();
				self.cache = self.parseData(data);
				return cont(true, self.cache.data);
			}
		});

		return self.xhr;
	};

	// #getTypeInfo {{{2

	HttpSource.prototype.getTypeInfo = function (cont) {
		var self = this;

		if (self.cache != null) {
			return cont(true, self.cache.typeInfo);
		}

		return self.getData(undefined, function (ok) {
			if (!ok) {
				return cont(false);
			}

			return cont(true, self.cache.typeInfo);
		});
	};

	// #clearCachedData {{{2

	HttpSource.prototype.clearCachedData = function () {
		var self = this;

		self.cache = null;
	};

	// #cancel {{{2

	HttpSource.prototype.cancel = function () {
		var self = this;

		self.xhr.abort();
	};

	// FileSource {{{1
	// Constructor {{{2

	var FileSource = makeSubclass('FileSource', Object, function (spec, userTypeInfo, source) {
		var self = this;

		self.spec = spec;
		self.userTypeInfo = userTypeInfo;
		self.source = source;

		self.cache = {
			data: [],
			typeInfo: new OrdMap()
		};
	});

	// #setToolbar {{{2

	FileSource.prototype.setToolbar = function (toolbar) {
		var self = this;

		var input = jQuery('<input>', { 'type': 'file', 'name': 'file', 'accept': '.csv' })
			.on('change', function () {
				papaparse.parse(this.files.item(0), {
					header: true,
					skipEmptyLines: true,
					complete: function (results, file) {
						console.log(results);

						self.cache.data = results.data;
						self.cache.typeInfo = new OrdMap();

						underscore.each(results.meta.fields, function (field) {
							self.cache.typeInfo.set(field, {
								'type': 'string'
							});
						});

						self.source.clearCachedData();
					}
				});
			})
			.appendTo(toolbar);
	};

	// #setFile {{{2

	FileSource.prototype.setFiles = function (files) {
		var self = this;

		if (!(files instanceof FileList)) {
			return;
		}

		papaparse.parse(files.item(0), {
			header: true,
			skipEmptyLines: true,
			complete: function (results, file) {
				console.log(results);

				self.cache.data = results.data;
				self.cache.typeInfo = new OrdMap();

				underscore.each(results.meta.fields, function (field) {
					self.cache.typeInfo.set(field, {
						'type': 'string'
					});
				});

				self.source.clearCachedData();
			}
		});
	};

	// #getData {{{2

	FileSource.prototype.getData = function (params, cont) {
		var self = this;

		return cont(true, self.cache.data);
	};

	// #getTypeInfo {{{2

	FileSource.prototype.getTypeInfo = function (cont) {
		var self = this;

		return cont(true, self.cache.typeInfo);
	};

	// Source {{{1

	// JSDoc Typedefs {{{2

	/**
	 * A callback function that receives the data obtained from a data source.
	 *
	 * @callback Source~getData_cb
	 *
	 * @param {Array<Object>} data The data.
	 */

	/**
	 * A callback function that receives unique element information from a data source.
	 *
	 * @callback Source~getUniqElts_cb
	 *
	 * @param {Object<string, wcgraph.UniqElt>} uniqElts The unique element information.
	 */

	/**
	 * A callback function that receives the type information about a data source.
	 *
	 * @callback Source~getTypeInfo_cb
	 *
	 * @param {TypeInfo} typeInfo The type information.
	 */

	/**
	 * Represents information about the types of fields produced by a data source.  The keys are field
	 * names.  Values can just be the type name as a string, in simple situations; when more info is
	 * required, you can use the full object to describe the field.
	 *
	 * @typedef Source~TypeInfo
	 *
	 * @type {Object<string,string|Source~FieldTypeInfo>}
	 */

	/**
	 * This is the full specification of a field's type information.  One step of data acquisition is
	 * type decoding, which converts the data to an internal representation which will be used for
	 * sorting and filtering.  This step occurs after any user conversion functions are evaluated.  Type
	 * decoding works on the `value` property of the field value object.  If your conversion function
	 * updates this property, it's possible to perform your own conversion and still get the benefit of
	 * type decoding on the result.
	 *
	 * @typedef Source~FieldTypeInfo
	 *
	 * @property {string} type What type of data are we receiving?  Must be one of the following:
	 * string, number, date, datetime, currency.
	 *
	 * @property {string} format For a type of date or datetime, a formatting string for Moment which
	 * will decode the input.  Note that decoding comes *after* any conversion functions are executed.
	 */

	/**
	 * Source specification.
	 *
	 * @typedef Source~Spec
	 *
	 * @property {string} name
	 * @property {string} error
	 * @property {string} type
	 *
	 * @property {Array.<string>|Object.<string,Array.<string>>} conversion
	 * As an array, apply the named conversions to all fields in the data.  As an object, each key is a
	 * field, and the corresponding value is the named conversions to apply to that field only.
	 *
	 * ```
	 * conversion: ['foo', {'name': ['bar']}]
	 * ```
	 *
	 * This example applies the conversion *foo* to all fields, and the conversion *bar* only to values
	 * in the `name` field.
	 */

	// Constructor {{{2

	/**
	 * Abstract data source that wraps specific data source implementations (e.g. for system reports or
	 * the JSON API).
	 *
	 * @param {Source~Spec} spec
	 * Specification of the source.
	 *
	 * @param {object} params
	 *
	 * @param {object} userTypeInfo Provided by the user to override the type information that comes
	 * from the origin.  For example, you might be using an origin backed by MySQL, which reports a
	 * column type as being a string... but we want to treat it as a date.  You would override that
	 * field's type information to indicate it should be parsed as a date instead of a string.  Another
	 * possibility is to discard time information from a datetime, treating it as a date instead.
	 *
	 * ```
	 * {
	 *   "Birth Date": {
	 *     "type": "date"
	 *   }
	 * }
	 * ```
	 *
	 * @param {object} opts
	 *
	 * @param {boolean} [opts.deferDecoding=false] If true, defer conversion of numeric and date types
	 * (using Numeral and Moment) until required (when displayed or upon sort).
	 *
	 * @param {boolean} [opts.passThroughParams=false] If true, then parameters are obtained from the
	 * current page's URL.  These are overridden by any other parameters.
	 *
	 * @class
	 * @property {string} name
	 * @property {function} error
	 * @property {string} type
	 * @property {object} cache
	 * @property {Array<ParamInput>} params
	 * @property {object} locks
	 * @property {Array<function>} subscribers
	 * @property {boolean} guessColumnTypes
	 */

	var Source = makeSubclass('Source', Object, function (spec, params, userTypeInfo, opts) {
		var self = this;

		self.name = spec.name; // The name of the data source, by which it can be addressed later.
		self.error = spec.error; // Error reporting function.
		self.type = spec.type; // Where we're getting the data from.
		self.cache = {};
		self.params = params;
		self.locks = {};
		self.opts = opts || {};

		underscore.defaults(self.opts, {
			deferDecoding: true,
			passThroughParams: false
		});

		self.eventHandlers = {};
		underscore.each(underscore.keys(Source.events), function (evt) {
			self.eventHandlers[evt] = [];
		});

		self.guessColumnTypes = true;

		if (underscore.isArray(userTypeInfo)) {
			self.userTypeInfo = underscore.indexBy(userTypeInfo, 'field');
		}
		else {
			self.userTypeInfo = userTypeInfo;
		}

		if (Source.sources[self.type] === undefined) {
			throw new SourceError('Unsupported data source type: ' + self.type);
		}

		self.origin = new Source.sources[self.type](spec, userTypeInfo, self);

		var checkConversionArray = function (convs, field) {
			// Check the validity of all the specified conversions.
			//
			//   * If identified by name:
			//
			//     1. The name must already be registered in `Source.converters`
			//     2. The registered converter must be a function
			//
			//   * Otherwise it needs to be a function.

			underscore.each(convs, function (c, i) {
				if (typeof c === 'string') {
					if (Source.converters[c] === undefined) {
						throw new SourceError('Conversion' + (field ? ' for field "' + field + '", ' : '') + ' #' + i + ': Named converter "' + c + '" not registered');
					}

					if (typeof Source.converters[c] !== 'function') {
						throw new SourceError('Conversion' + (field ? ' for field "' + field + '", ' : '') + ' #' + i + ': Named converter "' + c + '" is not a function');
					}
				}
				else if (typeof c !== 'function') {
					throw new SourceError('Invalid Source config: `.conversion' + (field ? '[' + field + ']' : '') + '[' + i + ']` must be a function or string');
				}
			});
		};

		if (underscore.isArray(spec.conversion)) {
			checkConversionArray(spec.conversion);
		}
		else {
			underscore.each(spec.conversion, function (convs, field) {
				checkConversionArray(convs, field);
			});
		}

		self.conversion = spec.conversion;

		self.locks.getData = new Lock(self.getDebugTag() + ' // GET DATA');
		self.locks.refresh = new Lock(self.getDebugTag() + ' // REFRESH');
	});

	// Mixins {{{2

	mixinEventHandling(Source, [
			'fetchDataBegin'
		, 'fetchDataEnd'
		, 'fetchDataCancel'
		, 'dataUpdated'
		, 'getTypeInfo'
	]);

	mixinDebugging(Source);

	// Event JSDoc {{{2

	/**
	 * Fired when we start fetching data from the origin.
	 *
	 * @event Source#fetchDataBegin
	 */

	/**
	 * Fired when we've received data from the origin.
	 *
	 * @event Source#fetchDataEnd
	 */

	/**
	 * Fired when new data is available.
	 *
	 * @event Source#dataUpdated
	 */

	/**
	 * Fired when new type information is available.
	 *
	 * @event Source#getTypeInfo
	 */

	// .sources {{{2

	/**
	 * A map of source types to the classes that implement them.
	 */

	Source.sources = {
		local: LocalSource,
		http: HttpSource,
		file: FileSource
	};

	// .converters {{{2

	Source.converters = {};

	// #getName {{{2

	Source.prototype.getName = function () {
		var self = this;

		if (typeof self.origin.getName === 'function') {
			return self.origin.getName();
		}
	};

	// #getData {{{2

	/**
	 * Evaluate the data source, if necessary, and pass along the data that was obtained from it.  The
	 * data will be cached so that subsequent invocations don't re-evaluate the data source.
	 *
	 * @method
	 *
	 * @param {Source~getData_cb} cont Continuation function.
	 */

	Source.prototype.getData = function (cont) {
		var self = this;

		if (self.locks.getData.isLocked()) {
			return self.locks.getData.onUnlock(function () {
				return self.getData(cont);
			});
		}

		if (self.cache.data != null) {
			return cont(true, self.cache.data);
		}

		self.locks.getData.lock();
		self.fire('fetchDataBegin', {async: true});
		return self.origin.getData(self.createParams(), function (ok, data) {
			if (!ok) {
				self.locks.getData.unlock();
				self.fire('fetchDataEnd', {async: true});
				return cont(false);
			}

			{
				self.postProcess(data, function (finalData) {
					self.cache.data = finalData;
					self.locks.getData.unlock();
					self.fire('fetchDataEnd', {async: true});
					return cont(true, finalData);
				});
			}
		});
	};

	// #getUniqueVals {{{2

	/**
	 * Provide unique element information.
	 *
	 * @method
	 *
	 * @param {Source~getUniqElts_cb} cont Continuation function.
	 */

	Source.prototype.getUniqueVals = function (cont) {
		var self = this;

		if (self.cache.uniqElts != null) {
			return cont(self.cache.uniqElts);
		}

		self.getData(function (ok, data) {
			var uniqElts = {};
			var tmp = {};

			if (!ok) {
				return cont({});
			}

			underscore.each(data, function (row) {
				underscore.each(row, function (cell, field) {
					if (uniqElts[field] === undefined) {
						uniqElts[field] = {
							count: 0,
							values: []
						};
						tmp[field] = {};
					}

					if (tmp[field][cell.value] === undefined) {
						tmp[field][cell.value] = true;
						uniqElts[field].count += 1;
						uniqElts[field].values.push(cell.value);
					}
				});
			});

			underscore.each(uniqElts, function (obj) {
				obj.values.sort();
			});

			self.cache.uniqElts = uniqElts;
			return cont(self.cache.uniqElts);
		});
	};

	// #getTypeInfo {{{2

	/**
	 * @param {Source~getTypeInfo_cb} cont Continuation function.
	 */

	Source.prototype.getTypeInfo = function (cont) {
		var self = this;

		if (self.cache.typeInfo != null) {
			return cont(true, self.cache.typeInfo);
		}

		return self.origin.getTypeInfo(function (ok, typeInfo) {
			if (!ok) {
				return cont(false);
			}

			// When the type information for a field is just a string, then that's the same as setting it as
			// the 'type' property of the full object.

			typeInfo.each(function (v, k) {
				if (typeof v === 'string') {
					v = {
						'type': v
					};
					typeInfo.set(k, v);
				}
				v.field = k;
				v.overridden = false;
			});

			// Merge user-specified type information with whatever we got from the source.

			if (self.userTypeInfo != null) {
				underscore.each(self.userTypeInfo, function (userFti, field) {
					if (!typeInfo.isSet(field)) {
						log.warn('Overriding type information on field "' + field + '" which is not present in the source.');
						typeInfo.set(field, {});
					}

					// Just a string for the value is a shortcut for specifying the type.
					// EXAMPLE: {field1: 'number'} => {field1: {type: 'number'}}

					if (typeof userFti === 'string') {
						userFti = { type: userFti };
					}

					var fti = typeInfo.get(field);

					// Mark when the type is overridden by the user, so we don't try to guess it later.

					if (userFti.type != null) {
						fti.overridden = true;
					}

					underscore.extend(fti, userFti);

					self.debug('GET TYPE INFO', 'Overriding origin type information { field = "' + field + '", typeInfo = %O }', userFti);
				});
			}

			self.cache.typeInfo = typeInfo;
			self.debug('GET TYPE INFO', 'Type Info = %O', deepCopy(self.cache.typeInfo.asMap()));

			self.fire(Source.events.getTypeInfo, null, self.cache.typeInfo, self);
			return cont(true, self.cache.typeInfo);
		});
	};

	// #getDisplayName {{{2

	Source.prototype.getDisplayName = function (cont) {
		var self = this;

		if (self.cache.displayName != null) {
			return cont(self.cache.displayName);
		}

		if (self.origin.getDisplayName != null) {
			return self.origin.getDisplayName(function (displayName) {
				self.cache.displayName = displayName;
				return cont(self.cache.displayName);
			});
		}
		else {
			self.cache.displayName = {};
			return cont(self.cache.displayName);
		}
	};

	// #postProcess {{{2

	Source.prototype.postProcess = function (data, cont) {
		var self = this;

		if (data == null) {
			throw new SourceError('Data Source / Post Process / Received nothing');
		}
		else if (!underscore.isArray(data)) {
			throw new SourceError('Data Source / Post Process / Data is not an array');
		}

		self.debug('POST-PROCESSING', 'Beginning post-processing');

		self.getTypeInfo(function (ok, typeInfo) {
			if (!ok) {
				return cont(data);
			}

			self.debug('POST-PROCESSING', 'Received type info from source origin: %O', typeInfo.asMap());

			typeInfo.each(function (fti) {
				if (fti.type == null) {
					fti.type = 'string';
				}
			});

			// Post-processing involves converting the data received from the source into a form that will
			// be used internally for sorting, filtering, and display.  This takes several steps.
			//
			//   #1 - User conversion functions.  These go first because they can alter the value and type
			//        information.  (For example, turning all strings starting with "$" into currency.)
			//
			//   #2 - Decide whether type conversion is necessary and should be deferred.
			//
			//   #3 - Perform type conversion for non-deferred fields.

			// Gather the user's conversion functions, which will be applied on every row.  Conversion
			// functions can be applied across all fields (specified as an array), or on a per-field basis
			// (specified as an object with field name keys and array values).

			var conversionFuncs = {};
			typeInfo.each(function (fti, fieldName) {
				conversionFuncs[fieldName] = self.getConversionFuncs(fieldName);
			});

			// Step #1 - Perform all user conversion functions.

			underscore.each(data, function (row, rowNum) {
				underscore.each(row, function (val, field) {
					var fti = typeInfo.get(field);
					var cell = {
						value: val
					};

					if (conversionFuncs[field] != null) {
						var conversionFuncOpts = {
							row: row,
							source: self,
							rowNum: rowNum,
							totalRows: data.length
						};

						// Go through all the user's conversion functions.

						for (var i = 0; i < conversionFuncs[field].length; i += 1) {
							if (conversionFuncs[field][i](cell, field, fti, conversionFuncOpts)) {
								break;
							}
						}
					}

					row[field] = cell;
				});
			});

			self.guessTypes(data, typeInfo);

			// Step #2 - Update the type information with whether the internal representation (i.e. numeral
			// or moment) conversion of a field should be deferred or not.

			self.setConversionTypeInfo(data, typeInfo);

			// Step #3 - Unless conversion has been deferred on this field, convert it into the appropriate
			// internal representation (numeral or moment).

			underscore.each(data, function (row, rowNum) {
				underscore.each(row, function (val, field) {
					var fti = typeInfo.get(field);

					if (fti != null && !fti.deferDecoding) {
						convert(row[field], fti);
					}
				});
			});

			self.debug('POST-PROCESSING', 'Post-processing finished');

			return cont(data);
		});
	};

	// #determineConversionFuncs {{{2

	Source.prototype.getConversionFuncs = function (fieldName) {
		var self = this
			, conversionFuncs = [];

		var addConversionFuncs = function (convs) {
			underscore.each(convs, function (c, i) {
				if (typeof c === 'function') {
					conversionFuncs.push(c);
				}
				else if (typeof c === 'string') {
					conversionFuncs.push(Source.converters[c]);
				}
			});
		};

		if (self.conversion !== undefined) {
			if (underscore.isArray(self.conversion)) {
				addConversionFuncs(self.conversion);
			}
			else if (self.conversion[fieldName] !== undefined) {
				addConversionFuncs(self.conversion[fieldName]);
			}
		}

		return conversionFuncs;
	};

	// #guessTypes {{{2

	Source.prototype.guessTypes = function (data, typeInfo) {
		var self = this;

		typeInfo.each(function (fti, f) {
			if (fti.overridden || fti.type !== 'string') {
				return;
			}

			self.debug('CONVERSION // TYPE GUESSING', 'Guessing type for field "%s"', fti.field);

			var guess = null;

			for (var i = 0; guess !== 'string' && i < data.length; i += 1) {
				var val = data[i][f].value;
				var newGuess = stringValueType(val);

				if (guess == null) {
					guess = newGuess;
				}
				else if (newGuess !== guess) {
					self.debug('CONVERSION // TYPE GUESSING', 'For field "%s", previous guess "%s" disagrees with current guess "%s" (rowNum = %d, value = %O)', f, guess, newGuess, i, val);
					guess = 'string';
				}
			}

			if (guess != null && guess !== 'string') {
				self.debug('CONVERSION // TYPE GUESSING', 'For field "%s", successfully guessed new type "%s"', f, guess);
				fti.type = guess;
			}
		});
	};

	// #setConversionTypeInfo {{{2

	Source.prototype.setConversionTypeInfo = function (data, typeInfo) {
		var self = this;

		typeInfo.each(function (fti, f) {
			if (fti.type === 'string') {
				fti.internalType = 'string';
			}
			else if (['number', 'currency', 'date', 'datetime'].indexOf(fti.type) >= 0) {
				fti.deferDecoding = self.opts.deferDecoding;

				if (fti.type === 'number' || fti.type === 'currency') {
					fti.needsDecoding = true;
					if (fti.internalType == null) {
						if (fti.type === 'currency') {
							fti.internalType = 'bignumber';
						}
						else {
							fti.internalType = 'primitive';
						}
					}
					else if (['primitive', 'numeral', 'bignumber'].indexOf(fti.internalType) < 0) {
						log.error('Invalid internalType "' + fti.internalType + '" requested for field "' + fti.field + '" - falling back to "primitive" instead');
						fti.internalType = 'primitive';
					}
				}
				else if (fti.type === 'date' || fti.type === 'datetime') {
					if ((fti.type === 'date' && (fti.format === undefined || fti.format === 'YYYY-MM-DD'))
							|| (fti.type === 'datetime' && (fti.format === undefined || fti.format === 'YYYY-MM-DD HH:mm:ss'))) {
						// The values are dates and/or times where the lexicographic sort is also chronological.
						// So, there's no need to convert them to any special value internally to support sorting.
						fti.internalType = 'string';
					}
					else {
						fti.needsDecoding = true;
						fti.internalType = 'moment';
					}
				}

				if (fti.deferDecoding) {
					self.debug('CONVERSION', 'Deferring conversion until <%s> { field = "%s", type = "%s", format = "%s" }',
						fti.needsDecoding ? 'SORT' : 'DISPLAY', f, fti.type, fti.format);
				}
			}
		});
	};

	// #convertAll {{{2

	Source.prototype.convertAll = function (data, field) {
		var self = this;
		var fti = self.cache.typeInfo.get(field);

		if (!fti.needsDecoding) {
			return;
		}

		self.debug('CONVERSION', 'Converting all values: field = "%s" ; type = %s ; internalType = %s ; valueTypeOf = %s', field, fti.type, fti.internalType, typeof(getProp(data, 0, field, 'value')));

		underscore.each(data, function (row) {
			convert(row[field], self.cache.typeInfo.get(field));
		});

		fti.deferDecoding = false;
		fti.needsDecoding = false;
	};

	// #clearCachedData {{{2

	/**
	 * Removes the cache of data, type information, unique elements, and display names.  This is also
	 * needed to force the data source to re-evalute its parameter inputs.  The next call to getData()
	 * et al. will re-evaluate the underlying data source.
	 *
	 * @method
	 */

	Source.prototype.clearCachedData = function () {
		var self = this;

		if (typeof self.origin.clearCachedData === 'function') {
			self.origin.clearCachedData();
		}

		self.cache = {};

		self.fire('dataUpdated');
	};

	// #refresh {{{2

	Source.prototype.refresh = function () {
		var self = this;

		// When locked, a data updated is already in progress.  Just wait and it will notify clients to
		// re-pull the data from us.

		if (self.locks.refresh.isLocked()) {
			return;
		}

		self.debug(null, 'Refreshing...');

		self.locks.refresh.lock();

		if (typeof self.origin.clearCachedData === 'function') {
			self.origin.clearCachedData();
		}

		var tmp = self.cache;
		self.cache = {};

		self.getData(function (ok) {
			self.locks.refresh.unlock();
			if (ok) {
				self.fire('dataUpdated');
			}
			else {
				// Restore cached data.  Not sure if this is really necessary because the View should have its
				// own reference to this data.
				self.cache = tmp;
			}
		});
	};

	// #createParams {{{2

	/**
	 * Create a parameters object from the ParamInput instances currently bound to this data source.
	 * This is an internal method used when the user calls getData().  For system reports, it helps
	 * build the object used by jQuery to set the CGI parameters for the HTTP GET request.
	 *
	 * @method
	 *
	 * @returns {object} The CGI parameters needed for running a system report.
	 */

	Source.prototype.createParams = function () {
		var self = this
			, obj = {};

		if (self.opts.passThroughParams) {
			obj = getParamsFromUrl();
		}

		underscore.each(self.params, function (p) {
			self.debug('CREATE PARAMS', 'Parameter =', p);
			p.toParams(obj);
		});

		self.debug('CREATE PARAMS', 'Final Parameters =', obj);

		// The JSON clause parameters will be objects that need to be serialized first, so they can be
		// sent to the server and unpacked there.

		if (obj.report_json_where != null) {
			obj.report_json_where = JSON.stringify(obj.report_json_where);
		}

		if (obj.report_json_having != null) {
			obj.report_json_having = JSON.stringify(obj.report_json_having);
		}

		return obj;
	};

	// #swapRows {{{2

	/**
	 *
	 */

	Source.prototype.swapRows = function (oldIndex, newIndex) {
		var self = this;

		if (self.cache.data === undefined) {
			throw new SourceError('Attempted to swap rows before retrieving data');
		}

		var temp = self.cache.data.splice(oldIndex, 1);
		self.cache.data.splice(newIndex, 0, temp[0]);
		//for (var i=0; i<self.cache.data.length; i++) {
		//	self.cache.data[i].position=i;
		//}
	};

	// #isCancellable {{{2

	/**
	 * Indicates that retrieving data from the origin is cancellable via the `cancel()` method.
	 *
	 * @returns {boolean}
	 * True if the `cancel()` method works, false otherwise.
	 */

	Source.prototype.isCancellable = function () {
		var self = this;

		return typeof self.origin.cancel === 'function';
	};

	// #cancel {{{2

	/**
	 * Cancel retrieval of the data from the origin.
	 */

	Source.prototype.cancel = function () {
		var self = this;

		if (typeof self.origin.cancel === 'function') {
			self.origin.cancel();
			self.locks.getData.clear();
			self.locks.refresh.clear();
			self.fire('fetchDataCancel');
		}
	};

	// #toString {{{2

	Source.prototype.toString = function () {
		var self = this;

		return 'Source <' + self.name + ', ' + self.type + '>';
	};

	// #getDebugTag {{{2

	Source.prototype.getDebugTag = function () {
		var self = this;
		return 'SOURCE {name="' + self.name + '", type=' + self.type + '}';
	};

	// #setToolbar {{{2

	Source.prototype.setToolbar = function (toolbar) {
		var self = this;

		self.toolbar = toolbar;

		if (typeof self.origin.setToolbar === 'function') {
			self.origin.setToolbar(toolbar);
		}
	};

	/**
	 * The jQuery plugin namespace.
	 * @external "jQuery.fn"
	 * @see {@link http://learn.jquery.com/plugins/|jQuery Plugins}
	 */

	jQuery.fn.extend({

		/**
		 * Tells whether the element is checked.
		 *
		 * @function external:"jQuery.fn"#_isChecked
		 *
		 * @returns {boolean}
		 * True if the element is checked, false if it's not.
		 */

		_isChecked: function () {
			return this.prop('checked');
		},

		/**
		 * Checks a checkbox.
		 *
		 * @function external:"jQuery.fn"#_check
		 *
		 * @returns {boolean}
		 * True if the element is now checked, false if it's not.
		 */

		_check: function () {
			this.prop('checked', true);
		},

		/**
		 * Unchecks a checkbox.
		 *
		 * @function external:"jQuery.fn"#_uncheck
		 */

		_uncheck: function () {
			this.prop('checked', false);
		},

		/**
		 * Toggles the checkbox.
		 *
		 * @function external:"jQuery.fn"#_toggleCheck
		 *
		 * @returns {boolean}
		 * True if the element is now checked, false if it's not.
		 */

		_toggleCheck: function () {
			var newValue = !this.prop('checked');
			this.prop('checked', newValue);
			return newValue;
		},

		/**
		 * Tells whether the element is disabled.
		 *
		 * @function external:"jQuery.fn"#_isDisabled
		 *
		 * @returns {boolean}
		 * True if the element is disabled, false if it's not.
		 */

		_isDisabled: function () {
			return this.attr('disabled');
		},

		/**
		 * Tells whether the element is hidden.
		 *
		 * @function external:"jQuery.fn"#_isHidden
		 *
		 * @returns {boolean}
		 * True if the element is hidden, false if it's visible.
		 */

		_isHidden: function () {
			return this.css('display') === 'none' || this.css('visibility') !== 'visible';
		},

		_addTrailing: function (chars) {
			var t = this.text();
			if (t.slice(chars.length * -1) !== chars){
				this.text(t + chars);
			}
		},

		_stripTrailing: function (chars) {
			var t = this.text();
			if (t.slice(chars.length * -1) === chars) {
				this.text(t.slice(0, chars.length * -1));
			}
		},

		// _makeIconCheckbox('foo') -->
		//   off = fontawesome('foo'), class = 'wcdv_icon_checkbox_off'
		//   on = fontawesome('foo'), class = 'wcdv_icon_checkbox_on'
		// _makeIconCheckbox('foo', 'bar') -->
		//   off = fontawesome('foo')
		//   on = fontawesome('bar')
		// _makeIconCheckbox(obj) -->
		//   off = fontawesome(obj.off.icon), class = obj.off.classes
		//   on = fontawesome(obj.on.icon), class = obj.on.classes

		_makeIconCheckbox: function () {
			var self = this
				, args = Array.prototype.slice.call(arguments)
				, opts = {};

			if (args.length === 1) {
				if (typeof args[0] === 'string') {
					opts = {
						on: {
							icon: args[0],
							classes: 'wcdv_icon_checkbox_on'
						},
						off: {
							icon: args[0],
							classes: 'wcdv_icon_checkbox_off'
						}
					};
				}
				else {
					opts = args[0];
				}
			}
			else if (args.length === 2) {
				opts = {
					on: {
						icon: args[0]
					},
					off: {
						icon: args[1]
					}
				};
			}

			var button = jQuery('<button>', {
				'type': 'button',
				'disabled': jQuery(self).prop('disabled'),
				'title': self.attr('title')
			})
				.addClass('wcdv_icon_button wcdv_button_left')
				.on('click', function () {
					self._toggleCheck();
					self.trigger('change');
				})
			;

			var onIcon = fontAwesome(opts.on.icon, opts.on.classes).css('display', 'inline-block').hide().appendTo(button);
			var offIcon = fontAwesome(opts.off.icon, opts.off.classes).css('display', 'inline-block').hide().appendTo(button);

			var updateIcon = function () {
				if (self._isChecked()) {
					onIcon.show();
					offIcon.hide();
					if (opts.on.tooltip != null) {
						button.attr('title', opts.on.tooltip);
					}
				}
				else {
					onIcon.hide();
					offIcon.show();
					if (opts.off.tooltip != null) {
						button.attr('title', opts.off.tooltip);
					}
				}
			};

			updateIcon();
			self.hide();
			self.before(button);
			self.on('change', updateIcon);
			self._updateIcon = updateIcon;

			return self;
		},

		/**
		 * Adds debugging output for jQuery UI behavior events.
		 *
		 * @function external:"jQuery.fn"#_addEventDebugging
		 *
		 * @param {string} what
		 * The behavior to output debugging info for.  Must be: drag, drop, or sort.
		 *
		 * @param {string} tag
		 * Prefix to output at the beginning of the debug message.
		 */

		_addEventDebugging: function (what, tag) {
			switch (what) {
			case 'drag':
				this.on('dragstart', function (evt, ui) {
					console.log('### ' + tag + ' > DRAG.START: evt = %O, ui = %O', evt, ui);
				});
				this.on('dragstop', function (evt, ui) {
					console.log('### ' + tag + ' > DRAG.STOP: evt = %O, ui = %O', evt, ui);
				});
				break;
			case 'drop':
				this.on('dropactivate', function (evt, ui) {
					console.log('### ' + tag + ' > DROP.ACTIVATE: evt = %O, ui = %O', evt, ui);
				});
				this.on('dropdeactivate', function (evt, ui) {
					console.log('### ' + tag + ' > DROP.DEACTIVATE: evt = %O, ui = %O', evt, ui);
				});
				this.on('drop', function (evt, ui) {
					console.log('### ' + tag + ' > DROP.DROP: evt = %O, ui = %O', evt, ui);
				});
				break;
			case 'sort':
				this.on('sortreceive', function (evt, ui) {
					console.log('### ' + tag + ' > SORT.RECEIVE: evt = %O, ui = %O', evt, ui);
				});
				this.on('sortremove', function (evt, ui) {
					console.log('### ' + tag + ' > SORT.REMOVE: evt = %O, ui = %O', evt, ui);
				});
				this.on('sortstart', function (evt, ui) {
					console.log('### ' + tag + ' > SORT.START: evt = %O, ui = %O', evt, ui);
				});
				this.on('sortstop', function (evt, ui) {
					console.log('### ' + tag + ' > SORT.STOP: evt = %O, ui = %O', evt, ui);
				});
				this.on('sortactivate', function (evt, ui) {
					console.log('### ' + tag + ' > SORT.ACTIVATE: evt = %O, ui = %O', evt, ui);
				});
				this.on('sortdeactivate', function (evt, ui) {
					console.log('### ' + tag + ' > SORT.DEACTIVATE: evt = %O, ui = %O', evt, ui);
				});
				this.on('sortupdate', function (evt, ui) {
					console.log('### ' + tag + ' > SORT.UPDATE: evt = %O, ui = %O', evt, ui);
				});
				break;
			default:
				throw new Error('Call Error: Event type must be one of: ["drag", "drop", "sort"]');
			}
			return this;
		},

		/**
		 * Make this element draggable.
		 *
		 * @function external:"jQuery.fn"#_makeDraggableField
		 *
		 * @param {object} [opts]
		 * Change options passed to `draggable()`.
		 */

		_makeDraggableField: function (opts) {
			opts = deepDefaults(true, {
				classes: {
					'ui-draggable-handle': 'wcdv_drag_handle'
				},
				distance: 8, // FIXME Deprecated [1.12]: replacement will be in 1.13
				helper: 'clone',
				appendTo: document.body,
				revert: true,
				revertDuration: 0
			});
			this.attr('title', 'XXX'); // FIXME Without this, the 'content' property below does nothing!
			var tooltipContent = jQuery('<div>')
				.append(fontAwesome('fa-info-circle').css('padding-right', '0.25em').addClass('wcdv_text-primary'))
				.append('You can drag & drop this field into the grid controls above to filter, group or pivot.');
			this.tooltip({
				classes: {
					'ui-tooltip': 'ui-corner-all ui-widget-shadow wcdv_info_tooltip wcdv_border-primary'
				},
				show: { delay: 2000 },
				content: tooltipContent
			});
			return this
				.draggable(opts);
		},

		_makeSortableTable: function (cb) {
			var self = this;

			var helperClone = function (e, tr) {
				var originals = tr.children(),
					clonedRow = tr.clone(),
					start_idx = tr.index(),
					all_rows = tr.parent().children(),
					all_select = tr.find('select');

				// first set the size of the row that was cloned (clonedRow).
				// This keeps the table rows shape.
				clonedRow.children().each(function(index, val) {
					jQuery(val).width(originals.eq(index).width());
					//_.each(['box-sizing'], function (cssProp) {
					//	jQuery(val).css(cssProp, originals.eq(index).css(cssProp));
					//});
				});
				// second set the 'selected' value of any selects
				// found during the clone.  Seems jquery has a
				// bug that will not be fixed.
				clonedRow.find('select').val(function(index) {
					return all_select.eq(index).val();
				});
				// third lets place a temp class on all the rows
				// to keep the zerba striping, during the drag
				for (var i = start_idx+1; i < all_rows.length; i++) {
					if ((i % 2) == 0) {
						// this row should really be even but because
						// the clonedRow is hidden we need to make it
						// odd to avoid the 'shifting of colors in the zebra'
						jQuery(all_rows[i]).addClass('odd');
					} else {
						jQuery(all_rows[i]).addClass('even');
					}
				}
				// lastly put the correct zebra strip on the cloned row
				// that gets dragged around
				if ((start_idx % 2) == 0) {
					clonedRow.addClass('odd');
				} else {
					clonedRow.addClass('even');
				}
				return clonedRow;
			};

			self.on('keydown', 'button.drag-handle', function (event) {
				var tr = jQuery(event.currentTarget).closest('tr'),
					oldIndex = tr.index(),
					newIndex = oldIndex;

				// Reposition if one of the directional keys is pressed
				switch (event.keyCode) {
				case 38: // Up
					event.preventDefault();
					if (tr.prev().length) {
						tr.insertBefore(tr.prev());
					} else {
						// already at the top so exit
						return true;
					}
					break;
				case 40: // Down
					event.preventDefault();
					if (tr.next().length) {
						tr.insertAfter(tr.next());
					} else {
						// already at the bottom so exit
						return true;
					}
					break;
				default:
					return true; // Exit
				}
				newIndex = tr.index();
				if (oldIndex !== newIndex) {
					cb(oldIndex, newIndex);
				}
				// keep focus on the button after move
				jQuery(event.currentTarget).focus();
			});

			var opts = {
				forcePlaceholderSize: true,
				axis: 'y',
				cancel: 'input,textarea,select,option',
				helper: helperClone,
				handle: '.drag-handle',
				containment: self,
				// This event is triggered when sorting starts.
				start: function(event, ui) {
					// set the height of the placeholder row on start
					ui.placeholder.height(ui.helper.height());
					ui.item.data('originIndex', ui.item.index());
				},
				// This event is triggered when sorting has stopped.
				stop: function(event, ui) {
					var oldIndex = ui.item.data('originIndex'),
						newIndex = ui.item.index();
					// the drag has stopped so remove the classes that 'override'
					// the even/odd strips
					ui.item.parent().children().removeClass('even odd');

					if ( (typeof oldIndex !== 'undefined') &&
						(typeof newIndex !== 'undefined') &&
						(oldIndex !== newIndex) ) {
						// swap the rows in our internal data structure
						cb(oldIndex, newIndex);
					} else {
						// strange some bad data so just call the 'cancel' method
						jQuery(this).sortable('cancel');
					}
				}
			};

			self.sortable(opts);

			return this;
		},

		/**
		 * Specify what to do when a file is dropped onto this element.
		 *
		 * ```
		 * $('#fileDropTarget')._onFileDrop(function (files) {
		 *   something.addFiles(files);
		 * });
		 * ```
		 *
		 * @function external:"jQuery.fn"#_onFileDrop
		 *
		 * @param {function} cb
		 * Function to call when the file is dropped; it is passed a `File` array.
		 */

		_onFileDrop: function (cb) {
			// https://www.html5rocks.com/en/tutorials/file/dndfiles/
			function handleFileSelect(evt) {
				evt.stopPropagation();
				evt.preventDefault();
				cb(evt.dataTransfer.files);
			}

			function handleDragOver(evt) {
				evt.stopPropagation();
				evt.preventDefault();

				// Things I've tried to determine file type in drag+drop:
				//
				//   evt.dataTransfer.items[0].type => MIME Type
				//
				// +---------+--------------------------------------+
				// | Browser | Result                               |
				// +=========+======================================+
				// | Chrome  | ** OK **                             |
				// | Firefox | ** OK **                             |
				// | IE11    | evt.dataTransfer.items doesn't exist |
				// | Safari  | evt.dataTransfer.items doesn't exist |
				// | Edge    | evt.dataTransfer.items[0].type = ''  |
				// +---------+--------------------------------------+
				//
				// Setting the dropEffect:
				//
				// +---------+-----------------------------+
				// | Browser | Result                      |
				// +=========+=============================+
				// | Chrome  | ** OK **                    |
				// | Firefox | ** OK **                    |
				// | IE11    | None (performs navigation)  |
				// | Safari  | ** OK **                    |
				// | Edge    | None (file always accepted) |
				// +---------+-----------------------------+

				evt.dataTransfer.dropEffect =
					getProp(evt.dataTransfer, 'items', 0, 'type') === 'text/csv' ? 'copy' : 'none';
			}

			this.get(0).addEventListener('dragover', handleDragOver, false);
			this.get(0).addEventListener('drop', handleFileSelect, false);
		},

		findFieldCell: function (field) {
			return this.children().filter(function (i, elt) {
				return jQuery(elt).attr('data-wcdv-field') === field;
			});
		}
	});

	/**
	 * @file
	 * Contains the implementation of "grid filters" which are the dynamically applied filters that are
	 * shown in the filter control of a grid.  They set the filter on the {@link View} associated with
	 * the {@link Grid}.
	 *
	 * If you're looking for the parameters that get sent to the {@link Source} then you want {@link
	 * source_param.js} instead.
	 *
	 * ## Classes
	 *
	 * - {@link GridFilter}
	 *   - {@link StringTextboxGridFilter}
	 *   - {@link StringDropdownGridFilterChosen}
	 *   - {@link StringDropdownGridFilterSumo}
	 *   - {@link NumberTextboxGridFilter}
	 *   - {@link NumberCheckboxGridFilter}
	 *   - {@link DateSingleGridFilter}
	 *   - {@link DateRangeGridFilter}
	 *   - {@link BooleanCheckboxGridFilter}
	 * - {@link GridFilterSet}
	 */

	// GridFilter {{{1

	// Superclass {{{2

	// Constructor {{{3

	/**
	 * Base class for all grid filter widgets.
	 *
	 * @class
	 *
	 * @property {string} field
	 *
	 * @property {GridFilterSet} gridFilterSet
	 *
	 * @property {object} opts
	 *
	 * @property {string} [opts.filterType]
	 *
	 * @property {string} [opts.filterButton]
	 * The button used to add a new filter.
	 *
	 * @property {string} [opts.noRemoveButton=false]
	 * If true, don't create a remove button to place next to the filter.
	 *
	 * @property {number} limit
	 *
	 * @property {boolean} applyImmediately
	 *
	 * @property {jQuery} div
	 *
	 * @property {jQuery} input
	 *
	 * @property {jQuery} removeBtn
	 *
	 * @property {string} id
	 *
	 */

	var GridFilter = (function () {
		var id = 0;

		var genId = function () {
			return 'GridFilter_' + id++;
		};

		return makeSubclass('GridFilter', Object, function (field, gridFilterSet, typeInfo, opts) {
			var self = this;
			var localRemoveButton;

			self.id = genId();
			self.field = field;
			self.gridFilterSet = gridFilterSet;
			self.typeInfo = typeInfo;
			self.opts = opts;

			self.limit = 0;
			self.applyImmediately = false;
			self.div = jQuery('<div>')
				.addClass('wcdv_filter_control_filter');

			if (self.opts.makeRemoveButton) {
				self.removeBtn = self.makeRemoveBtn();
				localRemoveButton = self.removeBtn;
			}
			else if (self.opts.removeButton) {
				localRemoveButton = self.opts.removeButton;
			}

			if (localRemoveButton) {
				localRemoveButton.on('click', function () {
					self.gridFilterSet.remove(self.getId(), self.opts.filterButton);
					if (typeof self.opts.onRemove === 'function') {
						self.opts.onRemove();
					}
				});
			}

			if (self.gridFilterSet.gridTable) {
				self.gridFilterSet.gridTable.on('columnResize', function () {
					self.adjustInputWidth({ useSizingElement: true, fromColumnResize: true });
				});
			}
		});
	})();

	// #getValue {{{3

	/**
	 * This represents an exact value to use with a filter operator to decide what to show in the grid.
	 *
	 * @typedef {string|Moment|Numeral} GridFilter~Value
	 */

	/**
	 * This represents a range of allowed values; anything within the range should be shown in the grid.
	 *
	 * @typedef {Object} GridFilter~RangeValue
	 *
	 * @property {GridFilter~Value} start The starting number / date in the range (inclusive).
	 * @property {GridFilter~Value} end The ending number / date in the range (inclusive).
	 */

	/**
	 * Gives the value that should be used when building the filters for the View from the user's
	 * input in the GridFilter.  A GridFilter can return either a single value (which should be combined
	 * with the operator, e.g. "greater than 40") or a range value (where the operators are implicitly
	 * greater-than-or-equal and less-than-or-equal, e.g. "between January 1st and March 31st").
	 *
	 * @returns {GridFilter~Value|GridFilter~RangeValue} The value of the filter; you can tell whether
	 * or not it will be a range by checking the result of #isRange().
	 */

	GridFilter.prototype.getValue = function () {
		var self = this
			, fti = self.gridFilterSet.view.typeInfo.get(self.field);

		switch (fti.type) {
		case 'date':
		case 'time':
		case 'datetime':
			if (self.input.val() === '') {
				return undefined;
			}
			return fti.internalType === 'moment' ? moment(self.input.val()) : self.input.val();
		case 'number':
		case 'currency':
			if (self.input.val() === '') {
				return undefined;
			}
			switch (fti.internalType) {
			case 'bignumber':
				return new bignumber(self.input.val());
			case 'numeral':
				return numeral(self.input.val());
			case 'primitive':
				return isInt(self.input.val()) ? toInt(self.input.val())
					: isFloat(self.input.val()) ? toFloat(self.input.val())
					: self.input.val();
			default:
				return self.input.val();
			}
		case 'string':
		default:
			return self.input.val();
		}
	};

	// #setValue {{{3

	GridFilter.prototype.setValue = function (val) {
		var self = this;

		if (numeral && numeral.isNumeral(val)) {
			self.input.val(val._value);
		}
		else {
			self.input.val(val);
		}
	};

	// #getOperator {{{3

	GridFilter.prototype.getOperator = function () {
		var self = this;

		return self.operatorDrop.val();
	};

	// #setOperator {{{3

	GridFilter.prototype.setOperator = function (op) {
		var self = this;

		if (self.operatorDrop) {
			self.operatorDrop.val(op);
		}
	};

	// #getId {{{3

	GridFilter.prototype.getId = function () {
		return this.id;
	};

	// #makeOperatorDrop {{{3

	/**
	 * Construct a SELECT that allows the user to pick the operator.
	 *
	 * @param {Array<string>} include If present, only include operators that correspond to those
	 * operations requested.  This should be an array like ``['$eq', '$ne']`` to only show equality and
	 * inequality operators.
	 */

	GridFilter.prototype.makeOperatorDrop = function (include) {
		var self = this;

		// These are all the operators that are possible.

		var operators = [['$contains', '∈'], ['$notcontains', '∉'], ['$eq', '='], ['$ne', '≠'], ['$gt', '>'], ['$gte', '≥'], ['$lt', '<'], ['$lte', '≤'], ['$in', 'in'], ['$nin', 'not in']];

		// Remove anything that user didn't ask for.

		if (include !== undefined && underscore.isArray(include)) {
			operators = underscore.reject(operators, function (elt) {
				return include.indexOf(elt[0]) < 0;
			});
		}

		var operatorDrop = jQuery('<select>');

		operatorDrop.css({'margin-right': '0.5em'});

		// Add all the operators as options within the <SELECT>.

		underscore.each(operators, function (op) {
			var value = op[0]
				, name = op[1];
			operatorDrop.append(jQuery('<option>', { value: value }).text(name));
		});

		// Hook up the event to update the filter when the operator is changed.

		operatorDrop.on('change', function () {
			if (self.getValue() !== '') {
				self.gridFilterSet.update(false);
			}
		});

		// Return the <SELECT> so that the caller can put it where they want.

		return operatorDrop;
	};

	// #makeRemoveBtn {{{3

	GridFilter.prototype.makeRemoveBtn = function () {

		var removeBtn = jQuery(fontAwesome('F00D', null, 'Click to remove filter'));

		removeBtn.css({'cursor': 'pointer', 'margin-left': '0.5em'});
		return removeBtn;
	};

	// #remove {{{3

	GridFilter.prototype.remove = function () {
		var self = this;

		self.div.remove();
		self.gridFilterSet.update(false);
	};

	// #isRange {{{3

	GridFilter.prototype.isRange = function () {
		return false;
	};

	// #adjustInputWidth {{{3

	GridFilter.prototype.adjustInputWidth = function (opts) {
		var self = this;

		if (!self.opts.autoUpdateInputWidth) {
			return;
		}

		if (opts === undefined) {
			opts = {};
		}

		// In case we're using TableTool, we need to carry around this idea of the sizing element.  At
		// this point in the JS execution, TableTool hasn't caught up and correctly resized the floating
		// header to match the original header column widths.  Therefore, we can't use `self.div` for
		// determining the correct width (it's the wrong size, because it's still in a column which is the
		// wrong size).  Instead, we need to use the sizing element - which is the original version of the
		// TH containing `self.div` - to determine the correct size.  TableTool will catch up later,
		// correctly resizing the column to align perfectly with what we set here.
		//
		// FIXME: This is extremely tightly coupled to knowledge about how the grid table is laid out and
		// what features it has (e.g. TableTool).  It would be better to pass in what the size of the
		// column currently is with the event handler.

		underscore.defaults(opts, {
			useSizingElement: false,
			input: self.input
		});

		debug.info('GRID FILTER // ADJUST INPUT WIDTH', '         Target: %O', opts.input);

		var targetWidth = opts.useSizingElement ? self.opts.sizingElement.width() : self.div.width();
		debug.info('GRID FILTER // ADJUST INPUT WIDTH', 'Available Space: ' + targetWidth + 'px ' + (opts.useSizingElement ? '[sizing element]' : '[div]'));

		if (self.removeBtn) {
			targetWidth -= self.removeBtn.outerWidth();
			debug.info('GRID FILTER // ADJUST INPUT WIDTH', '  Remove Button: ' + self.removeBtn.outerWidth() + 'px');
		}

		if (self.operatorDrop !== undefined) {
			targetWidth -= self.operatorDrop.outerWidth();
			debug.info('GRID FILTER // ADJUST INPUT WIDTH', '  Operator Drop: ' + self.operatorDrop.outerWidth() + 'px');
		}

		debug.info('GRID FILTER' + (opts.fromColumnResize ? ' // HANDLER (columnResize)' : ''), 'Adjusting ' + self.field + ' filter widget width to ' + targetWidth + 'px to match column width');

		opts.input.outerWidth(targetWidth);

		if (typeof opts.callback === 'function') {
			opts.callback(targetWidth);
		}
	};

	// StringTextboxGridFilter {{{2

	/**
	 * Represents a filter on a single string.
	 *
	 * @class
	 * @extends GridFilter
	 */

	var StringTextboxGridFilter = makeSubclass('StringTextboxGridFilter', GridFilter, function () {
		var self = this;

		self.ctor.apply(self, arguments);

		self.input = jQuery('<input type="text">');
		self.input.on('change', function (evt) {
			self.gridFilterSet.update(false);
		});

		self.operatorDrop = self.makeOperatorDrop(/*['$eq', '$ne']*/);

		/*
		self.strictChkbox = jQuery('<input>', {id: gensym(), type: 'checkbox'})
			.on('change', function () {
				self.gridFilterSet.update();
			});
			*/

		self.div
			.append(self.operatorDrop)
			.append(self.input);

		if (self.removeBtn) {
			self.div.append(self.removeBtn);
		}
	});

	// StringDropdownGridFilterChosen {{{2

	/**
	 * Represents a filter for multiple strings.
	 *
	 * @class
	 * @extends GridFilter
	 */

	var StringDropdownGridFilterChosen = makeSubclass('StringDropdownGridFilterChosen', GridFilter, function () {
		var self = this;

		GridFilter.apply(self, arguments);

		self.super = makeSuper(self, GridFilter);
		self.limit = 1;
		self.input = jQuery('<select>').attr({
			'multiple': true
		});
		self.input.on('change', function (evt) {
			self.gridFilterSet.update(false);
		});

		self.div
			.append(self.input);

		if (self.removeBtn) {
			self.div.append(self.removeBtn);
		}

		self.afterAdd = function (target) {
			self.gridFilterSet.view.getUniqueVals(function (uniqueVals) {
				underscore.each(getPropDef([], uniqueVals, self.field, 'values'), function (val) {
					jQuery('<option>').attr({
						'value': val
					}).text(val).appendTo(self.input);
				});
				self.input.chosen({'width': self.div.innerWidth() - self.removeBtn.outerWidth()});
				self.chosen = self.input.next('div.chosen-container');
			});
		};

		if (self.gridFilterSet.gridTable) {
			self.gridFilterSet.gridTable.on('columnResize', function () {
				var targetWidth = self.opts.sizingElement.innerWidth() - self.removeBtn.outerWidth() - 14;
				debug.info('GRID FILTER // HANDLER (GridTablePlain.columnResize)', 'Adjusting Chosen widget width to ' + targetWidth + 'px to match column width');
				self.chosen.innerWidth(targetWidth);
			});
		}
	});

	// #getOperator {{{3

	StringDropdownGridFilterChosen.prototype.getOperator = function () {
		return '$in';
	};

	// #getValue {{{3

	StringDropdownGridFilterChosen.prototype.getValue = function () {
		var self = this
			, val = self.super.getValue(self);

		return val === null ? undefined : val;
	};

	// StringDropdownGridFilterSumo {{{2

	/**
	 * Represents a filter for multiple strings.
	 *
	 * @class
	 * @extends GridFilter
	 */

	var StringDropdownGridFilterSumo = makeSubclass('StringDropdownGridFilterSumo', GridFilter, function () {
		var self = this;

		GridFilter.apply(self, arguments);

		self.super = makeSuper(self, GridFilter);
		self.limit = 1;
		self.minDropdownWidth = 200;
		self.input = jQuery('<select>').attr({
			'multiple': true
		})
			.on('change', function (evt) {
				if (self.pleaseDontFireChangeEvent) {
					delete self.pleaseDontFireChangeEvent;
					return;
				}
				self.gridFilterSet.update(false);
			});

		self.operatorDrop = self.makeOperatorDrop(['$in', '$nin']);

		self.div.append(self.operatorDrop);
		self.div.append(self.input);

		if (self.removeBtn) {
			self.div.append(self.removeBtn);
		}

		self.afterAdd = function (target) {
			self.gridFilterSet.view.getUniqueVals(function (uniqueVals) {
				underscore.each(getPropDef([], uniqueVals, self.field, 'values'), function (val) {
					jQuery('<option>').attr({
						'value': val
					}).text(val === '' ? '[blank]' : val).appendTo(self.input);
				});
				self.input.SumoSelect({
					triggerChangeCombined: true,
					selectAll: true,
					search: true,
					okCancelInMulti: true,
					isClickAwayOk: true
				});
				self.optWrapper = self.input.closest('div.SumoSelect').find('div.optWrapper');
				/*
				optWrapper.resizable({
					helper: 'ui-resizable-helper'
				});
				*/
				//self.adjustInputWidth();
			});
		};
	});

	// #adjustInputWidth {{{3

	StringDropdownGridFilterSumo.prototype.adjustInputWidth = function (opts) {
		var self = this;

		if (opts === undefined) {
			opts = {};
		}

		opts.input = self.input.closest('div.SumoSelect');
		opts.callback = function (width) {
			self.optWrapper.outerWidth(Math.max(width, self.minDropdownWidth));
		};

		self.super.adjustInputWidth(opts);
	};

	// #getValue {{{3

	StringDropdownGridFilterSumo.prototype.getValue = function () {
		var self = this
			, val = self.super.getValue();

		return val === null ? undefined : val;
	};

	// #setValue {{{3

	StringDropdownGridFilterSumo.prototype.setValue = function (val) {
		var self = this;

		if (!underscore.isArray(val)) {
			val = [val];
		}

		underscore.each(val, function (v) {
			self.pleaseDontFireChangeEvent = true;
			self.input.get(0).sumo.selectItem(v);
		});
	};

	// #setOperator {{{3

	StringDropdownGridFilterSumo.prototype.setOperator = function (op) {
		var self = this;

		if (op === '$eq') {
			op = '$in';
		}

		return self.super.setOperator(op);
	};


	// NumberTextboxGridFilter {{{2

	var NumberTextboxGridFilter = makeSubclass('NumberTextboxGridFilter', GridFilter, function () {
		var self = this;

		GridFilter.apply(self, arguments);

		self.input = jQuery('<input>', {
			'type': 'text'
		});
		self.input.attr('size', '10');
		self.input.on('change', function (evt) {
			self.gridFilterSet.update(false);
		});

		self.operatorDrop = self.makeOperatorDrop(['$eq', '$ne', '$lt', '$lte', '$gt', '$gte']);

		self.div.append(self.operatorDrop);
		self.div.append(self.input);

		if (self.removeBtn) {
			self.div.append(self.removeBtn);
		}
	});

	// NumberCheckboxGridFilter {{{2

	var NumberCheckboxGridFilter = makeSubclass('NumberCheckboxGridFilter', GridFilter, function () {
		var self = this;

		GridFilter.apply(self, arguments);

		self.input = jQuery('<input>', {'id': gensym(), 'type': 'checkbox'});
		self.input.on('change', function () {
			self.gridFilterSet.update(false);
		});

		self.div
			.append(jQuery('<label>')
							.append(self.input)
							.append(' Filter'));

		if (self.removeBtn) {
			self.div.append(self.removeBtn);
		}

		//self.applyImmediately = true;
		self.limit = 1;
	});

	// #getValue {{{3

	NumberCheckboxGridFilter.prototype.getValue = function () {
		return this.input[0].checked ? 1 : 0;
	};

	// #getOperator {{{3

	NumberCheckboxGridFilter.prototype.getOperator = function () {
		return '$eq';
	};

	// NumberTriBoolGridFilter {{{2

	var NumberTriBoolGridFilter = makeSubclass('NumberTriBoolGridFilter', GridFilter, function () {
		var self = this;

		GridFilter.apply(self, arguments);

		self.inputName = gensym();

		var trueRadio = jQuery('<input>', {'type': 'radio', 'name': self.inputName, 'value': 'true'});
		var falseRadio = jQuery('<input>', {'type': 'radio', 'name': self.inputName, 'value': 'false'});
		var bothRadio = jQuery('<input>', {'type': 'radio', 'name': self.inputName, 'value': 'both'});

		self.inputs = jQuery([trueRadio.get(0), falseRadio.get(0), bothRadio.get(0)]);

		self.inputs.css('margin-right', '0.4em');

		self.inputs.each(function (i, elt) {
			elt = jQuery(elt);

			elt.on('change', function (evt) {
				self.gridFilterSet.update(false);
			});
		});

		self.div
			.append(jQuery('<label>')
				.append(trueRadio)
				.append('True'))
			.append(jQuery('<label>')
				.css('padding-left', '0.8em')
				.append(falseRadio)
				.append('False'))
			.append(jQuery('<label>')
				.css('padding-left', '0.8em')
				.append(bothRadio)
				.append('Both'))
		;

		if (self.removeBtn) {
			self.div.append(self.removeBtn);
		}

		//self.applyImmediately = true;
		self.limit = 1;
	});

	// #getValue {{{3

	NumberTriBoolGridFilter.prototype.getValue = function () {
		var self = this;

		var val = self.inputs.filter(':checked').val();

		switch (val) {
		case 'true':
			return 1;
		case 'false':
			return 0;
		case 'both':
			return undefined;
		default:
			throw new Error('Impossible');
		}
	};

	// #setValue {{{3

	NumberTriBoolGridFilter.prototype.setValue = function (val) {
		var self = this;

		var internalVal;

		switch (val) {
		case 0:
			internalVal = 'false';
			break;
		case 1:
			internalVal = 'true';
			break;
		default:
			internalVal = 'both';
		}

		self.inputs.filter('[value="' + internalVal + '"]').prop('checked', true);
	};

	// #getOperator {{{3

	NumberTriBoolGridFilter.prototype.getOperator = function () {
		return '$eq';
	};

	// DateSingleGridFilter {{{2

	/**
	 * Represents a filter for a single date.
	 *
	 * @class
	 * @extends GridFilter
	 */

	var DateSingleGridFilter = makeSubclass('DateSingleGridFilter', GridFilter, function () {
		var self = this;

		GridFilter.apply(self, arguments);

		self.input = jQuery('<input>').attr({
			'type': 'text',
			'placeholder': 'Select date...'
		});

		self.input.flatpickr({
			'altInput': false,
			'allowInput': true,
			'onChange': function (selectedDates, dateStr, instance) {
				console.log(selectedDates, dateStr);
				//self.gridFilterSet.update();
			}
		});

		self.div
			.append(self.input);

		if (self.removeBtn) {
			self.div.append(self.removeBtn);
		}
	});

	// DateRangeGridFilter {{{2

	/**
	 * Represents a filter for a range of dates.
	 *
	 * @class
	 * @extends GridFilter
	 */

	var DateRangeGridFilter = makeSubclass('DateRangeGridFilter', GridFilter, function () {
		var self = this;

		GridFilter.apply(self, arguments);

		self.limit = 1;

		self.input = jQuery('<input>').attr({
			'type': 'text',
			'placeholder': 'Click here; pick start/end dates.',
			'size': 28
		});

		self.widget = self.input.flatpickr({
			'altInput': false,
			'allowInput': true,
			'mode': 'range',
			'onChange': function (selectedDates, dateStr, instance) {
				self.selectedDates = selectedDates;
				self.gridFilterSet.update(false);
			}
		});

		self.div
			.append(self.input);

		if (self.removeBtn) {
			self.div.append(self.removeBtn);
		}
	});

	// #getValue {{{3

	/**
	 * Get the value(s) for this date range filter.  After you bring up the calendar, when you select
	 * the start date, the "onChange" event handler is run.  When you select the end date, the event is
	 * fired again.  So, we use #isRange() to decide if you've only selected one date, or if you've just
	 * picked the second.  When it's a range, we need to produce an object, instead of a simple value.
	 *
	 * @returns {GridFilter~Value|GridFilter~RangeValue} The value that should be used for filtering all
	 * the data in the grid.
	 */

	DateRangeGridFilter.prototype.getValue = function () {
		var self = this
			, result;

		if (self.selectedDates == null) {
			return undefined;
		}

		if (self.isRange()) {
			result = {
				'start': moment(self.selectedDates[0]),
				'end': moment(self.selectedDates[1]).hour(23).minute(59).second(59)
			};

			if (self.typeInfo.internalType === 'string') {
				result = underscore.mapObject(result, function (m) {
					return m.format('YYYY-MM-DD HH:mm:ss')
				});
			}
		}
		else {
			result = moment(self.selectedDates[0]);

			if (self.typeInfo.internalType === 'string') {
				result = result.format('YYYY-MM-DD HH:mm:ss');
			}
		}

		return result;
	};

	// #setValue {{{3

	DateRangeGridFilter.prototype.setValue = function (val) {
		var self = this;

		self.selectedDates = val;
		self.widget.setDate(val);
	};

	// #getOperator {{{3

	DateRangeGridFilter.prototype.getOperator = function () {
		var self = this;

		if (self.isRange()) {
			log.error('<< TSNH >> GridFilterSet called #getOperator() on a range');
		}

		return '$gte';
	};

	// #isRange {{{3

	DateRangeGridFilter.prototype.isRange = function () {
		var self = this;

		return self.selectedDates.length > 1;
	};

	// BooleanCheckboxGridFilter {{{2

	var BooleanCheckboxGridFilter = makeSubclass('BooleanCheckboxGridFilter', GridFilter, function (field, gridFilter) {
	});

	// #getValue {{{3

	BooleanCheckboxGridFilter.prototype.getValue = function () {
		return this.input.val();
	};

	// #getOperator {{{3

	BooleanCheckboxGridFilter.prototype.getOperator = function () {
		return '$eq';
	};

	// #getOperator {{{3

	BooleanCheckboxGridFilter.prototype.getId = function () {
		return this.input.attr('id');
	};

	// Widget Map {{{2

	// Type -> Filter Widget -> Constructor

	GridFilter.widgets = {
		'string': {
			'textbox': StringTextboxGridFilter,
			'dropdown': StringDropdownGridFilterSumo,
		},
		'number': {
			'textbox': NumberTextboxGridFilter,
			'checkbox': NumberCheckboxGridFilter,
			'tribool': NumberTriBoolGridFilter,
		},
		'currency': {
			'textbox': NumberTextboxGridFilter,
		},
		'date': {
			'single': DateSingleGridFilter,
			'range': DateRangeGridFilter,
		},
		'datetime': {
			'single': DateSingleGridFilter,
			'range': DateRangeGridFilter,
		}
	};

	GridFilter.defaultWidgets = {
		'string': 'dropdown',
		'number': 'textbox',
		'currency': 'textbox',
		'date': 'range',
		'datetime': 'range'
	};

	// GridFilterSet {{{1
	// Constructor {{{2

	/**
	 * Create a new collection of filters.
	 *
	 * @param {View} view
	 * The view that we will be updating the filter for.
	 *
	 * @param {Prefs} prefs
	 *
	 *
	 * @param {GridTable} gridTable A reference to the table that this filter set is displayed on.  This
	 * is used only to make sure that the widgets shown in the columns are resized correctly when the
	 * table's columns change width.
	 *
	 * @param {object} progress An object describing how to show a progress dialog when the view is
	 * updated.
	 *
	 * @class
	 * @property {View} view
	 * The view that we will be updating the filter for.
	 *
	 * @property {Prefs} prefs
	 *
	 * @property {object} progress An object describing how to show a progress dialog when the view is
	 * updated.
	 *
	 * @property {Element} thead
	 *
	 * @property {Object} filters Stores the filters that are within this set, with different properties
	 * to facilitate different lookup methods.
	 *
	 * @property {Array} filters.all An array of all the filters.
	 *
	 * @property {Object} filters.byId An object indexing all the filters by its internal ID.
	 *
	 * @property {Object.<Array>} filters.byCol An object indexing all the filters by the column that
	 * they're filtering.
	 *
	 * @property {boolean} delayUpdate If true, calls to the update() method do nothing.  This is used
	 * internally when loading preferences to avoid updating for every single filter.
	 */

	var GridFilterSet = makeSubclass('GridFilterSet', Object, function (view, prefs, gridTable, progress, opts) {
		var self = this;

		self.view = view;
		self.prefs = prefs;
		self.gridTable = gridTable;
		self.progress = progress;
		self.opts = deepDefaults(opts, {
			sendEvent: true,
			dontSendEventTo: [],
			updateData: true
		});

		self.filters = {
			all: [],
			byId: {},
			byCol: {}
		};

		self.delayUpdate = false;
	});

	// Events {{{2

	/**
	 * Fired when a filter has been added.
	 *
	 * @event GridFilterSet#filterAdded
	 */

	/**
	 * Fired when a filter has been removed.
	 *
	 * @event GridFilterSet#filterRemoved
	 */

	mixinEventHandling(GridFilterSet, [
			'filterAdded'
		, 'filterRemoved'
		, 'widgetResizedHoriz'
		, 'widgetResizedVert'
	]);

	// #add {{{2

	/**
	 * Add a new filter to this set.  This creates the user interface elements and places them in the
	 * appropriate place in the grid.
	 *
	 * @param {string} field Name of the column to filter on.
	 *
	 * @param {Element} target Where to place the filter widget.
	 *
	 * @param {string} [filterType] The developer's requested filter type.  If missing, we use the first
	 * one from the "allowed" list.  If present, and not in the allowed list, you'll get an error.
	 *
	 * @param {Element} filterBtn The "add filter" button from the column header.  Needed so we can hide
	 * it, if we've reached the maximum number of filters allowed on the column.
	 */

	GridFilterSet.prototype.add = function (field, target, opts) {
		var self = this
			, opts = opts || {}
			, filter;

		filter = self.build(field, target, opts);

		if (filter == null) {
			return null;
		}

		// Make sure that requisite data structures are there.

		if (self.filters.byCol[field] === undefined) {
			self.filters.byCol[field] = [];
		}

		// Add the filter to all of our data structures.

		self.filters.all.push(filter);
		self.filters.byCol[field].push(filter);
		self.filters.byId[filter.getId()] = filter;

		// Add the filter to the user interface.

		target.append(filter.div);

		if (typeof filter.afterAdd === 'function') {
			filter.afterAdd(target);
		}

		filter.adjustInputWidth();

		// Hide the "add filter" button if we've reached the limit of the number of filters we're allowed
		// to have for this column.

		if (opts.filterBtn && self.filters.byCol[field].length === filter.limit) {
			opts.filterBtn.hide();
		}

		self.fire(GridFilterSet.events.filterAdded);

		// Check to see if this filter should take effect as soon as it is created.

		if (filter.applyImmediately) {
			self.update();
		}

		return filter;
	};

	// #build {{{2

	/**
	 * Create a new GridFilter instance.
	 *
	 * @param {string} field
	 * Name of the field to apply the filter to.  Passed to the View.
	 *
	 * @param {string} filterType
	 * What type of widget to use for the filter (e.g. dropdown, text box, checkbox).
	 *
	 * @param {Element} filterBtn
	 * Button to add a new filter item.  Might be shown/hidden depending on how many items are allowed
	 * (e.g. a multi-select dropdown only allows one "item" as that's all you need).
	 *
	 * @param {Element} target
	 * Where the filter should be placed.
	 *
	 * @param {function} onRemove
	 * Function to call when the filter is removed.
	 *
	 * @param {Element} [sizingElement]
	 * If present, the element to use to calculate the width of the filter widget.  When absent, the
	 * div which is placed within the `target` is used.
	 */

	GridFilterSet.prototype.build = function (field, target, opts) {//filterType, filterBtn, target, onRemove, sizingElement, noRemoveBtn) {
		var self = this;

		// We use a data source to get the type information, so if the grid was built without a data
		// source, this isn't going to work.
		//
		// FIXME Don't rely on the cache, do it right.

		var fti = self.view.typeInfo.get(field);

		if (fti == null) {
			return null;
		}

		var colType = fti.type;

		// Make sure that we are able to get the column type.

		if (colType == null) {
			throw new Error('Unable to determine type of column "' + field + '"');
		}

		// Make sure that we know what kinds of filters are allowed for the column type.

		if (GridFilter.widgets[colType] === undefined) {
			throw new Error('Unknown type "' + colType + '" for column "' + field + '"');
		}

		// When the user didn't request a filter type, just use the first one in the allowed list.
		// Otherwise, make sure that the filter type they asked for makes sense for the column type.

		var filterType = opts.filterType || GridFilter.defaultWidgets[colType];
		var ctor = GridFilter.widgets[colType][filterType];

		if (ctor === undefined) {
			throw new Error('Invalid filter type "' + filterType + '" for type "' + colType + '" of column "' + field + '"');
		}

		debug.info('GRID FILTER', 'Creating new widget: column type = "' + colType + '" ; filter type = "' + filterType + '"');

		return new ctor(field, self, fti, opts);
	};

	// #remove {{{2

	/**
	 * Remove a filter.
	 *
	 * @param {string} id
	 * The unique ID of the filter to remove.
	 *
	 * @param {Element} filterBtn
	 * Button to add a new filter item.  Might be shown/hidden depending on how many items are allowed
	 * (e.g. a multi-select dropdown only allows one "item" as that's all you need).
	 */

	GridFilterSet.prototype.remove = function (id, filterBtn, noEvent) {
		var self = this
			, filter = self.filters.byId[id];

		// Make sure that a filter with that ID exists.

		if (filter === undefined) {
			log.warn('Attempted to remove filter with ID "' + id + '" from the grid, but it doesn\'t exist');
			return;
		}

		var sameId = function (elt) { return elt.getId() === id };
		var allIndex = underscore.findIndex(self.filters.all, sameId);
		var colIndex = underscore.findIndex(self.filters.byCol[filter.field], sameId);

		delete self.filters.byId[id];
		self.filters.all.splice(allIndex, 1);
		self.filters.byCol[filter.field].splice(colIndex, 1);

		filter.remove();

		// Show the "add filter" button if we're below the limit of the number of filters we're allowed to
		// have for this column.

		if (filterBtn && self.filters.byCol[filter.field].length < filter.limit) {
			filterBtn.show();
		}

		if (!noEvent) {
			self.fire(GridFilterSet.events.filterRemoved);
		}
	};

	// #removeField {{{2

	GridFilterSet.prototype.removeField = function (fieldName, filterBtn) {
		var self = this;

		underscore.each(self.filters.byCol[fieldName], function (filter) {
			self.remove(filter.getId(), filterBtn, true);
		});

		self.fire(GridFilterSet.events.filterRemoved);
	};

	// #reset {{{2

	/**
	 * Clear all filters.
	 */

	GridFilterSet.prototype.reset = function (opts) {
		var self = this;

		opts = opts || {};
		underscore.defaults(opts, {
			updateView: true
		});

		self.delayUpdate = true;

		// Remove every filter from the user interface.

		underscore.each(self.filters.all, function (filter) {
			filter.remove();
		});

		// Reset our internal data structures.

		self.filters = {
			all: [],
			byId: {},
			byCol: {}
		};

		if (opts.updateView) {
			self.view.clearFilter();
		}

		self.delayUpdate = false;
	};

	// #update {{{2

	/**
	 * Set the filters on the View based on what the user has entered into the user interface.
	 */

	GridFilterSet.prototype.update = function () {
		var self = this
			, spec = {};

		// Check for the "don't actually update" property, set when we're loading prefs to prevent any
		// `applyImmediately` filters from causing unnecessary updates until we're done.

		if (self.delayUpdate) {
			return;
		}

		if (self.filters.all.length === 0) {
			self.view.setFilter(null);
			return;
		}

		underscore.each(self.filters.byCol, function (filterList, field) {
			underscore.each(filterList, function (filter) {
				var value = filter.getValue();

				if (value === undefined) {
					return;
				}

				if (spec[field] === undefined) {
					spec[field] = {};
				}

				if (filter.isRange()) {
					spec[field]['$gte'] = value.start;
					spec[field]['$lte'] = value.end;
				}
				else {
					var operator = filter.getOperator();

					if (spec[field][operator] === undefined) {
						spec[field][operator] = value;
					}
					else if (underscore.isArray(spec[field][operator])) {
						spec[field][operator].push(value);
					}
					else if (['$eq', '$ne', '$contains'].indexOf(operator) >= 0) {
						spec[field][operator] = [spec[field][operator], value];
					}
					else {
						spec[field][operator] = value;
					}
				}
			});
		});

		debug.info('GRID FILTER SET', 'Updating with ' + self.filters.all.length + ' filters: ', spec);

		self.view.setFilter(spec, self.progress, self.opts);
	};

	// #set {{{2

	GridFilterSet.prototype.set = function (field, fieldSpec) {
		var self = this;

		if (typeof fieldSpec !== 'object') {
			fieldSpec = { '$eq': fieldSpec };
		}

		var filters = self.filters.byCol[field];

		if (filters == null || filters.length == null || filters.length === 0) {
			// ERROR: No filter exists for that field.
			return;
		}

		var widget = filters[0];

		if (widget instanceof DateRangeGridFilter && '$lte' in fieldSpec && '$gte' in fieldSpec) {
			widget.setValue([fieldSpec['$gte'], fieldSpec['$lte']]);
		}
		else {
			underscore.each(fieldSpec, function (val, op) {
				debug.info('GRID FILTER SET',
					'Setting filter: { field = %s ; operator = %s ; value = %s }',
					field, op, typeof val === 'object' ? JSON.stringify(val) : val);

				widget.setOperator(op);
				widget.setValue(val);
			});
		}
	};

	// GroupFunWin {{{1

	var GroupFunWin = makeSubclass('GroupFunWin', Object, function (title, groupFuns) {
		var self = this;

		var winEffect = {
			effect: 'fade',
			duration: 100
		};

		var selected = null;

		self.win = jQuery('<div>', { title: title }).dialog({
			autoOpen: false,
			modal: true,
			position: {
				my: 'center',
				at: 'center',
				of: window
			},
			classes: {
				"ui-dialog": "ui-corner-all wcdv_dialog",
				"ui-dialog-titlebar": "ui-corner-all",
			},
			show: winEffect,
			hide: winEffect,
			open: function () {
				selected = null;
			},
			close: function () {
				self.cb(selected);
			}
		});

		self.buttons = {};

		groupFuns.each(function (gf, gfName) {
			self.buttons[gfName] = jQuery('<button>', {
				'type': 'button',
				'class': 'wcdv_option',
				'data-wcdv-groupfunname': gfName,
				'title': gf.displayName
			})
				.text(gf.displayName)
				.on('click', function () {
					selected = gfName;
					self.win.dialog('close');
				});

			self.win.append(jQuery('<div>').append(self.buttons[gfName]));
		});

		// Add the "None" button to use no function.

		self.buttons['none'] = jQuery('<button>', {
			'type': 'button',
			'class': 'wcdv_option',
			'data-wcdv-groupfunname': 'none',
			'title': 'None'
		})
			.text('None')
			.on('click', function () {
				selected = 'none';
				self.win.dialog('close');
			});

		self.win.append(jQuery('<div>').append(self.buttons['none']));
	});

	// #show {{{2

	GroupFunWin.prototype.show = function (gfName, cb) {
		var self = this;
		self.cb = cb;

		self.win.dialog('open');

		if (gfName != null && self.buttons[gfName] != null) {
			self.buttons[gfName].focus();
		}
	};

	/*
	 * Grid controls are the rounded boxes that appear between the toolbar and the grid.  They allow
	 * dynamic configuration of the view to which the grid is bound.
	 *
	 *   - Filters
	 *   - Group Fields
	 *   - Pivot Fields
	 *   - Aggregates
	 *
	 * Each control is basically a list of things that have been added to it, e.g. for grouping, it's a
	 * list of fields to group by.  Internally, the control is an instance of a subclass of GridControl,
	 * and the items are corresponding instances of a subclass of GridControlField.  The name "Field"
	 * here is historical, before aggregates were specified this way, all controls managed fields from
	 * the source data.
	 */

	// GridControlField {{{1

	// Constructor {{{2

	/**
	 * Create a new GridControlField instance.
	 *
	 * @param {GridControl} control
	 *
	 * @param {string} field
	 *
	 * @param {string} displayText
	 *
	 * @param {object} colConfig
	 *
	 * @class
	 *
	 * Represents an individual field added to a control.  In an older iteration, this literally
	 * corresponded to a field in the data (e.g. because the control was a filter, group, or pivot).
	 * Now that aggregate functions are also managed through a GridControl subclass, the "field" name is
	 * no longer strictly accurate.
	 *
	 * @property {GridControl} control
	 *
	 * @property {string|object} spec
	 * If a string, simply the field to add.  If an object, should contain a `field` property along with
	 * anything else that this instance needs to carry.
	 *
	 * @property {string} displayText
	 *
	 * @property {object} colConfig
	 *
	 * @property {object} [opts]
	 *
	 * @property {object} ui
	 * Refers to all user interface constructs that we might need to use later.
	 *
	 * @property {Element} ui.root
	 * The DIV that completely contains the control field.
	 *
	 * @property {Element} ui.removeButton
	 * A button that is used to remove the control field.
	 */

	var GridControlField = (function () {
		var CONTROL_FIELD_ID = 0;
		return makeSubclass('GridControlField', Object, function (control, spec, displayText, colConfig, opts) {
			var self = this;

			self.control = control;

			if (typeof spec === 'string') {
				self.field = {
					field: spec
				};
			}
			else {
				self.field = deepCopy(spec);
			}
			self.displayText = displayText;
			self.colConfig = colConfig;
			self.opts = opts;

			self.fti = self.control.typeInfo.get(self.field.field);

			self.ui = {};
			self.id = CONTROL_FIELD_ID++;
		});
	})();

	// #draw {{{2

	/**
	 * Renders the control field into a DIV.
	 *
	 * @returns {Element}
	 * A newly created DIV that contains everything needed by the control field.
	 */

	GridControlField.prototype.draw = function () {
		var self = this;
		var label = self.displayText || (self.colConfig && self.colConfig.displayText) || self.field.field;

		self.ui.removeButton = jQuery('<button>', {'type': 'button'})
			.append(fontAwesome('F146'))
			.attr('title', 'Remove')
			.addClass('wcdv_icon_button wcdv_remove wcdv_text-primary')
			.on('click', function () {
				self.control.removeField(self);
			})
		;

		self.ui.fieldLabel = jQuery('<span>', {
			'class': 'wcdv_field_name',
			'title': label
		})
			.text(label);

		self.ui.root = jQuery('<div>', { 'class': 'wcdv_field' })
			.append(self.ui.removeButton)
			.append(self.ui.fieldLabel)
		;

		self._addErrorIndicator(self.ui.root, 'wcdv_aggregate_control_error');

		return self.ui.root;
	};

	// #getElement {{{2

	/**
	 * Gets the DIV that contains the UI for this control field.
	 *
	 * @returns {Element}
	 * The DIV that this control field was rendered into.
	 */

	GridControlField.prototype.getElement = function () {
		var self = this;

		return self.ui.root;
	};

	// #destroy {{{2

	/**
	 * Called when the control field is removed; should be used to clean up resources like DOM nodes and
	 * event handlers.
	 */

	GridControlField.prototype.destroy = function () {
		// DO NOTHING
	};

	// #showError {{{2

	GridControlField.prototype.showError = function (errMsg) {
		var self = this;

		debug.error('GRID // CONTROL', errMsg);

		if (self.ui.error) {
			self.ui.error.attr('title', errMsg);
			self.ui.error.show();
		}
		else {
			log.error('Call Error: Attempted to call `showError()` on a ControlField subclass instance that does not provide a way of indicating errors in the user interface.');
		}
	};

	// #_addErrorIndicator {{{2

	GridControlField.prototype._addErrorIndicator = function (parent, cls) {
		var self = this;

		self.ui.error = fontAwesome('fa-exclamation-triangle', cls)
			.hide()
			.tooltip({
				classes: {
					'ui-tooltip': 'ui-corner-all ui-widget-shadow ' + cls + '_tooltip'
				},
				show: { delay: 1000 }
			})
			.appendTo(parent);
	};

	// #getSpec {{{2

	GridControlField.prototype.getSpec = function () {
		var self = this;

		return {
			field: self.field.field
		};
	};

	// FunGridControlField {{{1

	// Constructor {{{2

	/**
	 * @class
	 * @extends GridControlField
	 */

	var FunGridControlField = makeSubclass('FunGridControlField', GridControlField);

	// #draw {{{2

	FunGridControlField.prototype.draw = function () {
		var self = this;

		self.super.draw();

		// Let's find out what group functions there are that work on the type of the field that we
		// represent, e.g. if we are a date, find out what group functions work on dates.

		var applicableGroupFuns = GROUP_FUNCTION_REGISTRY.filter(function (gf) {
			if (self.fti == null) {
				return false;
			}
			return gf.allowedTypes.indexOf(self.fti.type) >= 0;
		});

		if (applicableGroupFuns.size() > 0) {
			// When there are some group functions for the type of this field, we need to create a window to
			// choose between them, plus a button to show the window.

			self.ui.groupFunWin = new GroupFunWin('Apply Function to ' + self.field.field, applicableGroupFuns);

			self.ui.groupFunWinBtn = jQuery('<button>', {
				'type': 'button',
				'data-wcdv-role': 'set-group-fun',
				title: 'Show functions available for this field'
			})
				.addClass('wcdv_icon_button wcdv_button_left wcdv_text-primary')
				.on('click', function () {
					self.showFunWin();
				})
				.append(fontAwesome('fa-bolt'))
				.appendTo(self.ui.root)
			;

			if (self.field.fun != null) {
				var gf = GROUP_FUNCTION_REGISTRY.get(self.field.fun);
				self.ui.fieldLabel.text(self.field.field + ' (' + gf.displayName + ')');
				self.ui.fieldLabel.attr('title', self.field.field + ' (' + gf.displayName + ')');
			}
			self.ui.fieldLabel.after(self.ui.groupFunWinBtn);
		}

		return self.ui.root;
	};

	// #getSpec {{{2

	FunGridControlField.prototype.getSpec = function () {
		var self = this;

		return {
			field: self.field.field,
			fun: self.field.fun
		}
	};

	// #showFunWin {{{2

	FunGridControlField.prototype.showFunWin = function () {
		var self = this;

		self.ui.groupFunWin.show(self.field.fun || 'none', function (groupFunName) {
			if (groupFunName != null) {
				if (groupFunName === 'none') {
					self.field.fun = null;
					self.ui.fieldLabel.text(self.field.field);
				}
				else {
					self.field.fun = groupFunName;
					var gf = GROUP_FUNCTION_REGISTRY.get(self.field.fun);
					self.ui.fieldLabel.text(self.field.field + ' (' + gf.displayName + ')');
				}
				self.control.updateView();
			}
			else if (self.field.fun === undefined) {
				self.field.fun = null;
				self.control.updateView();
			}
		});
	};

	// GroupControlField {{{1

	// Constructor {{{2

	/**
	 * @class
	 * @extends FunGridControlField
	 */

	var GroupControlField = makeSubclass('GroupControlField', FunGridControlField);

	// PivotControlField {{{1

	// Constructor {{{2

	/**
	 * @class
	 * @extends FunGridControlField
	 */

	var PivotControlField = makeSubclass('PivotControlField', FunGridControlField);

	// FilterControlField {{{1
	// Constructor {{{2

	/**
	 * @class
	 * @extends GridControlField
	 */

	var FilterControlField = makeSubclass('FilterControlField', GridControlField);

	// #draw {{{2

	FilterControlField.prototype.draw = function () {
		var self = this;

		self.super.draw();
		self.ui.filterContainer = jQuery('<div>')
			.addClass('wcdv_filter_control_filter_container')
			.appendTo(self.ui.root);
		self.control.gfs.add(self.field.field, self.ui.filterContainer, {
			filterType: self.colConfig && self.colConfig.filter
		});

		return self.ui.root;
	};
	// AggregateControlField {{{1
	// Constructor {{{2

	/**
	 * @class
	 * @extends GridControlField
	 *
	 * @property {object} [opts]
	 *
	 * @property {string[]} [opts.fields]
	 * List of the fields used by the aggregate function.
	 *
	 * @property {object} [aggFunOpts]
	 * Options passed to the aggregate function.
	 */

	var AggregateControlField = makeSubclass('AggregateControlField', GridControlField, function () {
		var self = this;

		self.super.ctor.apply(self, arguments);
		self.fieldDropdowns = [];
		self.shouldGraph = false;
	});

	// #draw {{{2

	AggregateControlField.prototype.draw = function () {
		var self = this;

		self.super.draw();

		self._addErrorIndicator(self.ui.root, 'wcdv_aggregate_control_error');

		var aggDefn = AGGREGATE_REGISTRY.get(self.field.field);

		var fieldList = jQuery('<ul>', {
			'class': 'wcdv_aggregate_control_fieldlist'
		}).appendTo(self.ui.root);

		for (var i = 0; i < aggDefn.prototype.fieldCount; i += 1) {
			var li = jQuery('<li>').addClass('wcdv_aggregate_field').appendTo(fieldList);
			if (getProp(aggDefn.prototype, 'fieldInfo', i, 'name')) {
				var label = jQuery('<label>').text(aggDefn.prototype.fieldInfo[i].name + ':').appendTo(li);
			}
			var select = jQuery('<select>')
				.on('change', function (evt) {
					select.children('option[data-wcdv-bad-field]').filter(function (eltIndex, elt) {
						return jQuery(elt).attr('value') !== select.val();
					}).remove();
					self.control.updateView();
				})
				.appendTo(li);
			self.fieldDropdowns.push(select);
		}

		underscore.each(determineColumns(self.control.colConfig, null, self.control.typeInfo), function (fieldName) {
			var text = getProp(self.control.colConfig.get(fieldName), 'displayText') || fieldName;
			underscore.each(self.fieldDropdowns, function (dropdown, i) {
				jQuery('<option>', { 'value': fieldName }).text(text).appendTo(dropdown);
			});
		});

		// For each field dropdown, set its value to whatever we received.  This has the effect of making
		// the user interface match the internal aggregate configuration.

		underscore.each(self.fieldDropdowns, function (dropdown, i) {
			if (getProp(self.opts, 'fields', i)) {
				var matchingOption = dropdown.children('option').filter(function (eltIndex, elt) {
					return jQuery(elt).attr('value') === self.opts.fields[i];
				});

				// When the field in the configuration isn't in the dropdown (i.e. it's not in colConfig) then
				// we need to make an entry for it.  This happens when the aggregate spec from prefs refers to
				// a field that no longer exists in the data.

				if (matchingOption.length === 0) {
					jQuery('<option>', {
						'value': self.opts.fields[i],
						'data-wcdv-bad-field': 'yup'
					})
						.text(self.opts.fields[i] + ' — Invalid')
						.appendTo(dropdown);
				}

				dropdown.val(self.opts.fields[i]);
			}
		});

		if (aggDefn.prototype.options != null) {
			jQuery('<button>', {
				'type': 'button',
				title: 'Edit Options'
			})
				.addClass('wcdv_icon_button wcdv_button_left wcdv_text-primary')
				.on('click', function () {
					self.ui.optionsDialog.dialog('open');
				})
				.append(fontAwesome('F044'))
				.appendTo(self.ui.root)
			;
			self._makeOptionsDialog(aggDefn);
		}

		if (self.control.view.hasClientKind('graph')) {
			self.ui.graphBtn = jQuery('<button>', {
				'type': 'button'
			})
				.addClass('wcdv_icon_button wcdv_text-primary')
				.on('click', function () {
					// TODO Think of a better way to do this.  I feel like the coupling here is too high.

					self.control.clearGraphFlag();
					self.shouldGraph = true;
					self.control.updateView();
				})
				.append(fontAwesome('fa-bar-chart'))
				.appendTo(self.ui.root)
			;
		}

		self.ui.isHiddenCheckbox = jQuery('<input>', {
			'type': 'checkbox'
		})
			.prop('checked', getProp(self.opts, 'isHidden'))
			.on('change', function () {
				self.control.updateView();
			})
			.appendTo(self.ui.root)
			._makeIconCheckbox('fa-eye-slash wcdv_text-primary', 'fa-eye wcdv_text-primary')
		;

		return self.ui.root;
	};

	// #_makeOptionsDialog {{{2

	AggregateControlField.prototype._makeOptionsDialog = function (aggDefn) {
		var self = this;

		self.ui.optionsDiv = jQuery('<div>')
			.css('display', 'none')
			.appendTo(document.body);

		var table = jQuery('<table>').appendTo(self.ui.optionsDiv);
		var opts = {};

		underscore.each(aggDefn.prototype.options, function (optConfig, optName) {
			optConfig = deepDefaults(optConfig, {
				type: 'string',
				widget: 'text',
				displayText: optName
			});
			var id = gensym();
			var input = jQuery('<input>', {
				'type': 'text',
				'id': id
			});
			opts[optName] = input;
			var label = jQuery('<label>', {
				'for': id
			}).text(optConfig.displayText);
			jQuery('<tr>')
				.append(jQuery('<td>').append(label))
				.append(jQuery('<td>').append(input))
				.appendTo(table);
		});

		jQuery('<div>')
			.css({
				'text-align': 'center',
				'margin-top': '1ex'
			})
			.append(jQuery('<button>', {'type': 'button'})
				.append(fontAwesome('F00C'))
				.append('OK')
				.on('click', function () {
					self.aggFunOpts = opts;
					self.control.updateView();
					self.ui.optionsDialog.dialog('close');
				}))
			.append(jQuery('<button>', {'type': 'button'})
				.css('margin-left', '1em')
				.append(fontAwesome('F05E'))
				.append('Cancel')
				.on('click', function () {
					self.ui.optionsDialog.dialog('close');
				}))
			.appendTo(self.ui.optionsDiv)
		;

		self.ui.optionsDialog = self.ui.optionsDiv.dialog({
			autoOpen: false,
			modal: true,
			title: aggDefn.prototype.name + ' — Options',
			minHeight: 0
		});
	};

	// #destroy {{{2

	AggregateControlField.prototype.destroy = function () {
		var self = this;

		if (self.ui.optionsDiv != null) {
			self.ui.optionsDialog.dialog('destroy');
			self.ui.optionsDiv.remove();
		}

		self.super.destroy();
	};

	// #getInfo {{{2

	AggregateControlField.prototype.getInfo = function () {
		var self = this;

		return {
			fun: self.field.field,
			name: null,
			fields: underscore.map(self.fieldDropdowns, function (dropdown) {
				return dropdown.val();
			}),
			isHidden: self.ui.isHiddenCheckbox._isChecked(),
			shouldGraph: self.shouldGraph,
			opts: underscore.mapObject(self.aggFunOpts, function (input, optName) {
				return input.val();
			})
		};
	};

	// GridControl {{{1

	// Constructor {{{2

	/**
	 * Creates a new GridControl instance.
	 *
	 * @param {Grid} grid
	 * @param {OrdMap.<Grid~ColConfig>} colConfig
	 * @param {View} view
	 * @param {object} features
	 * @param {Timing} timing
	 *
	 * @class
	 *
	 * An abstract class that represents some kind of interface that the user can operate over the
	 * available fields.
	 *
	 * Subclasses should implement the following functions:
	 *
	 * - `draw(TARGET)`
	 *   Called to create all required user interface components.
	 *
	 * - `updateView()`
	 *   Use `self.fields` to set whatever properties are needed on the view.
	 *
	 * @property {Grid} grid
	 * @property {View} view
	 * @property {object} features
	 * @property {Timing} timing
	 * @property {OrdMap.<Grid~ColConfig>} colConfig
	 *
	 * @property {Array.<string>} fields
	 * List of all the fields selected by the user.
	 *
	 * @property {Array.<ControlField>} controlFields
	 * List of all the control fields currently in the UI.
	 *
	 * @property {Object.<string, Array.<ControlField>>} controlFieldsByField
	 * Object for looking up control fields by name.
	 *
	 * @property {Object.<string, ControlField>} controlFieldsById
	 * Object for looking up control fields by ID.
	 *
	 * @property {object} ui
	 * Object containing different user interface components.
	 *
	 * @property {jQuery} ui.dropdown
	 * The SELECT element containing the available fields.
	 *
	 * @property {boolean} [prototype.isHorizontal=false]
	 * If true, display the list horizontally rather than vertically.
	 *
	 * @property {boolean} [prototype.isReorderable=true]
	 * If true, display an arrow for reordering the items in the list (when `isHorizontal=false`).
	 *
	 * @property {boolean} [prototype.showColumns=true]
	 * If true, display a dropdown with field names to choose from.
	 *
	 * @property {boolean} [prototype.disableUsedItems=false]
	 * If true, items that are added will be disabled in the columns dropdown.
	 *
	 * @property {boolean} [prototype.useColConfig=true]
	 * If true, pass colConfig for the item to the appropriate `Field` subclass.
	 *
	 * @property {boolean} [prototype.updateCanHide=true]
	 * If true, automatically update colConfig to show (and prohibit hiding of) the column being added.
	 */

	var GridControl = makeSubclass('GridControl', Object, function (grid, colConfig, view, features, timing) {
		var self = this;

		if (!(grid instanceof Grid)) {
			throw new Error('Call Error: `grid` must be an instance of MIE.WC_DataVis.Grid');
		}

		self.grid = grid;
		self.colConfig = colConfig;
		self.view = view;
		self.features = features;
		self.timing = timing;
		self.fields = [];
		self.controlFields = [];
		self.controlFieldsByField = {};
		self.controlFieldsById = {};

		self.ui = {};

		self.grid.on('colConfigUpdate', function (colConfig) {
			self.colConfig = colConfig;
		});
	}, {
		isHorizontal: false,
		isReorderable: true,
		showColumns: true,
		disableUsedItems: false,
		useColConfig: true,
		updateCanHide: true
	});

	// Events {{{2

	/**
	 * Fired when a field has been added to the control.
	 *
	 * @event GridControl#fieldAdded
	 *
	 * @param {string} fieldAdded
	 * The field that was added.
	 *
	 * @param {Array.<string>} allFields
	 * All fields in the control, after the addition.
	 */

	/**
	 * Fired when a field has been removed from the control.
	 *
	 * @event GridControl#fieldRemoved
	 *
	 * @param {string} fieldRemoved
	 * The field that was removed.
	 *
	 * @param {Array.<string>} allFields
	 * All fields in the control, after the removal.
	 */

	/**
	 * Fired when the control has been cleared (reset).
	 *
	 * @event GridControl#cleared
	 */

	mixinEventHandling(GridControl, [
			'fieldAdded'
		, 'fieldRemoved'
		, 'cleared'
	]);

	// #makeClearButton {{{2

	/**
	 * Make a button that calls the `clear` method when clicked.
	 *
	 * @param {jQuery} target
	 * Where to append the button.
	 *
	 * @returns {jQuery}
	 * The button created.
	 */

	GridControl.prototype.makeClearButton = function (target) {
		var self = this;

		return jQuery(fontAwesome('F05E'))
			.addClass('wcdv_button wcdv_text-primary wcdv_control_clear_button')
			.hide()
			.on('click', function () {
				jQuery(this).hide();
				self.clear();
			})
			.appendTo(target);
	};

	// #addField {{{2

	/**
	 * Add a field to this control.  Automatically updates the view afterwards.
	 *
	 * @param {string} field
	 * Name of the field to add.
	 *
	 * @param {string} displayText
	 *
	 * @param {object} opts
	 *
	 * @param {object} controlFieldOpts
	 *
	 * @param {function} next
	 */

	GridControl.prototype.addField = function (field, displayText, opts, controlFieldOpts, next) {
		var self = this
			, args = Array.prototype.slice.call(arguments)
			, fieldName;

		opts = deepDefaults(opts, {
			updateView: true,
			silent: false,
			openControls: false
		});

		if (field == null || field === '') {
			return typeof next === 'function' ? next(false) : undefined;
		}

		fieldName = typeof field === 'string' ? field : field.field;

		if (fieldName == null || fieldName === '' || (self.disableUsedItems && self.fields.indexOf(fieldName) >= 0)) {
			return typeof next === 'function' ? next(false) : undefined;
		}

		// Make sure we have access to typeinfo before continuing.  The typeinfo is used for:
		//
		//   1. Making sure aggregates are only applied to certain fields.
		//   2. Showing group/pivot functions for applicable fields only.

		if (self.typeInfo == null) {
			return self.view.getTypeInfo(function (ok, typeInfo) {
				if (!ok) {
					return typeof next === 'function' ? next(false) : undefined;
				}
				self.typeInfo = typeInfo;
				return GridControl.prototype.addField.apply(self, args);
			});
		}

		if (opts.openControls) {
			self.grid.showControls();
		}

		// Check to see if we are supposed to update the 'canHide' property of the column config.  Since
		// we're adding the field, we mark it so that the field can't be hidden.

		if (self.updateCanHide && self.colConfig != null && self.colConfig.isSet(fieldName)) {
			self.colConfig.get(fieldName).isHidden = false;
			self.colConfig.get(fieldName).canHide = false;
		}

		var cf = new self.controlFieldCtor(self, field, displayText, self.useColConfig ? self.colConfig.get(fieldName) : null, controlFieldOpts);

		self.controlFields.push(cf);
		self.controlFieldsById[cf.id] = cf;

		if (self.controlFieldsByField[fieldName] == null) {
			self.controlFieldsByField[fieldName] = [];
		}
		self.controlFieldsByField[fieldName].push(cf);

		self.ui.clearBtn.show();

		var li = jQuery('<li>')
			.attr({
				'data-wcdv-field': fieldName,
				'data-wcdv-control-field-id': cf.id,
				'data-wcdv-draggable-origin': 'GRID_CONTROL_FIELD'
			});

		if (self.isHorizontal) {
			li.append(fontAwesome('F178'));
		}

		li.append(cf.draw());
		li.appendTo(self.ui.fields); // Add it to the DOM.

		if (self.disableUsedItems) {
			self.ui.dropdown.find('option').filter(function () {
				return jQuery(this).val() === fieldName;
			}).prop('disabled', true);
		}

		self.ui.dropdown.val('');
		self.fields.push(fieldName); // Add it to the fields array.

		if (typeof self.updateView === 'function' && opts.updateView) {
			self.updateView();
		}

		if (!opts.silent) {
			self.fire('fieldAdded', null, fieldName, self.fields);
		}

		return typeof next === 'function' ? next(true, cf) : undefined;
	};

	// #removeField {{{2

	/**
	 * Remove a field from this control.  Automatically updates the view afterwards.
	 *
	 * @param {ControlField} cf
	 * The field to remove.
	 */

	GridControl.prototype.removeField = function (cf) {
		var self = this
			, fieldName = cf.field.field;

		// Check to see if we are supposed to update the 'canHide' property of the column config.  Since
		// we're removing the field, we mark it so that the field can be hidden.

		if (self.updateCanHide && self.colConfig != null && self.colConfig.isSet(fieldName)) {
			self.colConfig.get(fieldName).canHide = true;
		}

		// Remove it from the UI.

		cf.destroy();
		cf.getElement().parent('li').remove();

		// Remove it from the internal data structures.

		self.controlFields = underscore.without(self.controlFields, cf);
		self.controlFieldsById[cf.id] = undefined;
		self.controlFieldsByField[fieldName] = underscore.without(self.controlFieldsByField[fieldName], cf);

		// Re-enable the option in the dropdown, if necessary.

		self.fields.splice(self.fields.indexOf(fieldName), 1);

		if (self.disableUsedItems) {
			self.ui.dropdown.find('option').filter(function () {
				return jQuery(this).val() === fieldName;
			}).prop('disabled', false);
		}

		// Hide the "clear" button if there's nothing to clear.

		if (self.controlFields.length === 0) {
			self.ui.clearBtn.hide();
		}

		self.updateView();
		self.fire(GridControl.events.fieldRemoved, null, fieldName, self.fields);
	};

	// #clear {{{2

	/**
	 * Removes all fields from the control.  Automatically updates the view afterwards.
	 */

	GridControl.prototype.clear = function (opts) {
		var self = this;

		opts = opts || {};
		underscore.defaults(opts, {
			updateView: true
		});

		// Check to see if we are supposed to update the 'canHide' property of the column config.  Since
		// we're removing all fields, we mark it so that they can all be hidden.

		if (self.updateCanHide && self.colConfig != null) {
			self.colConfig.each(function (cc) {
				cc.canHide = true;
			});
		}

		self.fields = [];
		self.controlFields = [];
		self.controlFieldsById = {};
		self.controlFieldsByField = {};
		self.ui.fields.children().remove();
		self.ui.dropdown.find('option:disabled').filter(function () {
			return jQuery(this).val() !== '';
		}).prop('disabled', false);
		self.ui.clearBtn.hide();

		if (opts.updateView) {
			self.updateView();
		}

		self.fire(GridControl.events.cleared);
	};

	// #destroy {{{2

	GridControl.prototype.destroy = function () {
		var self = this;

		debug.info('GRID // CONTROL', 'Good-bye, cruel world!');

		self.view.off('*', self);
		self.grid.off('*', self);
		self.ui.root.remove();
	};

	// #addViewConfigChangeHandler {{{2

	/**
	 * Registers an event handler on the view to update the UI when the view is changed (typically by
	 * loading preferences, but also possibly by another grid connected to the same view).
	 *
	 * @param {string} event
	 * Name of the event to register on in the view.
	 *
	 * @param {function} sync
	 * Event handler for the specified event.
	 */

	GridControl.prototype.addViewConfigChangeHandler = function (event, sync) {
		var self = this;

		var clearDropdown = function () {
			self.ui.dropdown.children().remove();
			jQuery('<option>', {
				'value': '',
				'disabled': true,
				'selected': true
			})
				.text('Select Field')
				.appendTo(self.ui.dropdown);
		};

		// There are two main things that we sync:
		//
		// 1. The dropdown that shows all the fields.  (Not used by aggregate control.)  This is done when
		//    the column configuration is updated.  Interactive column configuration can change the names
		//    shown for the fields in the dropdown.
		//
		// 2. The list of elements applied in the control; for group & pivot these are the fields with
		//    arrows connecting them; for filter it's the list of filters; for aggregate it's the list of
		//    aggregate functions.  It's up to the caller (i.e. the subclass) to provide a function that
		//    does this synchronization.

		var sync_colConfig = function (colConfig) {
			debug.info('GRID (' + self.grid.id + ') // ' + self.controlType.toUpperCase() + ' CONTROL', 'Synchronizing column configuration with grid');
			self.colConfig = colConfig;
			if (self.showColumns) {
				clearDropdown();
				colConfig.each(function (fcc) {
					jQuery('<option>', { 'value': fcc.field }).text(fcc.displayText || fcc.field).appendTo(self.ui.dropdown);
				});
			}
		};

		var sync_view = function () {
			debug.info('GRID (' + self.grid.id + ') // ' + self.controlType.toUpperCase() + ' CONTROL', 'Synchronizing user interface with view');
			sync();
		};

		// To fully sync, you need column configuration and type info.  Obviously you need column config
		// because that says what all the available fields' names are.  Type info is only needed right now
		// for the filter control, to determine what type of control to show (e.g. the widget used for
		// numbers is different from that used for dates).
		//
		// We need to do things in that order: sync #1 (column config) first, then #2 (view).  The reason
		// is that synchronizing #2 may cause us to modify the dropdown, i.e. to disable a field that must
		// already exist due to synchronizing #1.
		//
		// BUT we don't know that any of this code will necessarily execute *before* the column config
		// and/or type info has been determined.  This code may run before either of those are known, or
		// it may be afterwards (because column config could come directly from the JS instantiating the
		// grid, from prefs, or from the source itself).  So we need to always take that info account ---
		// if the column config is already known, use it; otherwise register an event handler to capture
		// it when it's decided.  Similarly with type info.

		if (self.grid.colConfig != null) {
			sync_colConfig(self.grid.colConfig);
			self.grid.on('colConfigUpdate', sync_colConfig);
			if (self.view.typeInfo != null) {
				sync_view();
				self.view.on(event, sync_view, { who: self });
			}
			else {
				self.view.on('getTypeInfo', function () {
					sync_view();
					self.view.on(event, sync_view, { who: self });
				}, { limit: 1 });
			}
		}
		else {
			// This setup of event handlers forces us to receive one `colConfigUpdate` event before we allow
			// any `*Set` events to come through.  This is important because the `*Set` events will cause us
			// to disable elements in the dropdown, so we need to have populated it first.

			self.grid.on('colConfigUpdate', function (colConfig) {
				sync_colConfig(colConfig);
				self.grid.on('colConfigUpdate', sync_colConfig);
				if (self.view.typeInfo != null) {
					sync_view();
					self.view.on(event, sync_view, { who: self });
				}
				else {
					self.view.on('getTypeInfo', function (ok) {
						sync_view();
						self.view.on(event, sync_view, { who: self });
					}, { limit: 1 });
				}
			}, { limit: 1 });
		}
	};

	// #getListElement {{{2

	GridControl.prototype.getListElement = function () {
		var self = this;

		return self.ui.fields;
	};

	// #draw {{{2

	/**
	 * Render this grid control and attach it to the specified parent element.
	 *
	 * @abstract
	 *
	 * @param {jQuery} parent
	 * Element to append this grid control to.
	 */

	GridControl.prototype.draw = function (parent) {
		throw new Error('ABSTRACT');
	};

	// #updateView {{{2

	/**
	 * Update the view with the configuration entered using this grid control.
	 *
	 * @abstract
	 */

	GridControl.prototype.updateView = function () {
		throw new Error('ABSTRACT');
	};

	// GroupControl {{{1

	// Constructor {{{2

	/**
	 * Part of the user interface which governs the fields that are part of the group, including
	 * filtering.
	 *
	 * @class
	 * @extends GridControl
	 */

	var GroupControl = makeSubclass('GroupControl', GridControl, function () {
		var self = this;

		self.super.ctor.apply(self, arguments);

		self.view.on(View.events.invalidGroupField, function (field) {
			underscore.each(self.controlFieldsByField[field], function (cf) {
				cf.showError('This field does not exist in the data.');
			});
		});
	}, {
		controlFieldCtor: GroupControlField,
		controlType: 'Group'
	});

	// #draw {{{2

	/**
	 * Create a DIV element that can be placed within the Grid instance to hold the user interface for
	 * the GroupControl.  The caller must add the result to the DOM somewhere.
	 *
	 * @returns {jQuery} The DIV element that holds the entire UI.
	 */

	GroupControl.prototype.draw = function (parent) {
		var self = this;

		parent.droppable({
			classes: {
				'ui-droppable-hover': 'wcdv_drop_target_hover'
			},
			drop: function (evt, ui) {
				// Turn this off for the sake of efficiency.
				//ui.draggable.draggable('option', 'refreshPositions', false);

				// The problem is, this event gets triggered both (1) when dropping a field from the grid
				// table's header, and (2) when shuffling fields between the group & pivot controls.  In the
				// case of (1) we need to make an <LI>.  But in the case of (2), we don't need to modify the
				// DOM in any way, jQuery UI sortable does that for us.  To tell the difference, we use the
				// `wcdv-draggable-origin` data attribute, which tells where the draggable came from.

				if (ui.draggable.attr('data-wcdv-draggable-origin') === 'GRID_TABLE_HEADER') {
					var field = ui.draggable.attr('data-wcdv-field');
					self.addField(field, getProp(self.colConfig.get(field), 'displayText'), {
						autoShowFunWin: true
					});
				}
			}
		})
			._addEventDebugging('drop', 'GROUP');

		self.ui.root = jQuery('<div>').appendTo(parent);
		self.ui.title = jQuery('<div>')
			.addClass('wcdv_control_title_bar')
			.appendTo(self.ui.root);
		jQuery('<span>', { 'class': 'wcdv_control_title' })
			.text('Group Fields')
			.appendTo(self.ui.title);
		self.ui.clearBtn = self.makeClearButton(self.ui.title);
		self.ui.fields = jQuery('<ul>', {
			id: gensym(),
			'class': self.isHorizontal ? 'wcdv_control_horizontal' : 'wcdv_control_vertical'
		}).appendTo(self.ui.root);

		var dropdownContainer = jQuery('<div>').appendTo(self.ui.root);
		self.ui.dropdown = jQuery('<select>', { 'class': 'wcdv_control_addField' }).appendTo(dropdownContainer);
		self.ui.dropdown.on('change', function () {
			self.addField(self.ui.dropdown.val(), self.ui.dropdown.find('option:selected').text(), {
				autoShowFunWin: true
			});
		});

		self.addViewConfigChangeHandler('groupSet', function () {
			var spec = self.view.getGroup();
			var fields = (spec && spec.fieldNames) || [];
			self.clear({ updateView: false });
			debug.info('GRID // GROUP CONTROL',
				'View set group fields to: ' + JSON.stringify(fields));
			underscore.each(fields, function (field) {
				self.addField(field, getProp(self.colConfig.get(field), 'displayText'), { updateView: false });
			});
		});

		return self.ui.root;
	};

	// #updateView {{{2

	GroupControl.prototype.updateView = function () {
		var self = this;
		var fieldNames = underscore.map(self.controlFields, function (cf) {
			return cf.getSpec();
		});

		if (fieldNames.length > 0) {
			self.view.setGroup({fieldNames: fieldNames}, {
				dontSendEventTo: self
			});
		}
		else {
			self.view.clearGroup();
		}
	};

	// #toString {{{2

	GroupControl.prototype.toString = function () {
		var self = this;

		return self.grid.id + ', Group';
	};

	// #sortableSync {{{2

	GroupControl.prototype.sortableSync = function () {
		var self = this;

		var controlFieldIds = self.ui.fields.children('li').map(function (index, elt) {
			return jQuery(elt).attr('data-wcdv-control-field-id');
		}).get();

		self.controlFields = [];
		underscore.each(controlFieldIds, function (id) {
			self.controlFields.push(self.controlFieldsById[id]);
		});

		return self.updateView();
	};

	// #addField {{{2

	GroupControl.prototype.addField = function (field, displayText, opts) {
		var self = this;

		opts = deepDefaults(opts, {
			autoShowFunWin: false,
			updateView: true
		});
		var updateView = opts.updateView;
		opts.updateView = false;

		self.super.addField(field, displayText, opts, null, function (ok, cf) {
			if (!ok) {
				return;
			}
			if (opts.autoShowFunWin && cf.fti != null && ['date', 'datetime'].indexOf(cf.fti.type) >= 0 && cf.field.fun === undefined) {
				cf.showFunWin();
			}
			else if (updateView) {
				self.updateView();
			}
		});
	};

	// PivotControl {{{1

	// Constructor {{{2

	/**
	 * Part of the user interface which governs: (1) the fields that are part of the pivot, including
	 * filtering; (2) the aggregate function [and potentially its arguments] that produces the values in
	 * the pivot table.
	 *
	 * @class
	 * @extends GridControl
	 *
	 * @property {GridControl} super
	 * Proxy to call prototype ("superclass") methods even if we override them.
	 *
	 * @property {string[]} fields
	 * Names of the fields
	 */

	var PivotControl = makeSubclass('PivotControl', GridControl, function () {
		var self = this;

		self.super.ctor.apply(self, arguments);

		self.view.on(View.events.invalidPivotField, function (field) {
			underscore.each(self.controlFieldsByField[field], function (cf) {
				cf.showError('This field does not exist in the data.');
			});
		});
	}, {
		controlFieldCtor: PivotControlField,
		controlType: 'Pivot'
	});

	// #draw {{{2

	/**
	 * Create a DIV element that can be placed within the Grid instance to hold the user interface for
	 * the PivotControl.  The caller must add the result to the DOM somewhere.
	 *
	 * @returns {jQuery} The DIV element that holds the entire UI.
	 */

	PivotControl.prototype.draw = function (parent) {
		var self = this;

		parent.droppable({
			classes: {
				'ui-droppable-hover': 'wcdv_drop_target_hover'
			},
			drop: function (evt, ui) {
				// Turn this off for the sake of efficiency.
				//ui.draggable.draggable('option', 'refreshPositions', false);

				// The problem is, this event gets triggered both (1) when dropping a field from the grid
				// table's header, and (2) when shuffling fields between the group & pivot controls.  In the
				// case of (1) we need to make an <LI>.  But in the case of (2), we don't need to modify the
				// DOM in any way, jQuery UI sortable does that for us.  To tell the difference, we use the
				// `wcdv-draggable-origin` data attribute, which tells where the draggable came from.

				if (ui.draggable.attr('data-wcdv-draggable-origin') === 'GRID_TABLE_HEADER') {
					var field = ui.draggable.attr('data-wcdv-field');
					self.addField(field, getProp(self.colConfig.get(field), 'displayText'), {
						autoShowFunWin: true
					});
				}
			}
		})
			._addEventDebugging('drop', 'PIVOT');

		self.ui.root = jQuery('<div>').appendTo(parent);
		self.ui.title = jQuery('<div>')
			.addClass('wcdv_control_title_bar')
			.appendTo(self.ui.root);
		jQuery('<span>')
			.addClass('wcdv_control_title')
			.text('Pivot Fields')
			.appendTo(self.ui.title);
		self.ui.clearBtn = self.makeClearButton(self.ui.title);
		self.ui.fields = jQuery('<ul>', {
			id: gensym(),
			'class': self.isHorizontal ? 'wcdv_control_horizontal' : 'wcdv_control_vertical'
		}).appendTo(self.ui.root);

		var dropdownContainer = jQuery('<div>').appendTo(self.ui.root);
		self.ui.dropdown = jQuery('<select>', { 'class': 'wcdv_control_addField' }).appendTo(dropdownContainer);
		self.ui.dropdown.on('change', function () {
			self.addField(self.ui.dropdown.val(), self.ui.dropdown.find('option:selected').text(), {
				autoShowFunWin: true
			});
		});

		self.addViewConfigChangeHandler('pivotSet', function (spec) {
			spec = self.view.getPivot();
			var fields = (spec && spec.fieldNames) || [];
			self.clear({ updateView: false });
			debug.info('GRID // PIVOT CONTROL',
				'View set pivot fields to: ' + JSON.stringify(fields));
			underscore.each(fields, function (field) {
				self.addField(field, getProp(self.colConfig.get(field), 'displayText'), { updateView: false });
			});
		});

		return self.ui.root;
	};

	// #updateView {{{2

	/**
	 * Set the pivot configuration on the View.  The pivot configuration consists of:
	 *
	 *   - Fields that are part of the pivot.
	 */

	PivotControl.prototype.updateView = function () {
		var self = this;
		var fieldNames = underscore.map(self.controlFields, function (cf) {
			return cf.getSpec();
		});

		if (fieldNames.length > 0) {
			self.view.setPivot({fieldNames: fieldNames}, {
				dontSendEventTo: self
			});
		}
		else {
			self.view.clearPivot();
		}
	};

	// #toString {{{2

	PivotControl.prototype.toString = function () {
		var self = this;

		return self.grid.id + ', Pivot';
	};

	// #sortableSync {{{2

	PivotControl.prototype.sortableSync = function () {
		var self = this;

		var controlFieldIds = self.ui.fields.children('li').map(function (index, elt) {
			return jQuery(elt).attr('data-wcdv-control-field-id');
		}).get();

		self.controlFields = [];
		underscore.each(controlFieldIds, function (id) {
			self.controlFields.push(self.controlFieldsById[id]);
		});

		return self.updateView();
	};

	// #addField {{{2

	PivotControl.prototype.addField = function (field, displayText, opts) {
		var self = this;

		opts = deepDefaults(opts, {
			autoShowFunWin: false,
			updateView: true
		});
		var updateView = opts.updateView;
		opts.updateView = false;

		self.super.addField(field, displayText, opts, null, function (ok, cf) {
			if (!ok) {
				return;
			}
			if (opts.autoShowFunWin && cf.fti != null && ['date', 'datetime'].indexOf(cf.fti.type) >= 0 && cf.field.fun === undefined) {
				cf.showFunWin();
			}
			else if (updateView) {
				self.updateView();
			}
		});
	};

	// AggregateControl {{{1

	// Constructor {{{2

	/**
	 * Part of the user interface which governs the aggregate function (and potentially its arguments)
	 * that produces the values in (1) group summary columns, (2) pivot cells.
	 *
	 * @class
	 * @extends GridControl
	 *
	 * @property {string[]} fields
	 * Names of the fields
	 */

	var AggregateControl = makeSubclass('AggregateControl', GridControl, function () {
		var self = this;

		self.super.ctor.apply(self, arguments);

		self.view.on(View.events.invalidAggregate, function (aggNum, errMsg) {
			self.controlFields[aggNum].showError(errMsg);
		});
	}, {
		disableUsedItems: false,
		showColumns: false,
		updateCanHide: false,
		controlFieldCtor: AggregateControlField,
		controlType: 'Aggregate'
	});

	// #draw {{{2

	/**
	 * Create a DIV element that can be placed within the Grid instance to hold the user interface for
	 * the AggregateControl.  The caller must add the result to the DOM somewhere.
	 *
	 * @returns {jQuery} The DIV element that holds the entire UI.
	 */

	AggregateControl.prototype.draw = function (parent) {
		var self = this;

		self.ui.root = jQuery('<div>').appendTo(parent);

		self.ui.title = jQuery('<div>')
			.addClass('wcdv_control_title_bar')
			.appendTo(self.ui.root);
		jQuery('<span>')
			.addClass('wcdv_control_title')
			.text('Aggregate')
			.appendTo(self.ui.title);
		self.ui.clearBtn = self.makeClearButton(self.ui.title);
		self.ui.fields = jQuery('<ul>', {
			id: gensym(),
			'class': self.isHorizontal ? 'wcdv_control_horizontal' : 'wcdv_control_vertical'
		}).appendTo(self.ui.root);
		var dropdownContainer = jQuery('<div>').appendTo(self.ui.root);
		self.ui.dropdown = jQuery('<select>', { 'class': 'wcdv_control_addField' }).appendTo(dropdownContainer);
		self.ui.dropdown.on('change', function () {
			self.addField(self.ui.dropdown.val(), self.ui.dropdown.find('option:selected').text());
		});

		jQuery('<option>', { 'value': '', 'disabled': true, 'selected': true })
			.text('Select Aggregate')
			.appendTo(self.ui.dropdown);

		AGGREGATE_REGISTRY.each(function (aggFunDefn, aggFunShortName) {
			jQuery('<option>', { 'value': aggFunShortName }).text(aggFunDefn.prototype.name).appendTo(self.ui.dropdown);
		});
		/*
		self.ui.fun = jQuery('<div>').css({'margin-top': '7px'}).appendTo(self.ui.root);
		jQuery('<label>').text('Function:').appendTo(self.ui.fun);
		self.ui.funDropdown = jQuery('<select>')
			.appendTo(self.ui.fun)
			.on('change', function () {
				self.triggerAggChange();
			})
		;

		// Create a dropdown containing all the aggregate functions that are allowed to be used for
		// calculating pivot cells.  Right now that's everything that needs no external parameters aside
		// from the field.

		AGGREGATE_REGISTRY.each(function (aggClass, aggFunName) {
			if (aggClass.prototype.enabled && aggClass.prototype.enabled) {
				jQuery('<option>', {
					value: aggFunName
				})
					.text(aggClass.prototype.name || aggFunName)
					.appendTo(self.ui.funDropdown);
			}
		});

		// When we receive type information, use that to populate the "fields" dropdown.
		//
		// TODO This needs to be expanded to the possibility of having multiple fields.

		self.view.on('getTypeInfo', function (typeInfo) {
			self.typeInfo = typeInfo;
			self.updateFieldDropdowns();
		}, { limit: 1 });

		var syncAgg = function (spec) {
			var agg;
			if (getProp(spec, 'cell', 0, 'fun')) {
				self.ui.funDropdown.val(spec.cell[0].fun);
				agg = AGGREGATE_REGISTRY.get(spec.cell[0].fun);
				if (agg.prototype.fieldCount >= self.ui.fields.length) {
					self.addFieldDropdowns(agg);
				}
				self.showHideFields(agg);
			}
			if (getProp(spec, 'cell', 0, 'fields')) {
				_.each(spec.cell[0].fields, function (f, i) {
					self.ui.fields[i].dropdown.val(f);
				});
			}

			debug.info('GRID // AGGREGATE CONTROL',
								 'View set aggregate to: ' + JSON.stringify(spec));
		};

		self.view.on(View.events.aggregateSet, function (spec) {
			syncAgg(spec)
		}, { who: self });
		*/

		self.addViewConfigChangeHandler('aggregateSet', function () {
			var spec = self.view.getAggregate();
			self.clear({ updateView: false });
			if (spec != null) {
				debug.info('GRID // AGGREGATE CONTROL',
					'View set aggregate to: ' + JSON.stringify(spec.all));

				underscore.each(spec.all, function (agg) {
					self.addField(agg.fun, AGGREGATE_REGISTRY.get(agg.fun).prototype.name, { updateView: false }, {
						fields: agg.fields,
						isHidden: agg.isHidden
					});
				});
			}
		});
		return self.ui.root;
	};

	// #updateView {{{2

	AggregateControl.prototype.updateView = function () {
		var self = this;
		var info = underscore.map(self.controlFields, function (cf) {
			return cf.getInfo();
		});
		self.ui.root.find('.wcdv_aggregate_control_error').hide();
		self.view.setAggregate(objFromArray(['group', 'pivot', 'cell', 'all'], [info]), {
			dontSendEventTo: self
		});
	};

	// #clearGraphFlag {{{2

	AggregateControl.prototype.clearGraphFlag = function () {
		var self = this;

		underscore.each(self.controlFields, function (cf) {
			cf.shouldGraph = false;
		});
	};

	// #triggerAggChange (PROTOTYPE) {{{2

	/**
	 * Perform necessary actions when the aggregate function is changed.
	 *
	 *   - Update the UI to show/hide field argument.
	 */

	AggregateControl.prototype.triggerAggChange = function () {
		var self = this;
		var agg = AGGREGATE_REGISTRY.get(self.ui.funDropdown.val());

		if (agg.prototype.fieldCount > self.ui.fields.length) {
			self.addFieldDropdowns(agg);
		}

		self.showHideFields(agg);

		var aggSpec = objFromArray(['group', 'pivot', 'cell', 'all'], [[{
			fun: self.ui.funDropdown.val(),
			fields: agg.prototype.fieldCount > 0 && mapLimit(self.ui.fields, function (f) {
				return f.dropdown.val();
			}, agg.prototype.fieldCount)
		}]]);

		self.view.setAggregate(aggSpec, {
			dontSendEventTo: self
		});
	};

	// #showHideFields (PROTOTYPE) {{{2

	AggregateControl.prototype.showHideFields = function (agg) {
		var self = this;
		var i;

		for (i = 0; i < self.ui.fields.length; i += 1) {
			if (i < agg.prototype.fieldCount) {
				self.ui.fields[i].div.show();
			}
			else {
				self.ui.fields[i].div.hide();
			}
		}
	};

	// #addFieldDropdowns (PROTOTYPE) {{{2

	/**
	 * For each field that an aggregate function requires, add a dropdown for it to the user interface.
	 * This is used by some prototype code that allows changing the aggregate function dynamically.  If
	 * the new aggregate function needs more fields than the old one (e.g. going from "count" to "sum")
	 * then this function adds the extra UI elements needed to get those fields from the user.
	 */

	AggregateControl.prototype.addFieldDropdowns = function (agg) {
		var self = this;

		debug.info('GRID // AGGREGATE CONTROL', 'Adding ' + (agg.prototype.fieldCount - self.ui.fields.length) + ' extra field dropdowns for the ' + agg.prototype.name + ' aggregate function');

		// Create the extra dropdowns that we need to get all the fields required by the aggregate
		// function selected.

		while (self.ui.fields.length < agg.prototype.fieldCount) {
			var x = {};
			x.div = jQuery('<div>').css({'margin-top': '4px'}).appendTo(self.ui.root);
			x.label = jQuery('<label>').text('Field:').appendTo(x.div);
			x.dropdown = jQuery('<select>').on('change', function () { self.triggerAggChange(); }).appendTo(x.div);
			self.ui.fields.push(x);
		}

		self.updateFieldDropdowns();
	};

	// #updateFieldDropdowns (PROTOTYPE) {{{2

	/**
	 * Populate the field dropdowns with the list of fields that are available in the view.  This is
	 * used by prototype code that allows changing the aggregate function dynamically.
	 */

	AggregateControl.prototype.updateFieldDropdowns = function () {
		var self = this;

		// Clear out the fields that are already in the dropdown (in case anything was removed, and to
		// prevent duplicates from being added).

		underscore.each(self.ui.fields, function (f) {
			f.dropdown.children().remove();
		});

		// Add <OPTION> elements for all the fields.

		underscore.each(determineColumns(self.colConfig, null, self.typeInfo), function (fieldName) {
			var text = getProp(self.colConfig.get(fieldName), 'displayText') || fieldName;
			underscore.each(self.ui.fields, function (f) {
				jQuery('<option>', { 'value': fieldName }).text(text).appendTo(f.dropdown);
			});
		});
	};

	// #toString {{{2

	AggregateControl.prototype.toString = function () {
		var self = this;

		return self.grid.id + ', Aggregate';
	};

	// FilterControl {{{1

	// Constructor {{{2

	/**
	 * Part of the user interface which lets users filter columns.
	 *
	 * @param {object} defn
	 *
	 * @param {View} view
	 *
	 * @param {Grid~Features} features
	 *
	 * @param {object} timing
	 *
	 * @class
	 * @extends GridControl
	 */

	var FilterControl = makeSubclass('FilterControl', GridControl, function () {
		var self = this;

		self.super.ctor.apply(self, arguments);
		self.gfs = new GridFilterSet(self.view, null, null, null, {
			dontSendEventTo: self
		});
	}, {
		isReorderable: false,
		controlFieldCtor: FilterControlField,
		controlType: 'Filter'
	});

	// #draw {{{2

	/**
	 * Create a DIV element that can be placed within the Grid instance to hold the user interface for
	 * the FilterControl.  The caller must add the result to the DOM somewhere.
	 *
	 * @returns {jQuery} The DIV element that holds the entire UI.
	 */

	FilterControl.prototype.draw = function (parent) {
		var self = this;

		/*
		parent.resizable({
			handles: 'e',
			minWidth: 100
		});
		*/

		parent.droppable({
			classes: {
				'ui-droppable-hover': 'wcdv_drop_target_hover'
			},
			drop: function (evt, ui) {
				// Turn this off for the sake of efficiency.
				//ui.draggable.draggable('option', 'refreshPositions', false);
				var field = ui.draggable.attr('data-wcdv-field');

				self.addField(field, getProp(self.colConfig.get(field), 'displayText'));
			}
		})
			._addEventDebugging('drop', 'FILTER');

		self.ui.root = jQuery('<div>').appendTo(parent);
		self.ui.title = jQuery('<div>')
			.addClass('wcdv_control_title_bar')
			.appendTo(self.ui.root);
		jQuery('<span>', { 'class': 'wcdv_control_title' })
			.text('Filters')
			.appendTo(self.ui.title);
		self.ui.clearBtn = self.makeClearButton(self.ui.title);
		self.ui.fields = jQuery('<ul>', {
			id: gensym(),
			'class': self.isHorizontal ? 'wcdv_control_horizontal' : 'wcdv_control_vertical'
		}).appendTo(self.ui.root);

		var dropdownContainer = jQuery('<div>').appendTo(self.ui.root);
		self.ui.dropdown = jQuery('<select>', { 'class': 'wcdv_control_addField' }).appendTo(dropdownContainer);
		self.ui.dropdown.on('change', function () {
			self.addField(self.ui.dropdown.val(), self.ui.dropdown.find('option:selected').text());
		});

		self.addViewConfigChangeHandler('filterSet', function () {
			var spec = self.view.getFilter();
			debug.info('GRID // FILTER CONTROL', 'View set filter to: %O', spec);
			self.clear({ updateView: false });
			underscore.each(spec, function (fieldSpec, field) {
				self.addField(field, getProp(self.colConfig.get(field), 'displayText'), { updateView: false });
				self.gfs.set(field, fieldSpec);
			});
		});

		return self.ui.root;
	};

	// #addField {{{2

	FilterControl.prototype.addField = function (field, displayText, opts) {
		var self = this;

		self.super.addField(field, displayText || getProp(self.colConfig.get(field), 'displayText'), opts);
	};

	// #removeField {{{2

	FilterControl.prototype.removeField = function (cf) {
		var self = this;

		self.gfs.removeField(cf.field.field);
		self.super.removeField(cf);
	};

	// #clear {{{2

	FilterControl.prototype.clear = function (opts) {
		var self = this;

		self.gfs.reset(opts);
		self.super.clear(opts);
	};

	// #updateView {{{2

	FilterControl.prototype.updateView = function () {
		// NOTE This function intentionally does nothing!
		//      It overrides the behavior of the superclass' method.
	};

	// #toString {{{2

	FilterControl.prototype.toString = function () {
		var self = this;

		return self.grid.id + ', Filter';
	};

	var utils = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.extend = extend;
	exports.indexOf = indexOf;
	exports.escapeExpression = escapeExpression;
	exports.isEmpty = isEmpty;
	exports.createFrame = createFrame;
	exports.blockParams = blockParams;
	exports.appendContextPath = appendContextPath;

	var escape = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#x27;',
	  '`': '&#x60;',
	  '=': '&#x3D;'
	};

	var badChars = /[&<>"'`=]/g,
	    possible = /[&<>"'`=]/;

	function escapeChar(chr) {
	  return escape[chr];
	}

	function extend(obj /* , ...source */) {
	  for (var i = 1; i < arguments.length; i++) {
	    for (var key in arguments[i]) {
	      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
	        obj[key] = arguments[i][key];
	      }
	    }
	  }

	  return obj;
	}

	var toString = Object.prototype.toString;

	exports.toString = toString;
	// Sourced from lodash
	// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
	/* eslint-disable func-style */
	var isFunction = function isFunction(value) {
	  return typeof value === 'function';
	};
	// fallback for older versions of Chrome and Safari
	/* istanbul ignore next */
	if (isFunction(/x/)) {
	  exports.isFunction = isFunction = function (value) {
	    return typeof value === 'function' && toString.call(value) === '[object Function]';
	  };
	}
	exports.isFunction = isFunction;

	/* eslint-enable func-style */

	/* istanbul ignore next */
	var isArray = Array.isArray || function (value) {
	  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
	};

	exports.isArray = isArray;
	// Older IE versions do not directly support indexOf so we must implement our own, sadly.

	function indexOf(array, value) {
	  for (var i = 0, len = array.length; i < len; i++) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	}

	function escapeExpression(string) {
	  if (typeof string !== 'string') {
	    // don't escape SafeStrings, since they're already safe
	    if (string && string.toHTML) {
	      return string.toHTML();
	    } else if (string == null) {
	      return '';
	    } else if (!string) {
	      return string + '';
	    }

	    // Force a string conversion as this will be done by the append regardless and
	    // the regex test will do this transparently behind the scenes, causing issues if
	    // an object's to string has escaped characters in it.
	    string = '' + string;
	  }

	  if (!possible.test(string)) {
	    return string;
	  }
	  return string.replace(badChars, escapeChar);
	}

	function isEmpty(value) {
	  if (!value && value !== 0) {
	    return true;
	  } else if (isArray(value) && value.length === 0) {
	    return true;
	  } else {
	    return false;
	  }
	}

	function createFrame(object) {
	  var frame = extend({}, object);
	  frame._parent = object;
	  return frame;
	}

	function blockParams(params, ids) {
	  params.path = ids;
	  return params;
	}

	function appendContextPath(contextPath, id) {
	  return (contextPath ? contextPath + '.' : '') + id;
	}

	});

	unwrapExports(utils);
	var utils_1 = utils.extend;
	var utils_2 = utils.indexOf;
	var utils_3 = utils.escapeExpression;
	var utils_4 = utils.isEmpty;
	var utils_5 = utils.createFrame;
	var utils_6 = utils.blockParams;
	var utils_7 = utils.appendContextPath;
	var utils_8 = utils.isFunction;
	var utils_9 = utils.isArray;

	var exception = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;

	var errorProps = ['description', 'fileName', 'lineNumber', 'endLineNumber', 'message', 'name', 'number', 'stack'];

	function Exception(message, node) {
	  var loc = node && node.loc,
	      line = undefined,
	      endLineNumber = undefined,
	      column = undefined,
	      endColumn = undefined;

	  if (loc) {
	    line = loc.start.line;
	    endLineNumber = loc.end.line;
	    column = loc.start.column;
	    endColumn = loc.end.column;

	    message += ' - ' + line + ':' + column;
	  }

	  var tmp = Error.prototype.constructor.call(this, message);

	  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
	  for (var idx = 0; idx < errorProps.length; idx++) {
	    this[errorProps[idx]] = tmp[errorProps[idx]];
	  }

	  /* istanbul ignore else */
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, Exception);
	  }

	  try {
	    if (loc) {
	      this.lineNumber = line;
	      this.endLineNumber = endLineNumber;

	      // Work around issue under safari where we can't directly set the column value
	      /* istanbul ignore next */
	      if (Object.defineProperty) {
	        Object.defineProperty(this, 'column', {
	          value: column,
	          enumerable: true
	        });
	        Object.defineProperty(this, 'endColumn', {
	          value: endColumn,
	          enumerable: true
	        });
	      } else {
	        this.column = column;
	        this.endColumn = endColumn;
	      }
	    }
	  } catch (nop) {
	    /* Ignore if the browser is very particular */
	  }
	}

	Exception.prototype = new Error();

	exports['default'] = Exception;
	module.exports = exports['default'];

	});

	unwrapExports(exception);

	var blockHelperMissing = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;



	exports['default'] = function (instance) {
	  instance.registerHelper('blockHelperMissing', function (context, options) {
	    var inverse = options.inverse,
	        fn = options.fn;

	    if (context === true) {
	      return fn(this);
	    } else if (context === false || context == null) {
	      return inverse(this);
	    } else if (utils.isArray(context)) {
	      if (context.length > 0) {
	        if (options.ids) {
	          options.ids = [options.name];
	        }

	        return instance.helpers.each(context, options);
	      } else {
	        return inverse(this);
	      }
	    } else {
	      if (options.data && options.ids) {
	        var data = utils.createFrame(options.data);
	        data.contextPath = utils.appendContextPath(options.data.contextPath, options.name);
	        options = { data: data };
	      }

	      return fn(context, options);
	    }
	  });
	};

	module.exports = exports['default'];

	});

	unwrapExports(blockHelperMissing);

	var each = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }





	var _exception2 = _interopRequireDefault(exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('each', function (context, options) {
	    if (!options) {
	      throw new _exception2['default']('Must pass iterator to #each');
	    }

	    var fn = options.fn,
	        inverse = options.inverse,
	        i = 0,
	        ret = '',
	        data = undefined,
	        contextPath = undefined;

	    if (options.data && options.ids) {
	      contextPath = utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
	    }

	    if (utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    if (options.data) {
	      data = utils.createFrame(options.data);
	    }

	    function execIteration(field, index, last) {
	      if (data) {
	        data.key = field;
	        data.index = index;
	        data.first = index === 0;
	        data.last = !!last;

	        if (contextPath) {
	          data.contextPath = contextPath + field;
	        }
	      }

	      ret = ret + fn(context[field], {
	        data: data,
	        blockParams: utils.blockParams([context[field], field], [contextPath + field, null])
	      });
	    }

	    if (context && typeof context === 'object') {
	      if (utils.isArray(context)) {
	        for (var j = context.length; i < j; i++) {
	          if (i in context) {
	            execIteration(i, i, i === context.length - 1);
	          }
	        }
	      } else if (commonjsGlobal.Symbol && context[commonjsGlobal.Symbol.iterator]) {
	        var newContext = [];
	        var iterator = context[commonjsGlobal.Symbol.iterator]();
	        for (var it = iterator.next(); !it.done; it = iterator.next()) {
	          newContext.push(it.value);
	        }
	        context = newContext;
	        for (var j = context.length; i < j; i++) {
	          execIteration(i, i, i === context.length - 1);
	        }
	      } else {
	        var priorKey = undefined;

	        for (var key in context) {
	          if (context.hasOwnProperty(key)) {
	            // We're running the iterations one step out of sync so we can detect
	            // the last iteration without have to scan the object twice and create
	            // an itermediate keys array.
	            if (priorKey !== undefined) {
	              execIteration(priorKey, i - 1);
	            }
	            priorKey = key;
	            i++;
	          }
	        }
	        if (priorKey !== undefined) {
	          execIteration(priorKey, i - 1, true);
	        }
	      }
	    }

	    if (i === 0) {
	      ret = inverse(this);
	    }

	    return ret;
	  });
	};

	module.exports = exports['default'];

	});

	unwrapExports(each);

	var helperMissing = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



	var _exception2 = _interopRequireDefault(exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('helperMissing', function () /* [args, ]options */{
	    if (arguments.length === 1) {
	      // A missing field in a {{foo}} construct.
	      return undefined;
	    } else {
	      // Someone is actually trying to call something, blow up.
	      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
	    }
	  });
	};

	module.exports = exports['default'];

	});

	unwrapExports(helperMissing);

	var _if = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }





	var _exception2 = _interopRequireDefault(exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('if', function (conditional, options) {
	    if (arguments.length != 2) {
	      throw new _exception2['default']('#if requires exactly one argument');
	    }
	    if (utils.isFunction(conditional)) {
	      conditional = conditional.call(this);
	    }

	    // Default behavior is to render the positive path if the value is truthy and not empty.
	    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
	    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
	    if (!options.hash.includeZero && !conditional || utils.isEmpty(conditional)) {
	      return options.inverse(this);
	    } else {
	      return options.fn(this);
	    }
	  });

	  instance.registerHelper('unless', function (conditional, options) {
	    if (arguments.length != 2) {
	      throw new _exception2['default']('#unless requires exactly one argument');
	    }
	    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
	  });
	};

	module.exports = exports['default'];

	});

	unwrapExports(_if);

	var log$1 = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('log', function () /* message, options */{
	    var args = [undefined],
	        options = arguments[arguments.length - 1];
	    for (var i = 0; i < arguments.length - 1; i++) {
	      args.push(arguments[i]);
	    }

	    var level = 1;
	    if (options.hash.level != null) {
	      level = options.hash.level;
	    } else if (options.data && options.data.level != null) {
	      level = options.data.level;
	    }
	    args[0] = level;

	    instance.log.apply(instance, args);
	  });
	};

	module.exports = exports['default'];

	});

	unwrapExports(log$1);

	var lookup = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('lookup', function (obj, field) {
	    if (!obj) {
	      return obj;
	    }
	    if (field === 'constructor' && !obj.propertyIsEnumerable(field)) {
	      return undefined;
	    }
	    return obj[field];
	  });
	};

	module.exports = exports['default'];

	});

	unwrapExports(lookup);

	var _with = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }





	var _exception2 = _interopRequireDefault(exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('with', function (context, options) {
	    if (arguments.length != 2) {
	      throw new _exception2['default']('#with requires exactly one argument');
	    }
	    if (utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    var fn = options.fn;

	    if (!utils.isEmpty(context)) {
	      var data = options.data;
	      if (options.data && options.ids) {
	        data = utils.createFrame(options.data);
	        data.contextPath = utils.appendContextPath(options.data.contextPath, options.ids[0]);
	      }

	      return fn(context, {
	        data: data,
	        blockParams: utils.blockParams([context], [data && data.contextPath])
	      });
	    } else {
	      return options.inverse(this);
	    }
	  });
	};

	module.exports = exports['default'];

	});

	unwrapExports(_with);

	var helpers = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.registerDefaultHelpers = registerDefaultHelpers;
	exports.moveHelperToHooks = moveHelperToHooks;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



	var _helpersBlockHelperMissing2 = _interopRequireDefault(blockHelperMissing);



	var _helpersEach2 = _interopRequireDefault(each);



	var _helpersHelperMissing2 = _interopRequireDefault(helperMissing);



	var _helpersIf2 = _interopRequireDefault(_if);



	var _helpersLog2 = _interopRequireDefault(log$1);



	var _helpersLookup2 = _interopRequireDefault(lookup);



	var _helpersWith2 = _interopRequireDefault(_with);

	function registerDefaultHelpers(instance) {
	  _helpersBlockHelperMissing2['default'](instance);
	  _helpersEach2['default'](instance);
	  _helpersHelperMissing2['default'](instance);
	  _helpersIf2['default'](instance);
	  _helpersLog2['default'](instance);
	  _helpersLookup2['default'](instance);
	  _helpersWith2['default'](instance);
	}

	function moveHelperToHooks(instance, helperName, keepHelper) {
	  if (instance.helpers[helperName]) {
	    instance.hooks[helperName] = instance.helpers[helperName];
	    if (!keepHelper) {
	      delete instance.helpers[helperName];
	    }
	  }
	}

	});

	unwrapExports(helpers);
	var helpers_1 = helpers.registerDefaultHelpers;
	var helpers_2 = helpers.moveHelperToHooks;

	var inline = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;



	exports['default'] = function (instance) {
	  instance.registerDecorator('inline', function (fn, props, container, options) {
	    var ret = fn;
	    if (!props.partials) {
	      props.partials = {};
	      ret = function (context, options) {
	        // Create a new partials stack frame prior to exec.
	        var original = container.partials;
	        container.partials = utils.extend({}, original, props.partials);
	        var ret = fn(context, options);
	        container.partials = original;
	        return ret;
	      };
	    }

	    props.partials[options.args[0]] = options.fn;

	    return ret;
	  });
	};

	module.exports = exports['default'];

	});

	unwrapExports(inline);

	var decorators = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.registerDefaultDecorators = registerDefaultDecorators;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



	var _decoratorsInline2 = _interopRequireDefault(inline);

	function registerDefaultDecorators(instance) {
	  _decoratorsInline2['default'](instance);
	}

	});

	unwrapExports(decorators);
	var decorators_1 = decorators.registerDefaultDecorators;

	var logger_1 = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;



	var logger = {
	  methodMap: ['debug', 'info', 'warn', 'error'],
	  level: 'info',

	  // Maps a given level value to the `methodMap` indexes above.
	  lookupLevel: function lookupLevel(level) {
	    if (typeof level === 'string') {
	      var levelMap = utils.indexOf(logger.methodMap, level.toLowerCase());
	      if (levelMap >= 0) {
	        level = levelMap;
	      } else {
	        level = parseInt(level, 10);
	      }
	    }

	    return level;
	  },

	  // Can be overridden in the host environment
	  log: function log(level) {
	    level = logger.lookupLevel(level);

	    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
	      var method = logger.methodMap[level];
	      if (!console[method]) {
	        // eslint-disable-line no-console
	        method = 'log';
	      }

	      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        message[_key - 1] = arguments[_key];
	      }

	      console[method].apply(console, message); // eslint-disable-line no-console
	    }
	  }
	};

	exports['default'] = logger;
	module.exports = exports['default'];

	});

	unwrapExports(logger_1);

	var base = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.HandlebarsEnvironment = HandlebarsEnvironment;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }





	var _exception2 = _interopRequireDefault(exception);







	var _logger2 = _interopRequireDefault(logger_1);

	var VERSION = '4.5.1';
	exports.VERSION = VERSION;
	var COMPILER_REVISION = 8;
	exports.COMPILER_REVISION = COMPILER_REVISION;
	var LAST_COMPATIBLE_COMPILER_REVISION = 7;

	exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
	var REVISION_CHANGES = {
	  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
	  2: '== 1.0.0-rc.3',
	  3: '== 1.0.0-rc.4',
	  4: '== 1.x.x',
	  5: '== 2.0.0-alpha.x',
	  6: '>= 2.0.0-beta.1',
	  7: '>= 4.0.0 <4.3.0',
	  8: '>= 4.3.0'
	};

	exports.REVISION_CHANGES = REVISION_CHANGES;
	var objectType = '[object Object]';

	function HandlebarsEnvironment(helpers$1, partials, decorators$1) {
	  this.helpers = helpers$1 || {};
	  this.partials = partials || {};
	  this.decorators = decorators$1 || {};

	  helpers.registerDefaultHelpers(this);
	  decorators.registerDefaultDecorators(this);
	}

	HandlebarsEnvironment.prototype = {
	  constructor: HandlebarsEnvironment,

	  logger: _logger2['default'],
	  log: _logger2['default'].log,

	  registerHelper: function registerHelper(name, fn) {
	    if (utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple helpers');
	      }
	      utils.extend(this.helpers, name);
	    } else {
	      this.helpers[name] = fn;
	    }
	  },
	  unregisterHelper: function unregisterHelper(name) {
	    delete this.helpers[name];
	  },

	  registerPartial: function registerPartial(name, partial) {
	    if (utils.toString.call(name) === objectType) {
	      utils.extend(this.partials, name);
	    } else {
	      if (typeof partial === 'undefined') {
	        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
	      }
	      this.partials[name] = partial;
	    }
	  },
	  unregisterPartial: function unregisterPartial(name) {
	    delete this.partials[name];
	  },

	  registerDecorator: function registerDecorator(name, fn) {
	    if (utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple decorators');
	      }
	      utils.extend(this.decorators, name);
	    } else {
	      this.decorators[name] = fn;
	    }
	  },
	  unregisterDecorator: function unregisterDecorator(name) {
	    delete this.decorators[name];
	  }
	};

	var log = _logger2['default'].log;

	exports.log = log;
	exports.createFrame = utils.createFrame;
	exports.logger = _logger2['default'];

	});

	unwrapExports(base);
	var base_1 = base.HandlebarsEnvironment;
	var base_2 = base.VERSION;
	var base_3 = base.COMPILER_REVISION;
	var base_4 = base.LAST_COMPATIBLE_COMPILER_REVISION;
	var base_5 = base.REVISION_CHANGES;
	var base_6 = base.log;
	var base_7 = base.createFrame;
	var base_8 = base.logger;

	var safeString = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	function SafeString(string) {
	  this.string = string;
	}

	SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
	  return '' + this.string;
	};

	exports['default'] = SafeString;
	module.exports = exports['default'];

	});

	unwrapExports(safeString);

	var runtime = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.checkRevision = checkRevision;
	exports.template = template;
	exports.wrapProgram = wrapProgram;
	exports.resolvePartial = resolvePartial;
	exports.invokePartial = invokePartial;
	exports.noop = noop;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	// istanbul ignore next

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }



	var Utils = _interopRequireWildcard(utils);



	var _exception2 = _interopRequireDefault(exception);





	function checkRevision(compilerInfo) {
	  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
	      currentRevision = base.COMPILER_REVISION;

	  if (compilerRevision >= base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= base.COMPILER_REVISION) {
	    return;
	  }

	  if (compilerRevision < base.LAST_COMPATIBLE_COMPILER_REVISION) {
	    var runtimeVersions = base.REVISION_CHANGES[currentRevision],
	        compilerVersions = base.REVISION_CHANGES[compilerRevision];
	    throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
	  } else {
	    // Use the embedded version info since the runtime doesn't know about this revision yet
	    throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
	  }
	}

	function template(templateSpec, env) {

	  /* istanbul ignore next */
	  if (!env) {
	    throw new _exception2['default']('No environment passed to template');
	  }
	  if (!templateSpec || !templateSpec.main) {
	    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
	  }

	  templateSpec.main.decorator = templateSpec.main_d;

	  // Note: Using env.VM references rather than local var references throughout this section to allow
	  // for external users to override these as pseudo-supported APIs.
	  env.VM.checkRevision(templateSpec.compiler);

	  // backwards compatibility for precompiled templates with compiler-version 7 (<4.3.0)
	  var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;

	  function invokePartialWrapper(partial, context, options) {
	    if (options.hash) {
	      context = Utils.extend({}, context, options.hash);
	      if (options.ids) {
	        options.ids[0] = true;
	      }
	    }
	    partial = env.VM.resolvePartial.call(this, partial, context, options);

	    var optionsWithHooks = Utils.extend({}, options, { hooks: this.hooks });

	    var result = env.VM.invokePartial.call(this, partial, context, optionsWithHooks);

	    if (result == null && env.compile) {
	      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
	      result = options.partials[options.name](context, optionsWithHooks);
	    }
	    if (result != null) {
	      if (options.indent) {
	        var lines = result.split('\n');
	        for (var i = 0, l = lines.length; i < l; i++) {
	          if (!lines[i] && i + 1 === l) {
	            break;
	          }

	          lines[i] = options.indent + lines[i];
	        }
	        result = lines.join('\n');
	      }
	      return result;
	    } else {
	      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
	    }
	  }

	  // Just add water
	  var container = {
	    strict: function strict(obj, name, loc) {
	      if (!obj || !(name in obj)) {
	        throw new _exception2['default']('"' + name + '" not defined in ' + obj, { loc: loc });
	      }
	      return obj[name];
	    },
	    lookup: function lookup(depths, name) {
	      var len = depths.length;
	      for (var i = 0; i < len; i++) {
	        if (depths[i] && depths[i][name] != null) {
	          return depths[i][name];
	        }
	      }
	    },
	    lambda: function lambda(current, context) {
	      return typeof current === 'function' ? current.call(context) : current;
	    },

	    escapeExpression: Utils.escapeExpression,
	    invokePartial: invokePartialWrapper,

	    fn: function fn(i) {
	      var ret = templateSpec[i];
	      ret.decorator = templateSpec[i + '_d'];
	      return ret;
	    },

	    programs: [],
	    program: function program(i, data, declaredBlockParams, blockParams, depths) {
	      var programWrapper = this.programs[i],
	          fn = this.fn(i);
	      if (data || depths || blockParams || declaredBlockParams) {
	        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
	      } else if (!programWrapper) {
	        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
	      }
	      return programWrapper;
	    },

	    data: function data(value, depth) {
	      while (value && depth--) {
	        value = value._parent;
	      }
	      return value;
	    },
	    // An empty object to use as replacement for null-contexts
	    nullContext: Object.seal({}),

	    noop: env.VM.noop,
	    compilerInfo: templateSpec.compiler
	  };

	  function ret(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var data = options.data;

	    ret._setup(options);
	    if (!options.partial && templateSpec.useData) {
	      data = initData(context, data);
	    }
	    var depths = undefined,
	        blockParams = templateSpec.useBlockParams ? [] : undefined;
	    if (templateSpec.useDepths) {
	      if (options.depths) {
	        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
	      } else {
	        depths = [context];
	      }
	    }

	    function main(context /*, options*/) {
	      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
	    }
	    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
	    return main(context, options);
	  }
	  ret.isTop = true;

	  ret._setup = function (options) {
	    if (!options.partial) {
	      container.helpers = Utils.extend({}, env.helpers, options.helpers);

	      if (templateSpec.usePartial) {
	        container.partials = Utils.extend({}, env.partials, options.partials);
	      }
	      if (templateSpec.usePartial || templateSpec.useDecorators) {
	        container.decorators = Utils.extend({}, env.decorators, options.decorators);
	      }

	      container.hooks = {};

	      var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
	      helpers.moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);
	      helpers.moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);
	    } else {
	      container.helpers = options.helpers;
	      container.partials = options.partials;
	      container.decorators = options.decorators;
	      container.hooks = options.hooks;
	    }
	  };

	  ret._child = function (i, data, blockParams, depths) {
	    if (templateSpec.useBlockParams && !blockParams) {
	      throw new _exception2['default']('must pass block params');
	    }
	    if (templateSpec.useDepths && !depths) {
	      throw new _exception2['default']('must pass parent depths');
	    }

	    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
	  };
	  return ret;
	}

	function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
	  function prog(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var currentDepths = depths;
	    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
	      currentDepths = [context].concat(depths);
	    }

	    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
	  }

	  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

	  prog.program = i;
	  prog.depth = depths ? depths.length : 0;
	  prog.blockParams = declaredBlockParams || 0;
	  return prog;
	}

	/**
	 * This is currently part of the official API, therefore implementation details should not be changed.
	 */

	function resolvePartial(partial, context, options) {
	  if (!partial) {
	    if (options.name === '@partial-block') {
	      partial = options.data['partial-block'];
	    } else {
	      partial = options.partials[options.name];
	    }
	  } else if (!partial.call && !options.name) {
	    // This is a dynamic partial that returned a string
	    options.name = partial;
	    partial = options.partials[partial];
	  }
	  return partial;
	}

	function invokePartial(partial, context, options) {
	  // Use the current closure context to save the partial-block if this partial
	  var currentPartialBlock = options.data && options.data['partial-block'];
	  options.partial = true;
	  if (options.ids) {
	    options.data.contextPath = options.ids[0] || options.data.contextPath;
	  }

	  var partialBlock = undefined;
	  if (options.fn && options.fn !== noop) {
	    (function () {
	      options.data = base.createFrame(options.data);
	      // Wrapper function to get access to currentPartialBlock from the closure
	      var fn = options.fn;
	      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        // Restore the partial-block from the closure for the execution of the block
	        // i.e. the part inside the block of the partial call.
	        options.data = base.createFrame(options.data);
	        options.data['partial-block'] = currentPartialBlock;
	        return fn(context, options);
	      };
	      if (fn.partials) {
	        options.partials = Utils.extend({}, options.partials, fn.partials);
	      }
	    })();
	  }

	  if (partial === undefined && partialBlock) {
	    partial = partialBlock;
	  }

	  if (partial === undefined) {
	    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
	  } else if (partial instanceof Function) {
	    return partial(context, options);
	  }
	}

	function noop() {
	  return '';
	}

	function initData(context, data) {
	  if (!data || !('root' in data)) {
	    data = data ? base.createFrame(data) : {};
	    data.root = context;
	  }
	  return data;
	}

	function executeDecorators(fn, prog, container, depths, data, blockParams) {
	  if (fn.decorator) {
	    var props = {};
	    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
	    Utils.extend(prog, props);
	  }
	  return prog;
	}

	});

	unwrapExports(runtime);
	var runtime_1 = runtime.checkRevision;
	var runtime_2 = runtime.template;
	var runtime_3 = runtime.wrapProgram;
	var runtime_4 = runtime.resolvePartial;
	var runtime_5 = runtime.invokePartial;
	var runtime_6 = runtime.noop;

	var noConflict = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;

	exports['default'] = function (Handlebars) {
	  /* istanbul ignore next */
	  var root = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : window,
	      $Handlebars = root.Handlebars;
	  /* istanbul ignore next */
	  Handlebars.noConflict = function () {
	    if (root.Handlebars === Handlebars) {
	      root.Handlebars = $Handlebars;
	    }
	    return Handlebars;
	  };
	};

	module.exports = exports['default'];

	});

	unwrapExports(noConflict);

	var handlebars_runtime = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	// istanbul ignore next

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }



	var base$1 = _interopRequireWildcard(base);

	// Each of these augment the Handlebars object. No need to setup here.
	// (This is done to easily share code between commonjs and browse envs)



	var _handlebarsSafeString2 = _interopRequireDefault(safeString);



	var _handlebarsException2 = _interopRequireDefault(exception);



	var Utils = _interopRequireWildcard(utils);



	var runtime$1 = _interopRequireWildcard(runtime);



	var _handlebarsNoConflict2 = _interopRequireDefault(noConflict);

	// For compatibility and usage outside of module systems, make the Handlebars object a namespace
	function create() {
	  var hb = new base$1.HandlebarsEnvironment();

	  Utils.extend(hb, base$1);
	  hb.SafeString = _handlebarsSafeString2['default'];
	  hb.Exception = _handlebarsException2['default'];
	  hb.Utils = Utils;
	  hb.escapeExpression = Utils.escapeExpression;

	  hb.VM = runtime$1;
	  hb.template = function (spec) {
	    return runtime$1.template(spec, hb);
	  };

	  return hb;
	}

	var inst = create();
	inst.create = create;

	_handlebarsNoConflict2['default'](inst);

	inst['default'] = inst;

	exports['default'] = inst;
	module.exports = exports['default'];

	});

	unwrapExports(handlebars_runtime);

	var ast = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	var AST = {
	  // Public API used to evaluate derived attributes regarding AST nodes
	  helpers: {
	    // a mustache is definitely a helper if:
	    // * it is an eligible helper, and
	    // * it has at least one parameter or hash segment
	    helperExpression: function helperExpression(node) {
	      return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
	    },

	    scopedId: function scopedId(path) {
	      return (/^\.|this\b/.test(path.original)
	      );
	    },

	    // an ID is simple if it only has one part, and that part is not
	    // `..` or `this`.
	    simpleId: function simpleId(path) {
	      return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
	    }
	  }
	};

	// Must be exported as an object rather than the root of the module as the jison lexer
	// must modify the object to operate properly.
	exports['default'] = AST;
	module.exports = exports['default'];

	});

	unwrapExports(ast);

	var parser = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	var handlebars = (function () {
	    var parser = { trace: function trace() {},
	        yy: {},
	        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
	        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
	        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
	        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {

	            var $0 = $$.length - 1;
	            switch (yystate) {
	                case 1:
	                    return $$[$0 - 1];
	                    break;
	                case 2:
	                    this.$ = yy.prepareProgram($$[$0]);
	                    break;
	                case 3:
	                    this.$ = $$[$0];
	                    break;
	                case 4:
	                    this.$ = $$[$0];
	                    break;
	                case 5:
	                    this.$ = $$[$0];
	                    break;
	                case 6:
	                    this.$ = $$[$0];
	                    break;
	                case 7:
	                    this.$ = $$[$0];
	                    break;
	                case 8:
	                    this.$ = $$[$0];
	                    break;
	                case 9:
	                    this.$ = {
	                        type: 'CommentStatement',
	                        value: yy.stripComment($$[$0]),
	                        strip: yy.stripFlags($$[$0], $$[$0]),
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 10:
	                    this.$ = {
	                        type: 'ContentStatement',
	                        original: $$[$0],
	                        value: $$[$0],
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 11:
	                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
	                    break;
	                case 12:
	                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
	                    break;
	                case 13:
	                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
	                    break;
	                case 14:
	                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
	                    break;
	                case 15:
	                    this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 16:
	                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 17:
	                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 18:
	                    this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
	                    break;
	                case 19:
	                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
	                        program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
	                    program.chained = true;

	                    this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

	                    break;
	                case 20:
	                    this.$ = $$[$0];
	                    break;
	                case 21:
	                    this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
	                    break;
	                case 22:
	                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
	                    break;
	                case 23:
	                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
	                    break;
	                case 24:
	                    this.$ = {
	                        type: 'PartialStatement',
	                        name: $$[$0 - 3],
	                        params: $$[$0 - 2],
	                        hash: $$[$0 - 1],
	                        indent: '',
	                        strip: yy.stripFlags($$[$0 - 4], $$[$0]),
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 25:
	                    this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
	                    break;
	                case 26:
	                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
	                    break;
	                case 27:
	                    this.$ = $$[$0];
	                    break;
	                case 28:
	                    this.$ = $$[$0];
	                    break;
	                case 29:
	                    this.$ = {
	                        type: 'SubExpression',
	                        path: $$[$0 - 3],
	                        params: $$[$0 - 2],
	                        hash: $$[$0 - 1],
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 30:
	                    this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 31:
	                    this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 32:
	                    this.$ = yy.id($$[$0 - 1]);
	                    break;
	                case 33:
	                    this.$ = $$[$0];
	                    break;
	                case 34:
	                    this.$ = $$[$0];
	                    break;
	                case 35:
	                    this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 36:
	                    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
	                    break;
	                case 37:
	                    this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
	                    break;
	                case 38:
	                    this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
	                    break;
	                case 39:
	                    this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
	                    break;
	                case 40:
	                    this.$ = $$[$0];
	                    break;
	                case 41:
	                    this.$ = $$[$0];
	                    break;
	                case 42:
	                    this.$ = yy.preparePath(true, $$[$0], this._$);
	                    break;
	                case 43:
	                    this.$ = yy.preparePath(false, $$[$0], this._$);
	                    break;
	                case 44:
	                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
	                    break;
	                case 45:
	                    this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
	                    break;
	                case 46:
	                    this.$ = [];
	                    break;
	                case 47:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 48:
	                    this.$ = [];
	                    break;
	                case 49:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 50:
	                    this.$ = [];
	                    break;
	                case 51:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 58:
	                    this.$ = [];
	                    break;
	                case 59:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 64:
	                    this.$ = [];
	                    break;
	                case 65:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 70:
	                    this.$ = [];
	                    break;
	                case 71:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 78:
	                    this.$ = [];
	                    break;
	                case 79:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 82:
	                    this.$ = [];
	                    break;
	                case 83:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 86:
	                    this.$ = [];
	                    break;
	                case 87:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 90:
	                    this.$ = [];
	                    break;
	                case 91:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 94:
	                    this.$ = [];
	                    break;
	                case 95:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 98:
	                    this.$ = [$$[$0]];
	                    break;
	                case 99:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 100:
	                    this.$ = [$$[$0]];
	                    break;
	                case 101:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	            }
	        },
	        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
	        defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
	        parseError: function parseError(str, hash) {
	            throw new Error(str);
	        },
	        parse: function parse(input) {
	            var self = this,
	                stack = [0],
	                vstack = [null],
	                lstack = [],
	                table = this.table,
	                yytext = "",
	                yylineno = 0,
	                yyleng = 0,
	                recovering = 0;
	            this.lexer.setInput(input);
	            this.lexer.yy = this.yy;
	            this.yy.lexer = this.lexer;
	            this.yy.parser = this;
	            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
	            var yyloc = this.lexer.yylloc;
	            lstack.push(yyloc);
	            var ranges = this.lexer.options && this.lexer.options.ranges;
	            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
	            function lex() {
	                var token;
	                token = self.lexer.lex() || 1;
	                if (typeof token !== "number") {
	                    token = self.symbols_[token] || token;
	                }
	                return token;
	            }
	            var symbol,
	                preErrorSymbol,
	                state,
	                action,
	                r,
	                yyval = {},
	                p,
	                len,
	                newState,
	                expected;
	            while (true) {
	                state = stack[stack.length - 1];
	                if (this.defaultActions[state]) {
	                    action = this.defaultActions[state];
	                } else {
	                    if (symbol === null || typeof symbol == "undefined") {
	                        symbol = lex();
	                    }
	                    action = table[state] && table[state][symbol];
	                }
	                if (typeof action === "undefined" || !action.length || !action[0]) {
	                    var errStr = "";
	                    if (!recovering) {
	                        expected = [];
	                        for (p in table[state]) if (this.terminals_[p] && p > 2) {
	                            expected.push("'" + this.terminals_[p] + "'");
	                        }
	                        if (this.lexer.showPosition) {
	                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
	                        } else {
	                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
	                        }
	                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
	                    }
	                }
	                if (action[0] instanceof Array && action.length > 1) {
	                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
	                }
	                switch (action[0]) {
	                    case 1:
	                        stack.push(symbol);
	                        vstack.push(this.lexer.yytext);
	                        lstack.push(this.lexer.yylloc);
	                        stack.push(action[1]);
	                        symbol = null;
	                        if (!preErrorSymbol) {
	                            yyleng = this.lexer.yyleng;
	                            yytext = this.lexer.yytext;
	                            yylineno = this.lexer.yylineno;
	                            yyloc = this.lexer.yylloc;
	                            if (recovering > 0) recovering--;
	                        } else {
	                            symbol = preErrorSymbol;
	                            preErrorSymbol = null;
	                        }
	                        break;
	                    case 2:
	                        len = this.productions_[action[1]][1];
	                        yyval.$ = vstack[vstack.length - len];
	                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
	                        if (ranges) {
	                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
	                        }
	                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
	                        if (typeof r !== "undefined") {
	                            return r;
	                        }
	                        if (len) {
	                            stack = stack.slice(0, -1 * len * 2);
	                            vstack = vstack.slice(0, -1 * len);
	                            lstack = lstack.slice(0, -1 * len);
	                        }
	                        stack.push(this.productions_[action[1]][0]);
	                        vstack.push(yyval.$);
	                        lstack.push(yyval._$);
	                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	                        stack.push(newState);
	                        break;
	                    case 3:
	                        return true;
	                }
	            }
	            return true;
	        }
	    };
	    /* Jison generated lexer */
	    var lexer = (function () {
	        var lexer = { EOF: 1,
	            parseError: function parseError(str, hash) {
	                if (this.yy.parser) {
	                    this.yy.parser.parseError(str, hash);
	                } else {
	                    throw new Error(str);
	                }
	            },
	            setInput: function setInput(input) {
	                this._input = input;
	                this._more = this._less = this.done = false;
	                this.yylineno = this.yyleng = 0;
	                this.yytext = this.matched = this.match = '';
	                this.conditionStack = ['INITIAL'];
	                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
	                if (this.options.ranges) this.yylloc.range = [0, 0];
	                this.offset = 0;
	                return this;
	            },
	            input: function input() {
	                var ch = this._input[0];
	                this.yytext += ch;
	                this.yyleng++;
	                this.offset++;
	                this.match += ch;
	                this.matched += ch;
	                var lines = ch.match(/(?:\r\n?|\n).*/g);
	                if (lines) {
	                    this.yylineno++;
	                    this.yylloc.last_line++;
	                } else {
	                    this.yylloc.last_column++;
	                }
	                if (this.options.ranges) this.yylloc.range[1]++;

	                this._input = this._input.slice(1);
	                return ch;
	            },
	            unput: function unput(ch) {
	                var len = ch.length;
	                var lines = ch.split(/(?:\r\n?|\n)/g);

	                this._input = ch + this._input;
	                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
	                //this.yyleng -= len;
	                this.offset -= len;
	                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	                this.match = this.match.substr(0, this.match.length - 1);
	                this.matched = this.matched.substr(0, this.matched.length - 1);

	                if (lines.length - 1) this.yylineno -= lines.length - 1;
	                var r = this.yylloc.range;

	                this.yylloc = { first_line: this.yylloc.first_line,
	                    last_line: this.yylineno + 1,
	                    first_column: this.yylloc.first_column,
	                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
	                };

	                if (this.options.ranges) {
	                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	                }
	                return this;
	            },
	            more: function more() {
	                this._more = true;
	                return this;
	            },
	            less: function less(n) {
	                this.unput(this.match.slice(n));
	            },
	            pastInput: function pastInput() {
	                var past = this.matched.substr(0, this.matched.length - this.match.length);
	                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
	            },
	            upcomingInput: function upcomingInput() {
	                var next = this.match;
	                if (next.length < 20) {
	                    next += this._input.substr(0, 20 - next.length);
	                }
	                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	            },
	            showPosition: function showPosition() {
	                var pre = this.pastInput();
	                var c = new Array(pre.length + 1).join("-");
	                return pre + this.upcomingInput() + "\n" + c + "^";
	            },
	            next: function next() {
	                if (this.done) {
	                    return this.EOF;
	                }
	                if (!this._input) this.done = true;

	                var token, match, tempMatch, index, lines;
	                if (!this._more) {
	                    this.yytext = '';
	                    this.match = '';
	                }
	                var rules = this._currentRules();
	                for (var i = 0; i < rules.length; i++) {
	                    tempMatch = this._input.match(this.rules[rules[i]]);
	                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                        match = tempMatch;
	                        index = i;
	                        if (!this.options.flex) break;
	                    }
	                }
	                if (match) {
	                    lines = match[0].match(/(?:\r\n?|\n).*/g);
	                    if (lines) this.yylineno += lines.length;
	                    this.yylloc = { first_line: this.yylloc.last_line,
	                        last_line: this.yylineno + 1,
	                        first_column: this.yylloc.last_column,
	                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
	                    this.yytext += match[0];
	                    this.match += match[0];
	                    this.matches = match;
	                    this.yyleng = this.yytext.length;
	                    if (this.options.ranges) {
	                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
	                    }
	                    this._more = false;
	                    this._input = this._input.slice(match[0].length);
	                    this.matched += match[0];
	                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
	                    if (this.done && this._input) this.done = false;
	                    if (token) return token;else return;
	                }
	                if (this._input === "") {
	                    return this.EOF;
	                } else {
	                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
	                }
	            },
	            lex: function lex() {
	                var r = this.next();
	                if (typeof r !== 'undefined') {
	                    return r;
	                } else {
	                    return this.lex();
	                }
	            },
	            begin: function begin(condition) {
	                this.conditionStack.push(condition);
	            },
	            popState: function popState() {
	                return this.conditionStack.pop();
	            },
	            _currentRules: function _currentRules() {
	                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	            },
	            topState: function topState() {
	                return this.conditionStack[this.conditionStack.length - 2];
	            },
	            pushState: function begin(condition) {
	                this.begin(condition);
	            } };
	        lexer.options = {};
	        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

	            function strip(start, end) {
	                return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
	            }
	            switch ($avoiding_name_collisions) {
	                case 0:
	                    if (yy_.yytext.slice(-2) === "\\\\") {
	                        strip(0, 1);
	                        this.begin("mu");
	                    } else if (yy_.yytext.slice(-1) === "\\") {
	                        strip(0, 1);
	                        this.begin("emu");
	                    } else {
	                        this.begin("mu");
	                    }
	                    if (yy_.yytext) return 15;

	                    break;
	                case 1:
	                    return 15;
	                    break;
	                case 2:
	                    this.popState();
	                    return 15;

	                    break;
	                case 3:
	                    this.begin('raw');return 15;
	                    break;
	                case 4:
	                    this.popState();
	                    // Should be using `this.topState()` below, but it currently
	                    // returns the second top instead of the first top. Opened an
	                    // issue about it at https://github.com/zaach/jison/issues/291
	                    if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
	                        return 15;
	                    } else {
	                        strip(5, 9);
	                        return 'END_RAW_BLOCK';
	                    }

	                    break;
	                case 5:
	                    return 15;
	                    break;
	                case 6:
	                    this.popState();
	                    return 14;

	                    break;
	                case 7:
	                    return 65;
	                    break;
	                case 8:
	                    return 68;
	                    break;
	                case 9:
	                    return 19;
	                    break;
	                case 10:
	                    this.popState();
	                    this.begin('raw');
	                    return 23;

	                    break;
	                case 11:
	                    return 55;
	                    break;
	                case 12:
	                    return 60;
	                    break;
	                case 13:
	                    return 29;
	                    break;
	                case 14:
	                    return 47;
	                    break;
	                case 15:
	                    this.popState();return 44;
	                    break;
	                case 16:
	                    this.popState();return 44;
	                    break;
	                case 17:
	                    return 34;
	                    break;
	                case 18:
	                    return 39;
	                    break;
	                case 19:
	                    return 51;
	                    break;
	                case 20:
	                    return 48;
	                    break;
	                case 21:
	                    this.unput(yy_.yytext);
	                    this.popState();
	                    this.begin('com');

	                    break;
	                case 22:
	                    this.popState();
	                    return 14;

	                    break;
	                case 23:
	                    return 48;
	                    break;
	                case 24:
	                    return 73;
	                    break;
	                case 25:
	                    return 72;
	                    break;
	                case 26:
	                    return 72;
	                    break;
	                case 27:
	                    return 87;
	                    break;
	                case 28:
	                    // ignore whitespace
	                    break;
	                case 29:
	                    this.popState();return 54;
	                    break;
	                case 30:
	                    this.popState();return 33;
	                    break;
	                case 31:
	                    yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 80;
	                    break;
	                case 32:
	                    yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 80;
	                    break;
	                case 33:
	                    return 85;
	                    break;
	                case 34:
	                    return 82;
	                    break;
	                case 35:
	                    return 82;
	                    break;
	                case 36:
	                    return 83;
	                    break;
	                case 37:
	                    return 84;
	                    break;
	                case 38:
	                    return 81;
	                    break;
	                case 39:
	                    return 75;
	                    break;
	                case 40:
	                    return 77;
	                    break;
	                case 41:
	                    return 72;
	                    break;
	                case 42:
	                    yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');return 72;
	                    break;
	                case 43:
	                    return 'INVALID';
	                    break;
	                case 44:
	                    return 5;
	                    break;
	            }
	        };
	        lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
	        lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
	        return lexer;
	    })();
	    parser.lexer = lexer;
	    function Parser() {
	        this.yy = {};
	    }Parser.prototype = parser;parser.Parser = Parser;
	    return new Parser();
	})();exports["default"] = handlebars;
	module.exports = exports["default"];

	});

	unwrapExports(parser);

	var visitor = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



	var _exception2 = _interopRequireDefault(exception);

	function Visitor() {
	  this.parents = [];
	}

	Visitor.prototype = {
	  constructor: Visitor,
	  mutating: false,

	  // Visits a given value. If mutating, will replace the value if necessary.
	  acceptKey: function acceptKey(node, name) {
	    var value = this.accept(node[name]);
	    if (this.mutating) {
	      // Hacky sanity check: This may have a few false positives for type for the helper
	      // methods but will generally do the right thing without a lot of overhead.
	      if (value && !Visitor.prototype[value.type]) {
	        throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
	      }
	      node[name] = value;
	    }
	  },

	  // Performs an accept operation with added sanity check to ensure
	  // required keys are not removed.
	  acceptRequired: function acceptRequired(node, name) {
	    this.acceptKey(node, name);

	    if (!node[name]) {
	      throw new _exception2['default'](node.type + ' requires ' + name);
	    }
	  },

	  // Traverses a given array. If mutating, empty respnses will be removed
	  // for child elements.
	  acceptArray: function acceptArray(array) {
	    for (var i = 0, l = array.length; i < l; i++) {
	      this.acceptKey(array, i);

	      if (!array[i]) {
	        array.splice(i, 1);
	        i--;
	        l--;
	      }
	    }
	  },

	  accept: function accept(object) {
	    if (!object) {
	      return;
	    }

	    /* istanbul ignore next: Sanity code */
	    if (!this[object.type]) {
	      throw new _exception2['default']('Unknown type: ' + object.type, object);
	    }

	    if (this.current) {
	      this.parents.unshift(this.current);
	    }
	    this.current = object;

	    var ret = this[object.type](object);

	    this.current = this.parents.shift();

	    if (!this.mutating || ret) {
	      return ret;
	    } else if (ret !== false) {
	      return object;
	    }
	  },

	  Program: function Program(program) {
	    this.acceptArray(program.body);
	  },

	  MustacheStatement: visitSubExpression,
	  Decorator: visitSubExpression,

	  BlockStatement: visitBlock,
	  DecoratorBlock: visitBlock,

	  PartialStatement: visitPartial,
	  PartialBlockStatement: function PartialBlockStatement(partial) {
	    visitPartial.call(this, partial);

	    this.acceptKey(partial, 'program');
	  },

	  ContentStatement: function ContentStatement() /* content */{},
	  CommentStatement: function CommentStatement() /* comment */{},

	  SubExpression: visitSubExpression,

	  PathExpression: function PathExpression() /* path */{},

	  StringLiteral: function StringLiteral() /* string */{},
	  NumberLiteral: function NumberLiteral() /* number */{},
	  BooleanLiteral: function BooleanLiteral() /* bool */{},
	  UndefinedLiteral: function UndefinedLiteral() /* literal */{},
	  NullLiteral: function NullLiteral() /* literal */{},

	  Hash: function Hash(hash) {
	    this.acceptArray(hash.pairs);
	  },
	  HashPair: function HashPair(pair) {
	    this.acceptRequired(pair, 'value');
	  }
	};

	function visitSubExpression(mustache) {
	  this.acceptRequired(mustache, 'path');
	  this.acceptArray(mustache.params);
	  this.acceptKey(mustache, 'hash');
	}
	function visitBlock(block) {
	  visitSubExpression.call(this, block);

	  this.acceptKey(block, 'program');
	  this.acceptKey(block, 'inverse');
	}
	function visitPartial(partial) {
	  this.acceptRequired(partial, 'name');
	  this.acceptArray(partial.params);
	  this.acceptKey(partial, 'hash');
	}

	exports['default'] = Visitor;
	module.exports = exports['default'];

	});

	unwrapExports(visitor);

	var whitespaceControl = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



	var _visitor2 = _interopRequireDefault(visitor);

	function WhitespaceControl() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	  this.options = options;
	}
	WhitespaceControl.prototype = new _visitor2['default']();

	WhitespaceControl.prototype.Program = function (program) {
	  var doStandalone = !this.options.ignoreStandalone;

	  var isRoot = !this.isRootSeen;
	  this.isRootSeen = true;

	  var body = program.body;
	  for (var i = 0, l = body.length; i < l; i++) {
	    var current = body[i],
	        strip = this.accept(current);

	    if (!strip) {
	      continue;
	    }

	    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
	        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
	        openStandalone = strip.openStandalone && _isPrevWhitespace,
	        closeStandalone = strip.closeStandalone && _isNextWhitespace,
	        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

	    if (strip.close) {
	      omitRight(body, i, true);
	    }
	    if (strip.open) {
	      omitLeft(body, i, true);
	    }

	    if (doStandalone && inlineStandalone) {
	      omitRight(body, i);

	      if (omitLeft(body, i)) {
	        // If we are on a standalone node, save the indent info for partials
	        if (current.type === 'PartialStatement') {
	          // Pull out the whitespace from the final line
	          current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
	        }
	      }
	    }
	    if (doStandalone && openStandalone) {
	      omitRight((current.program || current.inverse).body);

	      // Strip out the previous content node if it's whitespace only
	      omitLeft(body, i);
	    }
	    if (doStandalone && closeStandalone) {
	      // Always strip the next node
	      omitRight(body, i);

	      omitLeft((current.inverse || current.program).body);
	    }
	  }

	  return program;
	};

	WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
	  this.accept(block.program);
	  this.accept(block.inverse);

	  // Find the inverse program that is involed with whitespace stripping.
	  var program = block.program || block.inverse,
	      inverse = block.program && block.inverse,
	      firstInverse = inverse,
	      lastInverse = inverse;

	  if (inverse && inverse.chained) {
	    firstInverse = inverse.body[0].program;

	    // Walk the inverse chain to find the last inverse that is actually in the chain.
	    while (lastInverse.chained) {
	      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
	    }
	  }

	  var strip = {
	    open: block.openStrip.open,
	    close: block.closeStrip.close,

	    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
	    // so our parent can determine if we actually are standalone
	    openStandalone: isNextWhitespace(program.body),
	    closeStandalone: isPrevWhitespace((firstInverse || program).body)
	  };

	  if (block.openStrip.close) {
	    omitRight(program.body, null, true);
	  }

	  if (inverse) {
	    var inverseStrip = block.inverseStrip;

	    if (inverseStrip.open) {
	      omitLeft(program.body, null, true);
	    }

	    if (inverseStrip.close) {
	      omitRight(firstInverse.body, null, true);
	    }
	    if (block.closeStrip.open) {
	      omitLeft(lastInverse.body, null, true);
	    }

	    // Find standalone else statments
	    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
	      omitLeft(program.body);
	      omitRight(firstInverse.body);
	    }
	  } else if (block.closeStrip.open) {
	    omitLeft(program.body, null, true);
	  }

	  return strip;
	};

	WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
	  return mustache.strip;
	};

	WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
	  /* istanbul ignore next */
	  var strip = node.strip || {};
	  return {
	    inlineStandalone: true,
	    open: strip.open,
	    close: strip.close
	  };
	};

	function isPrevWhitespace(body, i, isRoot) {
	  if (i === undefined) {
	    i = body.length;
	  }

	  // Nodes that end with newlines are considered whitespace (but are special
	  // cased for strip operations)
	  var prev = body[i - 1],
	      sibling = body[i - 2];
	  if (!prev) {
	    return isRoot;
	  }

	  if (prev.type === 'ContentStatement') {
	    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
	  }
	}
	function isNextWhitespace(body, i, isRoot) {
	  if (i === undefined) {
	    i = -1;
	  }

	  var next = body[i + 1],
	      sibling = body[i + 2];
	  if (!next) {
	    return isRoot;
	  }

	  if (next.type === 'ContentStatement') {
	    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
	  }
	}

	// Marks the node to the right of the position as omitted.
	// I.e. {{foo}}' ' will mark the ' ' node as omitted.
	//
	// If i is undefined, then the first child will be marked as such.
	//
	// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
	// content is met.
	function omitRight(body, i, multiple) {
	  var current = body[i == null ? 0 : i + 1];
	  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
	    return;
	  }

	  var original = current.value;
	  current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
	  current.rightStripped = current.value !== original;
	}

	// Marks the node to the left of the position as omitted.
	// I.e. ' '{{foo}} will mark the ' ' node as omitted.
	//
	// If i is undefined then the last child will be marked as such.
	//
	// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
	// content is met.
	function omitLeft(body, i, multiple) {
	  var current = body[i == null ? body.length - 1 : i - 1];
	  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
	    return;
	  }

	  // We omit the last node if it's whitespace only and not preceded by a non-content node.
	  var original = current.value;
	  current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
	  current.leftStripped = current.value !== original;
	  return current.leftStripped;
	}

	exports['default'] = WhitespaceControl;
	module.exports = exports['default'];

	});

	unwrapExports(whitespaceControl);

	var helpers$1 = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.SourceLocation = SourceLocation;
	exports.id = id;
	exports.stripFlags = stripFlags;
	exports.stripComment = stripComment;
	exports.preparePath = preparePath;
	exports.prepareMustache = prepareMustache;
	exports.prepareRawBlock = prepareRawBlock;
	exports.prepareBlock = prepareBlock;
	exports.prepareProgram = prepareProgram;
	exports.preparePartialBlock = preparePartialBlock;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



	var _exception2 = _interopRequireDefault(exception);

	function validateClose(open, close) {
	  close = close.path ? close.path.original : close;

	  if (open.path.original !== close) {
	    var errorNode = { loc: open.path.loc };

	    throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
	  }
	}

	function SourceLocation(source, locInfo) {
	  this.source = source;
	  this.start = {
	    line: locInfo.first_line,
	    column: locInfo.first_column
	  };
	  this.end = {
	    line: locInfo.last_line,
	    column: locInfo.last_column
	  };
	}

	function id(token) {
	  if (/^\[.*\]$/.test(token)) {
	    return token.substring(1, token.length - 1);
	  } else {
	    return token;
	  }
	}

	function stripFlags(open, close) {
	  return {
	    open: open.charAt(2) === '~',
	    close: close.charAt(close.length - 3) === '~'
	  };
	}

	function stripComment(comment) {
	  return comment.replace(/^\{\{~?!-?-?/, '').replace(/-?-?~?\}\}$/, '');
	}

	function preparePath(data, parts, loc) {
	  loc = this.locInfo(loc);

	  var original = data ? '@' : '',
	      dig = [],
	      depth = 0;

	  for (var i = 0, l = parts.length; i < l; i++) {
	    var part = parts[i].part,

	    // If we have [] syntax then we do not treat path references as operators,
	    // i.e. foo.[this] resolves to approximately context.foo['this']
	    isLiteral = parts[i].original !== part;
	    original += (parts[i].separator || '') + part;

	    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
	      if (dig.length > 0) {
	        throw new _exception2['default']('Invalid path: ' + original, { loc: loc });
	      } else if (part === '..') {
	        depth++;
	      }
	    } else {
	      dig.push(part);
	    }
	  }

	  return {
	    type: 'PathExpression',
	    data: data,
	    depth: depth,
	    parts: dig,
	    original: original,
	    loc: loc
	  };
	}

	function prepareMustache(path, params, hash, open, strip, locInfo) {
	  // Must use charAt to support IE pre-10
	  var escapeFlag = open.charAt(3) || open.charAt(2),
	      escaped = escapeFlag !== '{' && escapeFlag !== '&';

	  var decorator = /\*/.test(open);
	  return {
	    type: decorator ? 'Decorator' : 'MustacheStatement',
	    path: path,
	    params: params,
	    hash: hash,
	    escaped: escaped,
	    strip: strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	function prepareRawBlock(openRawBlock, contents, close, locInfo) {
	  validateClose(openRawBlock, close);

	  locInfo = this.locInfo(locInfo);
	  var program = {
	    type: 'Program',
	    body: contents,
	    strip: {},
	    loc: locInfo
	  };

	  return {
	    type: 'BlockStatement',
	    path: openRawBlock.path,
	    params: openRawBlock.params,
	    hash: openRawBlock.hash,
	    program: program,
	    openStrip: {},
	    inverseStrip: {},
	    closeStrip: {},
	    loc: locInfo
	  };
	}

	function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
	  if (close && close.path) {
	    validateClose(openBlock, close);
	  }

	  var decorator = /\*/.test(openBlock.open);

	  program.blockParams = openBlock.blockParams;

	  var inverse = undefined,
	      inverseStrip = undefined;

	  if (inverseAndProgram) {
	    if (decorator) {
	      throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
	    }

	    if (inverseAndProgram.chain) {
	      inverseAndProgram.program.body[0].closeStrip = close.strip;
	    }

	    inverseStrip = inverseAndProgram.strip;
	    inverse = inverseAndProgram.program;
	  }

	  if (inverted) {
	    inverted = inverse;
	    inverse = program;
	    program = inverted;
	  }

	  return {
	    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
	    path: openBlock.path,
	    params: openBlock.params,
	    hash: openBlock.hash,
	    program: program,
	    inverse: inverse,
	    openStrip: openBlock.strip,
	    inverseStrip: inverseStrip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	function prepareProgram(statements, loc) {
	  if (!loc && statements.length) {
	    var firstLoc = statements[0].loc,
	        lastLoc = statements[statements.length - 1].loc;

	    /* istanbul ignore else */
	    if (firstLoc && lastLoc) {
	      loc = {
	        source: firstLoc.source,
	        start: {
	          line: firstLoc.start.line,
	          column: firstLoc.start.column
	        },
	        end: {
	          line: lastLoc.end.line,
	          column: lastLoc.end.column
	        }
	      };
	    }
	  }

	  return {
	    type: 'Program',
	    body: statements,
	    strip: {},
	    loc: loc
	  };
	}

	function preparePartialBlock(open, program, close, locInfo) {
	  validateClose(open, close);

	  return {
	    type: 'PartialBlockStatement',
	    name: open.path,
	    params: open.params,
	    hash: open.hash,
	    program: program,
	    openStrip: open.strip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	});

	unwrapExports(helpers$1);
	var helpers_1$1 = helpers$1.SourceLocation;
	var helpers_2$1 = helpers$1.id;
	var helpers_3 = helpers$1.stripFlags;
	var helpers_4 = helpers$1.stripComment;
	var helpers_5 = helpers$1.preparePath;
	var helpers_6 = helpers$1.prepareMustache;
	var helpers_7 = helpers$1.prepareRawBlock;
	var helpers_8 = helpers$1.prepareBlock;
	var helpers_9 = helpers$1.prepareProgram;
	var helpers_10 = helpers$1.preparePartialBlock;

	var base$1 = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.parseWithoutProcessing = parseWithoutProcessing;
	exports.parse = parse;
	// istanbul ignore next

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



	var _parser2 = _interopRequireDefault(parser);



	var _whitespaceControl2 = _interopRequireDefault(whitespaceControl);



	var Helpers = _interopRequireWildcard(helpers$1);



	exports.parser = _parser2['default'];

	var yy = {};
	utils.extend(yy, Helpers);

	function parseWithoutProcessing(input, options) {
	  // Just return if an already-compiled AST was passed in.
	  if (input.type === 'Program') {
	    return input;
	  }

	  _parser2['default'].yy = yy;

	  // Altering the shared object here, but this is ok as parser is a sync operation
	  yy.locInfo = function (locInfo) {
	    return new yy.SourceLocation(options && options.srcName, locInfo);
	  };

	  var ast = _parser2['default'].parse(input);

	  return ast;
	}

	function parse(input, options) {
	  var ast = parseWithoutProcessing(input, options);
	  var strip = new _whitespaceControl2['default'](options);

	  return strip.accept(ast);
	}

	});

	unwrapExports(base$1);
	var base_1$1 = base$1.parseWithoutProcessing;
	var base_2$1 = base$1.parse;
	var base_3$1 = base$1.parser;

	var compiler = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.Compiler = Compiler;
	exports.precompile = precompile;
	exports.compile = compile;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



	var _exception2 = _interopRequireDefault(exception);





	var _ast2 = _interopRequireDefault(ast);

	var slice = [].slice;

	function Compiler() {}

	// the foundHelper register will disambiguate helper lookup from finding a
	// function in a context. This is necessary for mustache compatibility, which
	// requires that context functions in blocks are evaluated by blockHelperMissing,
	// and then proceed as if the resulting value was provided to blockHelperMissing.

	Compiler.prototype = {
	  compiler: Compiler,

	  equals: function equals(other) {
	    var len = this.opcodes.length;
	    if (other.opcodes.length !== len) {
	      return false;
	    }

	    for (var i = 0; i < len; i++) {
	      var opcode = this.opcodes[i],
	          otherOpcode = other.opcodes[i];
	      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
	        return false;
	      }
	    }

	    // We know that length is the same between the two arrays because they are directly tied
	    // to the opcode behavior above.
	    len = this.children.length;
	    for (var i = 0; i < len; i++) {
	      if (!this.children[i].equals(other.children[i])) {
	        return false;
	      }
	    }

	    return true;
	  },

	  guid: 0,

	  compile: function compile(program, options) {
	    this.sourceNode = [];
	    this.opcodes = [];
	    this.children = [];
	    this.options = options;
	    this.stringParams = options.stringParams;
	    this.trackIds = options.trackIds;

	    options.blockParams = options.blockParams || [];

	    // These changes will propagate to the other compiler components
	    var knownHelpers = options.knownHelpers;
	    options.knownHelpers = {
	      'helperMissing': true,
	      'blockHelperMissing': true,
	      'each': true,
	      'if': true,
	      'unless': true,
	      'with': true,
	      'log': true,
	      'lookup': true
	    };
	    if (knownHelpers) {
	      // the next line should use "Object.keys", but the code has been like this a long time and changing it, might
	      // cause backwards-compatibility issues... It's an old library...
	      // eslint-disable-next-line guard-for-in
	      for (var _name in knownHelpers) {
	        this.options.knownHelpers[_name] = knownHelpers[_name];
	      }
	    }

	    return this.accept(program);
	  },

	  compileProgram: function compileProgram(program) {
	    var childCompiler = new this.compiler(),
	        // eslint-disable-line new-cap
	    result = childCompiler.compile(program, this.options),
	        guid = this.guid++;

	    this.usePartial = this.usePartial || result.usePartial;

	    this.children[guid] = result;
	    this.useDepths = this.useDepths || result.useDepths;

	    return guid;
	  },

	  accept: function accept(node) {
	    /* istanbul ignore next: Sanity code */
	    if (!this[node.type]) {
	      throw new _exception2['default']('Unknown type: ' + node.type, node);
	    }

	    this.sourceNode.unshift(node);
	    var ret = this[node.type](node);
	    this.sourceNode.shift();
	    return ret;
	  },

	  Program: function Program(program) {
	    this.options.blockParams.unshift(program.blockParams);

	    var body = program.body,
	        bodyLength = body.length;
	    for (var i = 0; i < bodyLength; i++) {
	      this.accept(body[i]);
	    }

	    this.options.blockParams.shift();

	    this.isSimple = bodyLength === 1;
	    this.blockParams = program.blockParams ? program.blockParams.length : 0;

	    return this;
	  },

	  BlockStatement: function BlockStatement(block) {
	    transformLiteralToPath(block);

	    var program = block.program,
	        inverse = block.inverse;

	    program = program && this.compileProgram(program);
	    inverse = inverse && this.compileProgram(inverse);

	    var type = this.classifySexpr(block);

	    if (type === 'helper') {
	      this.helperSexpr(block, program, inverse);
	    } else if (type === 'simple') {
	      this.simpleSexpr(block);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('blockValue', block.path.original);
	    } else {
	      this.ambiguousSexpr(block, program, inverse);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('ambiguousBlockValue');
	    }

	    this.opcode('append');
	  },

	  DecoratorBlock: function DecoratorBlock(decorator) {
	    var program = decorator.program && this.compileProgram(decorator.program);
	    var params = this.setupFullMustacheParams(decorator, program, undefined),
	        path = decorator.path;

	    this.useDecorators = true;
	    this.opcode('registerDecorator', params.length, path.original);
	  },

	  PartialStatement: function PartialStatement(partial) {
	    this.usePartial = true;

	    var program = partial.program;
	    if (program) {
	      program = this.compileProgram(partial.program);
	    }

	    var params = partial.params;
	    if (params.length > 1) {
	      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
	    } else if (!params.length) {
	      if (this.options.explicitPartialContext) {
	        this.opcode('pushLiteral', 'undefined');
	      } else {
	        params.push({ type: 'PathExpression', parts: [], depth: 0 });
	      }
	    }

	    var partialName = partial.name.original,
	        isDynamic = partial.name.type === 'SubExpression';
	    if (isDynamic) {
	      this.accept(partial.name);
	    }

	    this.setupFullMustacheParams(partial, program, undefined, true);

	    var indent = partial.indent || '';
	    if (this.options.preventIndent && indent) {
	      this.opcode('appendContent', indent);
	      indent = '';
	    }

	    this.opcode('invokePartial', isDynamic, partialName, indent);
	    this.opcode('append');
	  },
	  PartialBlockStatement: function PartialBlockStatement(partialBlock) {
	    this.PartialStatement(partialBlock);
	  },

	  MustacheStatement: function MustacheStatement(mustache) {
	    this.SubExpression(mustache);

	    if (mustache.escaped && !this.options.noEscape) {
	      this.opcode('appendEscaped');
	    } else {
	      this.opcode('append');
	    }
	  },
	  Decorator: function Decorator(decorator) {
	    this.DecoratorBlock(decorator);
	  },

	  ContentStatement: function ContentStatement(content) {
	    if (content.value) {
	      this.opcode('appendContent', content.value);
	    }
	  },

	  CommentStatement: function CommentStatement() {},

	  SubExpression: function SubExpression(sexpr) {
	    transformLiteralToPath(sexpr);
	    var type = this.classifySexpr(sexpr);

	    if (type === 'simple') {
	      this.simpleSexpr(sexpr);
	    } else if (type === 'helper') {
	      this.helperSexpr(sexpr);
	    } else {
	      this.ambiguousSexpr(sexpr);
	    }
	  },
	  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
	    var path = sexpr.path,
	        name = path.parts[0],
	        isBlock = program != null || inverse != null;

	    this.opcode('getContext', path.depth);

	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);

	    path.strict = true;
	    this.accept(path);

	    this.opcode('invokeAmbiguous', name, isBlock);
	  },

	  simpleSexpr: function simpleSexpr(sexpr) {
	    var path = sexpr.path;
	    path.strict = true;
	    this.accept(path);
	    this.opcode('resolvePossibleLambda');
	  },

	  helperSexpr: function helperSexpr(sexpr, program, inverse) {
	    var params = this.setupFullMustacheParams(sexpr, program, inverse),
	        path = sexpr.path,
	        name = path.parts[0];

	    if (this.options.knownHelpers[name]) {
	      this.opcode('invokeKnownHelper', params.length, name);
	    } else if (this.options.knownHelpersOnly) {
	      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
	    } else {
	      path.strict = true;
	      path.falsy = true;

	      this.accept(path);
	      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
	    }
	  },

	  PathExpression: function PathExpression(path) {
	    this.addDepth(path.depth);
	    this.opcode('getContext', path.depth);

	    var name = path.parts[0],
	        scoped = _ast2['default'].helpers.scopedId(path),
	        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

	    if (blockParamId) {
	      this.opcode('lookupBlockParam', blockParamId, path.parts);
	    } else if (!name) {
	      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
	      this.opcode('pushContext');
	    } else if (path.data) {
	      this.options.data = true;
	      this.opcode('lookupData', path.depth, path.parts, path.strict);
	    } else {
	      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
	    }
	  },

	  StringLiteral: function StringLiteral(string) {
	    this.opcode('pushString', string.value);
	  },

	  NumberLiteral: function NumberLiteral(number) {
	    this.opcode('pushLiteral', number.value);
	  },

	  BooleanLiteral: function BooleanLiteral(bool) {
	    this.opcode('pushLiteral', bool.value);
	  },

	  UndefinedLiteral: function UndefinedLiteral() {
	    this.opcode('pushLiteral', 'undefined');
	  },

	  NullLiteral: function NullLiteral() {
	    this.opcode('pushLiteral', 'null');
	  },

	  Hash: function Hash(hash) {
	    var pairs = hash.pairs,
	        i = 0,
	        l = pairs.length;

	    this.opcode('pushHash');

	    for (; i < l; i++) {
	      this.pushParam(pairs[i].value);
	    }
	    while (i--) {
	      this.opcode('assignToHash', pairs[i].key);
	    }
	    this.opcode('popHash');
	  },

	  // HELPERS
	  opcode: function opcode(name) {
	    this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
	  },

	  addDepth: function addDepth(depth) {
	    if (!depth) {
	      return;
	    }

	    this.useDepths = true;
	  },

	  classifySexpr: function classifySexpr(sexpr) {
	    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

	    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

	    // a mustache is an eligible helper if:
	    // * its id is simple (a single part, not `this` or `..`)
	    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

	    // if a mustache is an eligible helper but not a definite
	    // helper, it is ambiguous, and will be resolved in a later
	    // pass or at runtime.
	    var isEligible = !isBlockParam && (isHelper || isSimple);

	    // if ambiguous, we can possibly resolve the ambiguity now
	    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
	    if (isEligible && !isHelper) {
	      var _name2 = sexpr.path.parts[0],
	          options = this.options;

	      if (options.knownHelpers[_name2]) {
	        isHelper = true;
	      } else if (options.knownHelpersOnly) {
	        isEligible = false;
	      }
	    }

	    if (isHelper) {
	      return 'helper';
	    } else if (isEligible) {
	      return 'ambiguous';
	    } else {
	      return 'simple';
	    }
	  },

	  pushParams: function pushParams(params) {
	    for (var i = 0, l = params.length; i < l; i++) {
	      this.pushParam(params[i]);
	    }
	  },

	  pushParam: function pushParam(val) {
	    var value = val.value != null ? val.value : val.original || '';

	    if (this.stringParams) {
	      if (value.replace) {
	        value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
	      }

	      if (val.depth) {
	        this.addDepth(val.depth);
	      }
	      this.opcode('getContext', val.depth || 0);
	      this.opcode('pushStringParam', value, val.type);

	      if (val.type === 'SubExpression') {
	        // SubExpressions get evaluated and passed in
	        // in string params mode.
	        this.accept(val);
	      }
	    } else {
	      if (this.trackIds) {
	        var blockParamIndex = undefined;
	        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
	          blockParamIndex = this.blockParamIndex(val.parts[0]);
	        }
	        if (blockParamIndex) {
	          var blockParamChild = val.parts.slice(1).join('.');
	          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
	        } else {
	          value = val.original || value;
	          if (value.replace) {
	            value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
	          }

	          this.opcode('pushId', val.type, value);
	        }
	      }
	      this.accept(val);
	    }
	  },

	  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
	    var params = sexpr.params;
	    this.pushParams(params);

	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);

	    if (sexpr.hash) {
	      this.accept(sexpr.hash);
	    } else {
	      this.opcode('emptyHash', omitEmpty);
	    }

	    return params;
	  },

	  blockParamIndex: function blockParamIndex(name) {
	    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
	      var blockParams = this.options.blockParams[depth],
	          param = blockParams && utils.indexOf(blockParams, name);
	      if (blockParams && param >= 0) {
	        return [depth, param];
	      }
	    }
	  }
	};

	function precompile(input, options, env) {
	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
	  }

	  options = options || {};
	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }

	  var ast = env.parse(input, options),
	      environment = new env.Compiler().compile(ast, options);
	  return new env.JavaScriptCompiler().compile(environment, options);
	}

	function compile(input, options, env) {
	  if (options === undefined) options = {};

	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
	  }

	  options = utils.extend({}, options);
	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }

	  var compiled = undefined;

	  function compileInput() {
	    var ast = env.parse(input, options),
	        environment = new env.Compiler().compile(ast, options),
	        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
	    return env.template(templateSpec);
	  }

	  // Template is only compiled on first use and cached after that point.
	  function ret(context, execOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled.call(this, context, execOptions);
	  }
	  ret._setup = function (setupOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._setup(setupOptions);
	  };
	  ret._child = function (i, data, blockParams, depths) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._child(i, data, blockParams, depths);
	  };
	  return ret;
	}

	function argEquals(a, b) {
	  if (a === b) {
	    return true;
	  }

	  if (utils.isArray(a) && utils.isArray(b) && a.length === b.length) {
	    for (var i = 0; i < a.length; i++) {
	      if (!argEquals(a[i], b[i])) {
	        return false;
	      }
	    }
	    return true;
	  }
	}

	function transformLiteralToPath(sexpr) {
	  if (!sexpr.path.parts) {
	    var literal = sexpr.path;
	    // Casting to string here to make false and 0 literal values play nicely with the rest
	    // of the system.
	    sexpr.path = {
	      type: 'PathExpression',
	      data: false,
	      depth: 0,
	      parts: [literal.original + ''],
	      original: literal.original + '',
	      loc: literal.loc
	    };
	  }
	}

	});

	unwrapExports(compiler);
	var compiler_1 = compiler.Compiler;
	var compiler_2 = compiler.precompile;
	var compiler_3 = compiler.compile;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var binarySearch = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;

	/**
	 * Recursive implementation of binary search.
	 *
	 * @param aLow Indices here and lower do not contain the needle.
	 * @param aHigh Indices here and higher do not contain the needle.
	 * @param aNeedle The element being searched for.
	 * @param aHaystack The non-empty array being searched.
	 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 */
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	  // This function terminates when one of the following is true:
	  //
	  //   1. We find the exact element we are looking for.
	  //
	  //   2. We did not find the exact element, but we can return the index of
	  //      the next-closest element.
	  //
	  //   3. We did not find the exact element, and there is no next-closest
	  //      element than the one we are searching for, so we return -1.
	  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	  var cmp = aCompare(aNeedle, aHaystack[mid], true);
	  if (cmp === 0) {
	    // Found the element we are looking for.
	    return mid;
	  }
	  else if (cmp > 0) {
	    // Our needle is greater than aHaystack[mid].
	    if (aHigh - mid > 1) {
	      // The element is in the upper half.
	      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // The exact needle element was not found in this haystack. Determine if
	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return aHigh < aHaystack.length ? aHigh : -1;
	    } else {
	      return mid;
	    }
	  }
	  else {
	    // Our needle is less than aHaystack[mid].
	    if (mid - aLow > 1) {
	      // The element is in the lower half.
	      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return mid;
	    } else {
	      return aLow < 0 ? -1 : aLow;
	    }
	  }
	}

	/**
	 * This is an implementation of binary search which will always try and return
	 * the index of the closest element if there is no exact hit. This is because
	 * mappings between original and generated line/col pairs are single points,
	 * and there is an implicit region between each of them, so a miss just means
	 * that you aren't on the very start of a region.
	 *
	 * @param aNeedle The element you are looking for.
	 * @param aHaystack The array that is being searched.
	 * @param aCompare A function which takes the needle and an element in the
	 *     array and returns -1, 0, or 1 depending on whether the needle is less
	 *     than, equal to, or greater than the element, respectively.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	 */
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	  if (aHaystack.length === 0) {
	    return -1;
	  }

	  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	  if (index < 0) {
	    return -1;
	  }

	  // We have found either the exact element, or the next-closest element than
	  // the one we are searching for. However, there may be more than one such
	  // element. Make sure we always return the smallest of these.
	  while (index - 1 >= 0) {
	    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	      break;
	    }
	    --index;
	  }

	  return index;
	};
	});
	var binarySearch_1 = binarySearch.GREATEST_LOWER_BOUND;
	var binarySearch_2 = binarySearch.LEAST_UPPER_BOUND;
	var binarySearch_3 = binarySearch.search;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.

	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}

	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.

	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.

	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;

	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;

	    // (2) Recurse on each half.

	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */
	var quickSort_1 = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};

	var quickSort = {
		quickSort: quickSort_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$2 = arraySet.ArraySet;

	var quickSort$1 = quickSort.quickSort;

	function SourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
	    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}

	SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	};

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;

	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.

	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});

	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };

	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;

	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }

	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };

	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number is 1-based.
	 *   - column: Optional. the column number in the original source.
	 *    The column number is 0-based.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *    line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *    The column number is 0-based.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };

	    needle.source = this._findSourceIndex(needle.source);
	    if (needle.source < 0) {
	      return [];
	    }

	    var mappings = [];

	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      }
	    }

	    return mappings;
	  };

	var SourceMapConsumer_1 = SourceMapConsumer;

	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The first parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);

	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  if (sourceRoot) {
	    sourceRoot = util.normalize(sourceRoot);
	  }

	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });

	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet$2.fromArray(names.map(String), true);
	  this._sources = ArraySet$2.fromArray(sources, true);

	  this._absoluteSources = this._sources.toArray().map(function (s) {
	    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
	  });

	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this._sourceMapURL = aSourceMapURL;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	/**
	 * Utility function to find the index of a source.  Returns -1 if not
	 * found.
	 */
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
	  var relativeSource = aSource;
	  if (this.sourceRoot != null) {
	    relativeSource = util.relative(this.sourceRoot, relativeSource);
	  }

	  if (this._sources.has(relativeSource)) {
	    return this._sources.indexOf(relativeSource);
	  }

	  // Maybe aSource is an absolute URL as returned by |sources|.  In
	  // this case we can't simply undo the transform.
	  var i;
	  for (i = 0; i < this._absoluteSources.length; ++i) {
	    if (this._absoluteSources[i] == aSource) {
	      return i;
	    }
	  }

	  return -1;
	};

	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @param String aSourceMapURL
	 *        The URL at which the source map can be found (optional)
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);

	    var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;
	    smc._sourceMapURL = aSourceMapURL;
	    smc._absoluteSources = smc._sources.toArray().map(function (s) {
	      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
	    });

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];

	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;

	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;

	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }

	        destOriginalMappings.push(destMapping);
	      }

	      destGeneratedMappings.push(destMapping);
	    }

	    quickSort$1(smc.__originalMappings, util.compareByOriginalPositions);

	    return smc;
	  };

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._absoluteSources.slice();
	  }
	});

	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;

	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);

	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64Vlq.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }

	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }

	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }

	          cachedSegments[str] = segment;
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;

	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }

	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }

	    quickSort$1(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;

	    quickSort$1(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };

	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }

	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];

	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];

	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }

	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }

	    var index = this._findSourceIndex(aSource);
	    if (index >= 0) {
	      return this.sourcesContent[index];
	    }

	    var relativeSource = aSource;
	    if (this.sourceRoot != null) {
	      relativeSource = util.relative(this.sourceRoot, relativeSource);
	    }

	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }

	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + relativeSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    source = this._findSourceIndex(source);
	    if (source < 0) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }

	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }

	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };

	var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The first parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet$2();
	  this._names = new ArraySet$2();

	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;

	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
	    }
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }

	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];

	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }

	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based. 
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }

	    return {
	      line: null,
	      column: null
	    };
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];

	        var source = section.consumer._sources.at(mapping.source);
	        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
	        this._sources.add(source);
	        source = this._sources.indexOf(source);

	        var name = null;
	        if (mapping.name) {
	          name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	        }

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };

	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }

	    quickSort$1(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort$1(this.__originalMappings, util.compareByOriginalPositions);
	  };

	var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

	var sourceMapConsumer = {
		SourceMapConsumer: SourceMapConsumer_1,
		BasicSourceMapConsumer: BasicSourceMapConsumer_1,
		IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;


	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;

	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;

	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";

	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}

	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();

	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are accessed by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function() {
	      var lineContents = getNextLine();
	      // The last line of a file might not have a newline.
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;

	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ?
	            remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };

	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;

	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[remainingLinesIndex] || '';
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex] || '';
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }

	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });

	    return node;

	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };

	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};

	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};

	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};

	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };

	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }

	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };

	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};

	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator$1(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });

	  return { code: generated.code, map: map };
	};

	var SourceNode_1 = SourceNode;

	var sourceNode = {
		SourceNode: SourceNode_1
	};

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	var SourceMapGenerator$2 = sourceMapGenerator.SourceMapGenerator;
	var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;
	var SourceNode$1 = sourceNode.SourceNode;

	var sourceMap = {
		SourceMapGenerator: SourceMapGenerator$2,
		SourceMapConsumer: SourceMapConsumer$1,
		SourceNode: SourceNode$1
	};

	var codeGen = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;



	var SourceNode = undefined;

	try {
	  /* istanbul ignore next */
	  if (typeof undefined !== 'function' || !undefined.amd) {
	    // We don't support this in AMD environments. For these environments, we asusme that
	    // they are running on the browser and thus have no need for the source-map library.
	    var SourceMap = sourceMap;
	    SourceNode = SourceMap.SourceNode;
	  }
	} catch (err) {}
	/* NOP */

	/* istanbul ignore if: tested but not covered in istanbul due to dist build  */
	if (!SourceNode) {
	  SourceNode = function (line, column, srcFile, chunks) {
	    this.src = '';
	    if (chunks) {
	      this.add(chunks);
	    }
	  };
	  /* istanbul ignore next */
	  SourceNode.prototype = {
	    add: function add(chunks) {
	      if (utils.isArray(chunks)) {
	        chunks = chunks.join('');
	      }
	      this.src += chunks;
	    },
	    prepend: function prepend(chunks) {
	      if (utils.isArray(chunks)) {
	        chunks = chunks.join('');
	      }
	      this.src = chunks + this.src;
	    },
	    toStringWithSourceMap: function toStringWithSourceMap() {
	      return { code: this.toString() };
	    },
	    toString: function toString() {
	      return this.src;
	    }
	  };
	}

	function castChunk(chunk, codeGen, loc) {
	  if (utils.isArray(chunk)) {
	    var ret = [];

	    for (var i = 0, len = chunk.length; i < len; i++) {
	      ret.push(codeGen.wrap(chunk[i], loc));
	    }
	    return ret;
	  } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
	    // Handle primitives that the SourceNode will throw up on
	    return chunk + '';
	  }
	  return chunk;
	}

	function CodeGen(srcFile) {
	  this.srcFile = srcFile;
	  this.source = [];
	}

	CodeGen.prototype = {
	  isEmpty: function isEmpty() {
	    return !this.source.length;
	  },
	  prepend: function prepend(source, loc) {
	    this.source.unshift(this.wrap(source, loc));
	  },
	  push: function push(source, loc) {
	    this.source.push(this.wrap(source, loc));
	  },

	  merge: function merge() {
	    var source = this.empty();
	    this.each(function (line) {
	      source.add(['  ', line, '\n']);
	    });
	    return source;
	  },

	  each: function each(iter) {
	    for (var i = 0, len = this.source.length; i < len; i++) {
	      iter(this.source[i]);
	    }
	  },

	  empty: function empty() {
	    var loc = this.currentLocation || { start: {} };
	    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
	  },
	  wrap: function wrap(chunk) {
	    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];

	    if (chunk instanceof SourceNode) {
	      return chunk;
	    }

	    chunk = castChunk(chunk, this, loc);

	    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
	  },

	  functionCall: function functionCall(fn, type, params) {
	    params = this.generateList(params);
	    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
	  },

	  quotedString: function quotedString(str) {
	    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
	    .replace(/\u2029/g, '\\u2029') + '"';
	  },

	  objectLiteral: function objectLiteral(obj) {
	    var pairs = [];

	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        var value = castChunk(obj[key], this);
	        if (value !== 'undefined') {
	          pairs.push([this.quotedString(key), ':', value]);
	        }
	      }
	    }

	    var ret = this.generateList(pairs);
	    ret.prepend('{');
	    ret.add('}');
	    return ret;
	  },

	  generateList: function generateList(entries) {
	    var ret = this.empty();

	    for (var i = 0, len = entries.length; i < len; i++) {
	      if (i) {
	        ret.add(',');
	      }

	      ret.add(castChunk(entries[i], this));
	    }

	    return ret;
	  },

	  generateArray: function generateArray(entries) {
	    var ret = this.generateList(entries);
	    ret.prepend('[');
	    ret.add(']');

	    return ret;
	  }
	};

	exports['default'] = CodeGen;
	module.exports = exports['default'];

	});

	unwrapExports(codeGen);

	var javascriptCompiler = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }





	var _exception2 = _interopRequireDefault(exception);





	var _codeGen2 = _interopRequireDefault(codeGen);

	function Literal(value) {
	  this.value = value;
	}

	function JavaScriptCompiler() {}

	JavaScriptCompiler.prototype = {
	  // PUBLIC API: You can override these methods in a subclass to provide
	  // alternative compiled forms for name lookup and buffering semantics
	  nameLookup: function nameLookup(parent, name /* , type*/) {
	    var isEnumerable = [this.aliasable('container.propertyIsEnumerable'), '.call(', parent, ',"constructor")'];

	    if (name === 'constructor') {
	      return ['(', isEnumerable, '?', _actualLookup(), ' : undefined)'];
	    }
	    return _actualLookup();

	    function _actualLookup() {
	      if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
	        return [parent, '.', name];
	      } else {
	        return [parent, '[', JSON.stringify(name), ']'];
	      }
	    }
	  },
	  depthedLookup: function depthedLookup(name) {
	    return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
	  },

	  compilerInfo: function compilerInfo() {
	    var revision = base.COMPILER_REVISION,
	        versions = base.REVISION_CHANGES[revision];
	    return [revision, versions];
	  },

	  appendToBuffer: function appendToBuffer(source, location, explicit) {
	    // Force a source as this simplifies the merge logic.
	    if (!utils.isArray(source)) {
	      source = [source];
	    }
	    source = this.source.wrap(source, location);

	    if (this.environment.isSimple) {
	      return ['return ', source, ';'];
	    } else if (explicit) {
	      // This is a case where the buffer operation occurs as a child of another
	      // construct, generally braces. We have to explicitly output these buffer
	      // operations to ensure that the emitted code goes in the correct location.
	      return ['buffer += ', source, ';'];
	    } else {
	      source.appendToBuffer = true;
	      return source;
	    }
	  },

	  initializeBuffer: function initializeBuffer() {
	    return this.quotedString('');
	  },
	  // END PUBLIC API

	  compile: function compile(environment, options, context, asObject) {
	    this.environment = environment;
	    this.options = options;
	    this.stringParams = this.options.stringParams;
	    this.trackIds = this.options.trackIds;
	    this.precompile = !asObject;

	    this.name = this.environment.name;
	    this.isChild = !!context;
	    this.context = context || {
	      decorators: [],
	      programs: [],
	      environments: []
	    };

	    this.preamble();

	    this.stackSlot = 0;
	    this.stackVars = [];
	    this.aliases = {};
	    this.registers = { list: [] };
	    this.hashes = [];
	    this.compileStack = [];
	    this.inlineStack = [];
	    this.blockParams = [];

	    this.compileChildren(environment, options);

	    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
	    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

	    var opcodes = environment.opcodes,
	        opcode = undefined,
	        firstLoc = undefined,
	        i = undefined,
	        l = undefined;

	    for (i = 0, l = opcodes.length; i < l; i++) {
	      opcode = opcodes[i];

	      this.source.currentLocation = opcode.loc;
	      firstLoc = firstLoc || opcode.loc;
	      this[opcode.opcode].apply(this, opcode.args);
	    }

	    // Flush any trailing content that might be pending.
	    this.source.currentLocation = firstLoc;
	    this.pushSource('');

	    /* istanbul ignore next */
	    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
	      throw new _exception2['default']('Compile completed with content left on stack');
	    }

	    if (!this.decorators.isEmpty()) {
	      this.useDecorators = true;

	      this.decorators.prepend('var decorators = container.decorators;\n');
	      this.decorators.push('return fn;');

	      if (asObject) {
	        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
	      } else {
	        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
	        this.decorators.push('}\n');
	        this.decorators = this.decorators.merge();
	      }
	    } else {
	      this.decorators = undefined;
	    }

	    var fn = this.createFunctionContext(asObject);
	    if (!this.isChild) {
	      var ret = {
	        compiler: this.compilerInfo(),
	        main: fn
	      };

	      if (this.decorators) {
	        ret.main_d = this.decorators; // eslint-disable-line camelcase
	        ret.useDecorators = true;
	      }

	      var _context = this.context;
	      var programs = _context.programs;
	      var decorators = _context.decorators;

	      for (i = 0, l = programs.length; i < l; i++) {
	        if (programs[i]) {
	          ret[i] = programs[i];
	          if (decorators[i]) {
	            ret[i + '_d'] = decorators[i];
	            ret.useDecorators = true;
	          }
	        }
	      }

	      if (this.environment.usePartial) {
	        ret.usePartial = true;
	      }
	      if (this.options.data) {
	        ret.useData = true;
	      }
	      if (this.useDepths) {
	        ret.useDepths = true;
	      }
	      if (this.useBlockParams) {
	        ret.useBlockParams = true;
	      }
	      if (this.options.compat) {
	        ret.compat = true;
	      }

	      if (!asObject) {
	        ret.compiler = JSON.stringify(ret.compiler);

	        this.source.currentLocation = { start: { line: 1, column: 0 } };
	        ret = this.objectLiteral(ret);

	        if (options.srcName) {
	          ret = ret.toStringWithSourceMap({ file: options.destName });
	          ret.map = ret.map && ret.map.toString();
	        } else {
	          ret = ret.toString();
	        }
	      } else {
	        ret.compilerOptions = this.options;
	      }

	      return ret;
	    } else {
	      return fn;
	    }
	  },

	  preamble: function preamble() {
	    // track the last context pushed into place to allow skipping the
	    // getContext opcode when it would be a noop
	    this.lastContext = 0;
	    this.source = new _codeGen2['default'](this.options.srcName);
	    this.decorators = new _codeGen2['default'](this.options.srcName);
	  },

	  createFunctionContext: function createFunctionContext(asObject) {
	    var varDeclarations = '';

	    var locals = this.stackVars.concat(this.registers.list);
	    if (locals.length > 0) {
	      varDeclarations += ', ' + locals.join(', ');
	    }

	    // Generate minimizer alias mappings
	    //
	    // When using true SourceNodes, this will update all references to the given alias
	    // as the source nodes are reused in situ. For the non-source node compilation mode,
	    // aliases will not be used, but this case is already being run on the client and
	    // we aren't concern about minimizing the template size.
	    var aliasCount = 0;
	    for (var alias in this.aliases) {
	      // eslint-disable-line guard-for-in
	      var node = this.aliases[alias];
	      if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
	        varDeclarations += ', alias' + ++aliasCount + '=' + alias;
	        node.children[0] = 'alias' + aliasCount;
	      }
	    }

	    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

	    if (this.useBlockParams || this.useDepths) {
	      params.push('blockParams');
	    }
	    if (this.useDepths) {
	      params.push('depths');
	    }

	    // Perform a second pass over the output to merge content when possible
	    var source = this.mergeSource(varDeclarations);

	    if (asObject) {
	      params.push(source);

	      return Function.apply(this, params);
	    } else {
	      return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
	    }
	  },
	  mergeSource: function mergeSource(varDeclarations) {
	    var isSimple = this.environment.isSimple,
	        appendOnly = !this.forceBuffer,
	        appendFirst = undefined,
	        sourceSeen = undefined,
	        bufferStart = undefined,
	        bufferEnd = undefined;
	    this.source.each(function (line) {
	      if (line.appendToBuffer) {
	        if (bufferStart) {
	          line.prepend('  + ');
	        } else {
	          bufferStart = line;
	        }
	        bufferEnd = line;
	      } else {
	        if (bufferStart) {
	          if (!sourceSeen) {
	            appendFirst = true;
	          } else {
	            bufferStart.prepend('buffer += ');
	          }
	          bufferEnd.add(';');
	          bufferStart = bufferEnd = undefined;
	        }

	        sourceSeen = true;
	        if (!isSimple) {
	          appendOnly = false;
	        }
	      }
	    });

	    if (appendOnly) {
	      if (bufferStart) {
	        bufferStart.prepend('return ');
	        bufferEnd.add(';');
	      } else if (!sourceSeen) {
	        this.source.push('return "";');
	      }
	    } else {
	      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

	      if (bufferStart) {
	        bufferStart.prepend('return buffer + ');
	        bufferEnd.add(';');
	      } else {
	        this.source.push('return buffer;');
	      }
	    }

	    if (varDeclarations) {
	      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
	    }

	    return this.source.merge();
	  },

	  // [blockValue]
	  //
	  // On stack, before: hash, inverse, program, value
	  // On stack, after: return value of blockHelperMissing
	  //
	  // The purpose of this opcode is to take a block of the form
	  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
	  // replace it on the stack with the result of properly
	  // invoking blockHelperMissing.
	  blockValue: function blockValue(name) {
	    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),
	        params = [this.contextName(0)];
	    this.setupHelperArgs(name, 0, params);

	    var blockName = this.popStack();
	    params.splice(1, 0, blockName);

	    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
	  },

	  // [ambiguousBlockValue]
	  //
	  // On stack, before: hash, inverse, program, value
	  // Compiler value, before: lastHelper=value of last found helper, if any
	  // On stack, after, if no lastHelper: same as [blockValue]
	  // On stack, after, if lastHelper: value
	  ambiguousBlockValue: function ambiguousBlockValue() {
	    // We're being a bit cheeky and reusing the options value from the prior exec
	    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),
	        params = [this.contextName(0)];
	    this.setupHelperArgs('', 0, params, true);

	    this.flushInline();

	    var current = this.topStack();
	    params.splice(1, 0, current);

	    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
	  },

	  // [appendContent]
	  //
	  // On stack, before: ...
	  // On stack, after: ...
	  //
	  // Appends the string value of `content` to the current buffer
	  appendContent: function appendContent(content) {
	    if (this.pendingContent) {
	      content = this.pendingContent + content;
	    } else {
	      this.pendingLocation = this.source.currentLocation;
	    }

	    this.pendingContent = content;
	  },

	  // [append]
	  //
	  // On stack, before: value, ...
	  // On stack, after: ...
	  //
	  // Coerces `value` to a String and appends it to the current buffer.
	  //
	  // If `value` is truthy, or 0, it is coerced into a string and appended
	  // Otherwise, the empty string is appended
	  append: function append() {
	    if (this.isInline()) {
	      this.replaceStack(function (current) {
	        return [' != null ? ', current, ' : ""'];
	      });

	      this.pushSource(this.appendToBuffer(this.popStack()));
	    } else {
	      var local = this.popStack();
	      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
	      if (this.environment.isSimple) {
	        this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
	      }
	    }
	  },

	  // [appendEscaped]
	  //
	  // On stack, before: value, ...
	  // On stack, after: ...
	  //
	  // Escape `value` and append it to the buffer
	  appendEscaped: function appendEscaped() {
	    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
	  },

	  // [getContext]
	  //
	  // On stack, before: ...
	  // On stack, after: ...
	  // Compiler value, after: lastContext=depth
	  //
	  // Set the value of the `lastContext` compiler value to the depth
	  getContext: function getContext(depth) {
	    this.lastContext = depth;
	  },

	  // [pushContext]
	  //
	  // On stack, before: ...
	  // On stack, after: currentContext, ...
	  //
	  // Pushes the value of the current context onto the stack.
	  pushContext: function pushContext() {
	    this.pushStackLiteral(this.contextName(this.lastContext));
	  },

	  // [lookupOnContext]
	  //
	  // On stack, before: ...
	  // On stack, after: currentContext[name], ...
	  //
	  // Looks up the value of `name` on the current context and pushes
	  // it onto the stack.
	  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
	    var i = 0;

	    if (!scoped && this.options.compat && !this.lastContext) {
	      // The depthed query is expected to handle the undefined logic for the root level that
	      // is implemented below, so we evaluate that directly in compat mode
	      this.push(this.depthedLookup(parts[i++]));
	    } else {
	      this.pushContext();
	    }

	    this.resolvePath('context', parts, i, falsy, strict);
	  },

	  // [lookupBlockParam]
	  //
	  // On stack, before: ...
	  // On stack, after: blockParam[name], ...
	  //
	  // Looks up the value of `parts` on the given block param and pushes
	  // it onto the stack.
	  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
	    this.useBlockParams = true;

	    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
	    this.resolvePath('context', parts, 1);
	  },

	  // [lookupData]
	  //
	  // On stack, before: ...
	  // On stack, after: data, ...
	  //
	  // Push the data lookup operator
	  lookupData: function lookupData(depth, parts, strict) {
	    if (!depth) {
	      this.pushStackLiteral('data');
	    } else {
	      this.pushStackLiteral('container.data(data, ' + depth + ')');
	    }

	    this.resolvePath('data', parts, 0, true, strict);
	  },

	  resolvePath: function resolvePath(type, parts, i, falsy, strict) {
	    // istanbul ignore next

	    var _this = this;

	    if (this.options.strict || this.options.assumeObjects) {
	      this.push(strictLookup(this.options.strict && strict, this, parts, type));
	      return;
	    }

	    var len = parts.length;
	    for (; i < len; i++) {
	      /* eslint-disable no-loop-func */
	      this.replaceStack(function (current) {
	        var lookup = _this.nameLookup(current, parts[i], type);
	        // We want to ensure that zero and false are handled properly if the context (falsy flag)
	        // needs to have the special handling for these values.
	        if (!falsy) {
	          return [' != null ? ', lookup, ' : ', current];
	        } else {
	          // Otherwise we can use generic falsy handling
	          return [' && ', lookup];
	        }
	      });
	      /* eslint-enable no-loop-func */
	    }
	  },

	  // [resolvePossibleLambda]
	  //
	  // On stack, before: value, ...
	  // On stack, after: resolved value, ...
	  //
	  // If the `value` is a lambda, replace it on the stack by
	  // the return value of the lambda
	  resolvePossibleLambda: function resolvePossibleLambda() {
	    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
	  },

	  // [pushStringParam]
	  //
	  // On stack, before: ...
	  // On stack, after: string, currentContext, ...
	  //
	  // This opcode is designed for use in string mode, which
	  // provides the string value of a parameter along with its
	  // depth rather than resolving it immediately.
	  pushStringParam: function pushStringParam(string, type) {
	    this.pushContext();
	    this.pushString(type);

	    // If it's a subexpression, the string result
	    // will be pushed after this opcode.
	    if (type !== 'SubExpression') {
	      if (typeof string === 'string') {
	        this.pushString(string);
	      } else {
	        this.pushStackLiteral(string);
	      }
	    }
	  },

	  emptyHash: function emptyHash(omitEmpty) {
	    if (this.trackIds) {
	      this.push('{}'); // hashIds
	    }
	    if (this.stringParams) {
	      this.push('{}'); // hashContexts
	      this.push('{}'); // hashTypes
	    }
	    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
	  },
	  pushHash: function pushHash() {
	    if (this.hash) {
	      this.hashes.push(this.hash);
	    }
	    this.hash = { values: {}, types: [], contexts: [], ids: [] };
	  },
	  popHash: function popHash() {
	    var hash = this.hash;
	    this.hash = this.hashes.pop();

	    if (this.trackIds) {
	      this.push(this.objectLiteral(hash.ids));
	    }
	    if (this.stringParams) {
	      this.push(this.objectLiteral(hash.contexts));
	      this.push(this.objectLiteral(hash.types));
	    }

	    this.push(this.objectLiteral(hash.values));
	  },

	  // [pushString]
	  //
	  // On stack, before: ...
	  // On stack, after: quotedString(string), ...
	  //
	  // Push a quoted version of `string` onto the stack
	  pushString: function pushString(string) {
	    this.pushStackLiteral(this.quotedString(string));
	  },

	  // [pushLiteral]
	  //
	  // On stack, before: ...
	  // On stack, after: value, ...
	  //
	  // Pushes a value onto the stack. This operation prevents
	  // the compiler from creating a temporary variable to hold
	  // it.
	  pushLiteral: function pushLiteral(value) {
	    this.pushStackLiteral(value);
	  },

	  // [pushProgram]
	  //
	  // On stack, before: ...
	  // On stack, after: program(guid), ...
	  //
	  // Push a program expression onto the stack. This takes
	  // a compile-time guid and converts it into a runtime-accessible
	  // expression.
	  pushProgram: function pushProgram(guid) {
	    if (guid != null) {
	      this.pushStackLiteral(this.programExpression(guid));
	    } else {
	      this.pushStackLiteral(null);
	    }
	  },

	  // [registerDecorator]
	  //
	  // On stack, before: hash, program, params..., ...
	  // On stack, after: ...
	  //
	  // Pops off the decorator's parameters, invokes the decorator,
	  // and inserts the decorator into the decorators list.
	  registerDecorator: function registerDecorator(paramSize, name) {
	    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
	        options = this.setupHelperArgs(name, paramSize);

	    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
	  },

	  // [invokeHelper]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of helper invocation
	  //
	  // Pops off the helper's parameters, invokes the helper,
	  // and pushes the helper's return value onto the stack.
	  //
	  // If the helper is not found, `helperMissing` is called.
	  invokeHelper: function invokeHelper(paramSize, name, isSimple) {
	    var nonHelper = this.popStack(),
	        helper = this.setupHelper(paramSize, name);

	    var possibleFunctionCalls = [];

	    if (isSimple) {
	      // direct call to helper
	      possibleFunctionCalls.push(helper.name);
	    }
	    // call a function from the input object
	    possibleFunctionCalls.push(nonHelper);
	    if (!this.options.strict) {
	      possibleFunctionCalls.push(this.aliasable('container.hooks.helperMissing'));
	    }

	    var functionLookupCode = ['(', this.itemsSeparatedBy(possibleFunctionCalls, '||'), ')'];
	    var functionCall = this.source.functionCall(functionLookupCode, 'call', helper.callParams);
	    this.push(functionCall);
	  },

	  itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
	    var result = [];
	    result.push(items[0]);
	    for (var i = 1; i < items.length; i++) {
	      result.push(separator, items[i]);
	    }
	    return result;
	  },
	  // [invokeKnownHelper]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of helper invocation
	  //
	  // This operation is used when the helper is known to exist,
	  // so a `helperMissing` fallback is not required.
	  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
	    var helper = this.setupHelper(paramSize, name);
	    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
	  },

	  // [invokeAmbiguous]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of disambiguation
	  //
	  // This operation is used when an expression like `{{foo}}`
	  // is provided, but we don't know at compile-time whether it
	  // is a helper or a path.
	  //
	  // This operation emits more code than the other options,
	  // and can be avoided by passing the `knownHelpers` and
	  // `knownHelpersOnly` flags at compile-time.
	  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
	    this.useRegister('helper');

	    var nonHelper = this.popStack();

	    this.emptyHash();
	    var helper = this.setupHelper(0, name, helperCall);

	    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

	    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
	    if (!this.options.strict) {
	      lookup[0] = '(helper = ';
	      lookup.push(' != null ? helper : ', this.aliasable('container.hooks.helperMissing'));
	    }

	    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
	  },

	  // [invokePartial]
	  //
	  // On stack, before: context, ...
	  // On stack after: result of partial invocation
	  //
	  // This operation pops off a context, invokes a partial with that context,
	  // and pushes the result of the invocation back.
	  invokePartial: function invokePartial(isDynamic, name, indent) {
	    var params = [],
	        options = this.setupParams(name, 1, params);

	    if (isDynamic) {
	      name = this.popStack();
	      delete options.name;
	    }

	    if (indent) {
	      options.indent = JSON.stringify(indent);
	    }
	    options.helpers = 'helpers';
	    options.partials = 'partials';
	    options.decorators = 'container.decorators';

	    if (!isDynamic) {
	      params.unshift(this.nameLookup('partials', name, 'partial'));
	    } else {
	      params.unshift(name);
	    }

	    if (this.options.compat) {
	      options.depths = 'depths';
	    }
	    options = this.objectLiteral(options);
	    params.push(options);

	    this.push(this.source.functionCall('container.invokePartial', '', params));
	  },

	  // [assignToHash]
	  //
	  // On stack, before: value, ..., hash, ...
	  // On stack, after: ..., hash, ...
	  //
	  // Pops a value off the stack and assigns it to the current hash
	  assignToHash: function assignToHash(key) {
	    var value = this.popStack(),
	        context = undefined,
	        type = undefined,
	        id = undefined;

	    if (this.trackIds) {
	      id = this.popStack();
	    }
	    if (this.stringParams) {
	      type = this.popStack();
	      context = this.popStack();
	    }

	    var hash = this.hash;
	    if (context) {
	      hash.contexts[key] = context;
	    }
	    if (type) {
	      hash.types[key] = type;
	    }
	    if (id) {
	      hash.ids[key] = id;
	    }
	    hash.values[key] = value;
	  },

	  pushId: function pushId(type, name, child) {
	    if (type === 'BlockParam') {
	      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
	    } else if (type === 'PathExpression') {
	      this.pushString(name);
	    } else if (type === 'SubExpression') {
	      this.pushStackLiteral('true');
	    } else {
	      this.pushStackLiteral('null');
	    }
	  },

	  // HELPERS

	  compiler: JavaScriptCompiler,

	  compileChildren: function compileChildren(environment, options) {
	    var children = environment.children,
	        child = undefined,
	        compiler = undefined;

	    for (var i = 0, l = children.length; i < l; i++) {
	      child = children[i];
	      compiler = new this.compiler(); // eslint-disable-line new-cap

	      var existing = this.matchExistingProgram(child);

	      if (existing == null) {
	        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
	        var index = this.context.programs.length;
	        child.index = index;
	        child.name = 'program' + index;
	        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
	        this.context.decorators[index] = compiler.decorators;
	        this.context.environments[index] = child;

	        this.useDepths = this.useDepths || compiler.useDepths;
	        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
	        child.useDepths = this.useDepths;
	        child.useBlockParams = this.useBlockParams;
	      } else {
	        child.index = existing.index;
	        child.name = 'program' + existing.index;

	        this.useDepths = this.useDepths || existing.useDepths;
	        this.useBlockParams = this.useBlockParams || existing.useBlockParams;
	      }
	    }
	  },
	  matchExistingProgram: function matchExistingProgram(child) {
	    for (var i = 0, len = this.context.environments.length; i < len; i++) {
	      var environment = this.context.environments[i];
	      if (environment && environment.equals(child)) {
	        return environment;
	      }
	    }
	  },

	  programExpression: function programExpression(guid) {
	    var child = this.environment.children[guid],
	        programParams = [child.index, 'data', child.blockParams];

	    if (this.useBlockParams || this.useDepths) {
	      programParams.push('blockParams');
	    }
	    if (this.useDepths) {
	      programParams.push('depths');
	    }

	    return 'container.program(' + programParams.join(', ') + ')';
	  },

	  useRegister: function useRegister(name) {
	    if (!this.registers[name]) {
	      this.registers[name] = true;
	      this.registers.list.push(name);
	    }
	  },

	  push: function push(expr) {
	    if (!(expr instanceof Literal)) {
	      expr = this.source.wrap(expr);
	    }

	    this.inlineStack.push(expr);
	    return expr;
	  },

	  pushStackLiteral: function pushStackLiteral(item) {
	    this.push(new Literal(item));
	  },

	  pushSource: function pushSource(source) {
	    if (this.pendingContent) {
	      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
	      this.pendingContent = undefined;
	    }

	    if (source) {
	      this.source.push(source);
	    }
	  },

	  replaceStack: function replaceStack(callback) {
	    var prefix = ['('],
	        stack = undefined,
	        createdStack = undefined,
	        usedLiteral = undefined;

	    /* istanbul ignore next */
	    if (!this.isInline()) {
	      throw new _exception2['default']('replaceStack on non-inline');
	    }

	    // We want to merge the inline statement into the replacement statement via ','
	    var top = this.popStack(true);

	    if (top instanceof Literal) {
	      // Literals do not need to be inlined
	      stack = [top.value];
	      prefix = ['(', stack];
	      usedLiteral = true;
	    } else {
	      // Get or create the current stack name for use by the inline
	      createdStack = true;
	      var _name = this.incrStack();

	      prefix = ['((', this.push(_name), ' = ', top, ')'];
	      stack = this.topStack();
	    }

	    var item = callback.call(this, stack);

	    if (!usedLiteral) {
	      this.popStack();
	    }
	    if (createdStack) {
	      this.stackSlot--;
	    }
	    this.push(prefix.concat(item, ')'));
	  },

	  incrStack: function incrStack() {
	    this.stackSlot++;
	    if (this.stackSlot > this.stackVars.length) {
	      this.stackVars.push('stack' + this.stackSlot);
	    }
	    return this.topStackName();
	  },
	  topStackName: function topStackName() {
	    return 'stack' + this.stackSlot;
	  },
	  flushInline: function flushInline() {
	    var inlineStack = this.inlineStack;
	    this.inlineStack = [];
	    for (var i = 0, len = inlineStack.length; i < len; i++) {
	      var entry = inlineStack[i];
	      /* istanbul ignore if */
	      if (entry instanceof Literal) {
	        this.compileStack.push(entry);
	      } else {
	        var stack = this.incrStack();
	        this.pushSource([stack, ' = ', entry, ';']);
	        this.compileStack.push(stack);
	      }
	    }
	  },
	  isInline: function isInline() {
	    return this.inlineStack.length;
	  },

	  popStack: function popStack(wrapped) {
	    var inline = this.isInline(),
	        item = (inline ? this.inlineStack : this.compileStack).pop();

	    if (!wrapped && item instanceof Literal) {
	      return item.value;
	    } else {
	      if (!inline) {
	        /* istanbul ignore next */
	        if (!this.stackSlot) {
	          throw new _exception2['default']('Invalid stack pop');
	        }
	        this.stackSlot--;
	      }
	      return item;
	    }
	  },

	  topStack: function topStack() {
	    var stack = this.isInline() ? this.inlineStack : this.compileStack,
	        item = stack[stack.length - 1];

	    /* istanbul ignore if */
	    if (item instanceof Literal) {
	      return item.value;
	    } else {
	      return item;
	    }
	  },

	  contextName: function contextName(context) {
	    if (this.useDepths && context) {
	      return 'depths[' + context + ']';
	    } else {
	      return 'depth' + context;
	    }
	  },

	  quotedString: function quotedString(str) {
	    return this.source.quotedString(str);
	  },

	  objectLiteral: function objectLiteral(obj) {
	    return this.source.objectLiteral(obj);
	  },

	  aliasable: function aliasable(name) {
	    var ret = this.aliases[name];
	    if (ret) {
	      ret.referenceCount++;
	      return ret;
	    }

	    ret = this.aliases[name] = this.source.wrap(name);
	    ret.aliasable = true;
	    ret.referenceCount = 1;

	    return ret;
	  },

	  setupHelper: function setupHelper(paramSize, name, blockHelper) {
	    var params = [],
	        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
	    var foundHelper = this.nameLookup('helpers', name, 'helper'),
	        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');

	    return {
	      params: params,
	      paramsInit: paramsInit,
	      name: foundHelper,
	      callParams: [callContext].concat(params)
	    };
	  },

	  setupParams: function setupParams(helper, paramSize, params) {
	    var options = {},
	        contexts = [],
	        types = [],
	        ids = [],
	        objectArgs = !params,
	        param = undefined;

	    if (objectArgs) {
	      params = [];
	    }

	    options.name = this.quotedString(helper);
	    options.hash = this.popStack();

	    if (this.trackIds) {
	      options.hashIds = this.popStack();
	    }
	    if (this.stringParams) {
	      options.hashTypes = this.popStack();
	      options.hashContexts = this.popStack();
	    }

	    var inverse = this.popStack(),
	        program = this.popStack();

	    // Avoid setting fn and inverse if neither are set. This allows
	    // helpers to do a check for `if (options.fn)`
	    if (program || inverse) {
	      options.fn = program || 'container.noop';
	      options.inverse = inverse || 'container.noop';
	    }

	    // The parameters go on to the stack in order (making sure that they are evaluated in order)
	    // so we need to pop them off the stack in reverse order
	    var i = paramSize;
	    while (i--) {
	      param = this.popStack();
	      params[i] = param;

	      if (this.trackIds) {
	        ids[i] = this.popStack();
	      }
	      if (this.stringParams) {
	        types[i] = this.popStack();
	        contexts[i] = this.popStack();
	      }
	    }

	    if (objectArgs) {
	      options.args = this.source.generateArray(params);
	    }

	    if (this.trackIds) {
	      options.ids = this.source.generateArray(ids);
	    }
	    if (this.stringParams) {
	      options.types = this.source.generateArray(types);
	      options.contexts = this.source.generateArray(contexts);
	    }

	    if (this.options.data) {
	      options.data = 'data';
	    }
	    if (this.useBlockParams) {
	      options.blockParams = 'blockParams';
	    }
	    return options;
	  },

	  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
	    var options = this.setupParams(helper, paramSize, params);
	    options.loc = JSON.stringify(this.source.currentLocation);
	    options = this.objectLiteral(options);
	    if (useRegister) {
	      this.useRegister('options');
	      params.push('options');
	      return ['options=', options];
	    } else if (params) {
	      params.push(options);
	      return '';
	    } else {
	      return options;
	    }
	  }
	};

	(function () {
	  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

	  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

	  for (var i = 0, l = reservedWords.length; i < l; i++) {
	    compilerWords[reservedWords[i]] = true;
	  }
	})();

	JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
	  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
	};

	function strictLookup(requireTerminal, compiler, parts, type) {
	  var stack = compiler.popStack(),
	      i = 0,
	      len = parts.length;
	  if (requireTerminal) {
	    len--;
	  }

	  for (; i < len; i++) {
	    stack = compiler.nameLookup(stack, parts[i], type);
	  }

	  if (requireTerminal) {
	    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ', ', JSON.stringify(compiler.source.currentLocation), ' )'];
	  } else {
	    return stack;
	  }
	}

	exports['default'] = JavaScriptCompiler;
	module.exports = exports['default'];

	});

	unwrapExports(javascriptCompiler);

	var handlebars = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



	var _handlebarsRuntime2 = _interopRequireDefault(handlebars_runtime);

	// Compiler imports



	var _handlebarsCompilerAst2 = _interopRequireDefault(ast);







	var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(javascriptCompiler);



	var _handlebarsCompilerVisitor2 = _interopRequireDefault(visitor);



	var _handlebarsNoConflict2 = _interopRequireDefault(noConflict);

	var _create = _handlebarsRuntime2['default'].create;
	function create() {
	  var hb = _create();

	  hb.compile = function (input, options) {
	    return compiler.compile(input, options, hb);
	  };
	  hb.precompile = function (input, options) {
	    return compiler.precompile(input, options, hb);
	  };

	  hb.AST = _handlebarsCompilerAst2['default'];
	  hb.Compiler = compiler.Compiler;
	  hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
	  hb.Parser = base$1.parser;
	  hb.parse = base$1.parse;
	  hb.parseWithoutProcessing = base$1.parseWithoutProcessing;

	  return hb;
	}

	var inst = create();
	inst.create = create;

	_handlebarsNoConflict2['default'](inst);

	inst.Visitor = _handlebarsCompilerVisitor2['default'];

	inst['default'] = inst;

	exports['default'] = inst;
	module.exports = exports['default'];

	});

	unwrapExports(handlebars);

	var printer = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.print = print;
	exports.PrintVisitor = PrintVisitor;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



	var _visitor2 = _interopRequireDefault(visitor);

	function print(ast) {
	  return new PrintVisitor().accept(ast);
	}

	function PrintVisitor() {
	  this.padding = 0;
	}

	PrintVisitor.prototype = new _visitor2['default']();

	PrintVisitor.prototype.pad = function (string) {
	  var out = '';

	  for (var i = 0, l = this.padding; i < l; i++) {
	    out += '  ';
	  }

	  out += string + '\n';
	  return out;
	};

	PrintVisitor.prototype.Program = function (program) {
	  var out = '',
	      body = program.body,
	      i = undefined,
	      l = undefined;

	  if (program.blockParams) {
	    var blockParams = 'BLOCK PARAMS: [';
	    for (i = 0, l = program.blockParams.length; i < l; i++) {
	      blockParams += ' ' + program.blockParams[i];
	    }
	    blockParams += ' ]';
	    out += this.pad(blockParams);
	  }

	  for (i = 0, l = body.length; i < l; i++) {
	    out += this.accept(body[i]);
	  }

	  this.padding--;

	  return out;
	};

	PrintVisitor.prototype.MustacheStatement = function (mustache) {
	  return this.pad('{{ ' + this.SubExpression(mustache) + ' }}');
	};
	PrintVisitor.prototype.Decorator = function (mustache) {
	  return this.pad('{{ DIRECTIVE ' + this.SubExpression(mustache) + ' }}');
	};

	PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function (block) {
	  var out = '';

	  out += this.pad((block.type === 'DecoratorBlock' ? 'DIRECTIVE ' : '') + 'BLOCK:');
	  this.padding++;
	  out += this.pad(this.SubExpression(block));
	  if (block.program) {
	    out += this.pad('PROGRAM:');
	    this.padding++;
	    out += this.accept(block.program);
	    this.padding--;
	  }
	  if (block.inverse) {
	    if (block.program) {
	      this.padding++;
	    }
	    out += this.pad('{{^}}');
	    this.padding++;
	    out += this.accept(block.inverse);
	    this.padding--;
	    if (block.program) {
	      this.padding--;
	    }
	  }
	  this.padding--;

	  return out;
	};

	PrintVisitor.prototype.PartialStatement = function (partial) {
	  var content = 'PARTIAL:' + partial.name.original;
	  if (partial.params[0]) {
	    content += ' ' + this.accept(partial.params[0]);
	  }
	  if (partial.hash) {
	    content += ' ' + this.accept(partial.hash);
	  }
	  return this.pad('{{> ' + content + ' }}');
	};
	PrintVisitor.prototype.PartialBlockStatement = function (partial) {
	  var content = 'PARTIAL BLOCK:' + partial.name.original;
	  if (partial.params[0]) {
	    content += ' ' + this.accept(partial.params[0]);
	  }
	  if (partial.hash) {
	    content += ' ' + this.accept(partial.hash);
	  }

	  content += ' ' + this.pad('PROGRAM:');
	  this.padding++;
	  content += this.accept(partial.program);
	  this.padding--;

	  return this.pad('{{> ' + content + ' }}');
	};

	PrintVisitor.prototype.ContentStatement = function (content) {
	  return this.pad("CONTENT[ '" + content.value + "' ]");
	};

	PrintVisitor.prototype.CommentStatement = function (comment) {
	  return this.pad("{{! '" + comment.value + "' }}");
	};

	PrintVisitor.prototype.SubExpression = function (sexpr) {
	  var params = sexpr.params,
	      paramStrings = [],
	      hash = undefined;

	  for (var i = 0, l = params.length; i < l; i++) {
	    paramStrings.push(this.accept(params[i]));
	  }

	  params = '[' + paramStrings.join(', ') + ']';

	  hash = sexpr.hash ? ' ' + this.accept(sexpr.hash) : '';

	  return this.accept(sexpr.path) + ' ' + params + hash;
	};

	PrintVisitor.prototype.PathExpression = function (id) {
	  var path = id.parts.join('/');
	  return (id.data ? '@' : '') + 'PATH:' + path;
	};

	PrintVisitor.prototype.StringLiteral = function (string) {
	  return '"' + string.value + '"';
	};

	PrintVisitor.prototype.NumberLiteral = function (number) {
	  return 'NUMBER{' + number.value + '}';
	};

	PrintVisitor.prototype.BooleanLiteral = function (bool) {
	  return 'BOOLEAN{' + bool.value + '}';
	};

	PrintVisitor.prototype.UndefinedLiteral = function () {
	  return 'UNDEFINED';
	};

	PrintVisitor.prototype.NullLiteral = function () {
	  return 'NULL';
	};

	PrintVisitor.prototype.Hash = function (hash) {
	  var pairs = hash.pairs,
	      joinedPairs = [];

	  for (var i = 0, l = pairs.length; i < l; i++) {
	    joinedPairs.push(this.accept(pairs[i]));
	  }

	  return 'HASH{' + joinedPairs.join(', ') + '}';
	};
	PrintVisitor.prototype.HashPair = function (pair) {
	  return pair.key + '=' + this.accept(pair.value);
	};
	/* eslint-enable new-cap */

	});

	unwrapExports(printer);
	var printer_1 = printer.print;
	var printer_2 = printer.PrintVisitor;

	// USAGE:
	// var handlebars = require('handlebars');
	/* eslint-disable no-var */

	// var local = handlebars.create();

	var handlebars$1 = handlebars['default'];


	handlebars$1.PrintVisitor = printer.PrintVisitor;
	handlebars$1.print = printer.print;

	var lib = handlebars$1;

	// Publish a Node.js require() handler for .handlebars and .hbs files
	function extension(module, filename) {
	  var fs$1 = fs;
	  var templateString = fs$1.readFileSync(filename, 'utf8');
	  module.exports = handlebars$1.compile(templateString);
	}
	/* istanbul ignore else */
	if (typeof commonjsRequire !== 'undefined' && commonjsRequire.extensions) {
	  commonjsRequire.extensions['.handlebars'] = extension;
	  commonjsRequire.extensions['.hbs'] = extension;
	}

	// GridRenderer {{{1

	// Constructor {{{2

	/**
	 * @param {Grid} grid
	 *
	 * @param {object} defn
	 *
	 * @param {View} view
	 *
	 * @param {object} features
	 *
	 * @param {object} opts
	 *
	 * @param {Timing} timing
	 *
	 * @param {string} id
	 *
	 * @class
	 */

	var GridRenderer = (function () {
		var UNIQUE_ID = 0;

		return makeSubclass('GridRenderer', Object, function (grid, defn, view, features, opts, timing, id, colConfig) {
			var self = this;

			self.UNIQUE_ID = UNIQUE_ID++;

			self.id = id;
			self.grid = grid;
			self.defn = defn;
			self.view = view;
			self.features = deepCopy(features);
			self.opts = opts;
			self.timing = timing;
			self.colConfig = colConfig;
			self.hasRendered = false;

			self._validateFeatures();

			self.drawLock = new Lock('Draw');

			self.grid.on('colConfigUpdate', function (newColConfig) {
				debug.info('GRID RENDERER', 'Received new colConfig: %O', newColConfig);
				self.colConfig = newColConfig;
				if (self.hasRendered) {
					debug.info('GRID RENDERER', 'Redrawing with new colConfig');
					self.draw(self.root, self.drawOpts);
				}
			}, { who: self });
		});
	})();

	// FIXME: We don't need all these, we only need "unableToRender."  However, mixinEventHandling()
	// can't traverse the class hierarchy, so trying to subscribe to "unableToRender" from a GridTable
	// will not work (because "unableToRender" isn't in the GridTable subclass' event list).  So for a
	// quick workaround, we just put all the events that any subclass may use here.  But the real fix
	// should be to make mixinEventHandling() traverse up the superclass chain.

	mixinEventHandling(GridRenderer, [
			'columnResize'        // A column is resized.
		, 'unableToRender'      // A grid renderer can't render the data in the view it's bound to.
		, 'limited'             // The grid table isn't rendering all possible rows.
		, 'unlimited'           // The grid table is rendering all possible rows.
		, 'csvReady'            // CSV data has been generated.
		, 'generateCsvProgress' // CSV generation progress.
		, 'renderBegin'
		, 'renderEnd'
		, 'selectionChange'
	]);

	// #canRender {{{2

	GridRenderer.prototype.canRender = function () {
		throw new Error('ABSTRACT');
	};

	// #draw {{{2

	GridRenderer.prototype.draw = function (root, opts, cont) {
		var self = this;
		var args = Array.prototype.slice.call(arguments);

		debug.info('GRID RENDERER // DRAW', 'Beginning draw operation; opts = %O', opts);

		opts = opts || {};

		self.root = root;
		self.drawOpts = opts;

		if (self.drawLock.isLocked()) {
			return self.drawLock.onUnlock(function () {
				GridRenderer.prototype.draw.apply(self, args);
			});
		}

		self.drawLock.lock();

		self.clear();

		return self.view.getData(function (ok, data) {
			if (!ok) {
				return cont(false);
			}

			debug.info('GRID RENDERER // DRAW', 'Data = %O', data);

			return self.view.getTypeInfo(function (ok, typeInfo) {
				if (!ok) {
					return cont(false);
				}

				debug.info('GRID RENDERER // DRAW', 'TypeInfo = %O', typeInfo.asMap());

				if ((data.isPlain && !self.canRender('plain'))
						|| (data.isGroup && !self.canRender('group'))
						|| (data.isPivot && !self.canRender('pivot'))) {

					debug.info('GRID RENDERER // DRAW', 'Unable to render data using current grid table: { isPlain = %s ; isGroup = %s ; isPivot = %s }', data.isPlain, data.isGroup, data.isPivot);

					return self.fire('unableToRender');
				}

				self.hasRendered = true;
				self.fire('renderBegin');

				self.data = data;
				self.typeInfo = typeInfo;

				self.timing.start(['Grid Renderer', 'Draw']);

				return cont(true, data, typeInfo);
			});
		});
	};

	// #clear {{{2

	/**
	 * Remove the table from page.
	 */

	GridRenderer.prototype.clear = function () {
		var self = this;

		self.root.children().remove();
	};

	// #destroy {{{2

	GridRenderer.prototype.destroy = function () {
		var self = this;

		self.clear();
		self.grid.off('*', self);
	};

	// #toString {{{2

	GridRenderer.prototype.toString = function () {
		var self = this;

		return '#<GridRenderer ' + self.UNIQUE_ID + '>';
	};

	// #_validateFeatures {{{2

	GridRenderer.prototype._validateFeatures = function () {
		return true;
	};

	// Registry {{{1

	GridRenderer.registry = new OrdMap();

	// Imports {{{1

	// Csv {{{1

	/**
	 * @typedef {object} Csv~Row
	 *
	 * @property {number} rowId
	 * @property {boolean} hidden
	 * @property {any[]} rowData
	 */

	/**
	 * Represents the data that will be output by exporting the grid table to a spreadsheet format like
	 * CSV.  This is used by grid table rendering functions to build the exported data while rendering
	 * the HTML data shown onscreen.
	 *
	 * @property {number} lastRowId
	 * The row ID of the last-added row.
	 *
	 * @property {Csv~Row} lastRow
	 * The last-added row.
	 *
	 * @property {Csv~Row[]} data
	 * All rows.
	 *
	 * @property {object} opts
	 * Options for serializing the data to a string.
	 *
	 * @property {string} opts.separator
	 * Column separator used when serializing.
	 */

	var Csv = makeSubclass('Csv', Object, function (opts) {
		var self = this;

		self.lastRowId = -2;
		self.opts = opts || {};

		underscore.defaults(self.opts, {
			separator: ','
		});

		self.clear();
	});

	// #addRow {{{2

	/**
	 * Add a row to the data set.
	 *
	 * @param {number} [rowId]
	 * Row ID of the newly added row; if omitted, the last number is just incremented.
	 */

	Csv.prototype.addRow = function (rowId) {
		var self = this;

		if (rowId == null) {
			rowId = ++self.lastRowId;
		}

		self.lastRow = {
			rowId: rowId,
			rowData: [],
			hidden: false
		};
		self.data.push(self.lastRow);
	};

	// #addCol {{{2

	/**
	 * Add a column to the current row.
	 *
	 * @param {string} x
	 * The value to add.
	 */

	Csv.prototype.addCol = function (x, opts) {
		var self = this;

		opts = opts || {};
		opts = underscore.defaults(opts, {
			prepend: false
		});

		if (x == null) {
			x = '';
		}
		else if (typeof x !== 'string') {
			x = x.toString();
		}

		// In case you didn't add a row before you added the first column.  Shame on you.

		if (self.lastRow == null) {
			self.addRow();
		}

		if (opts.prepend) {
			self.lastRow.rowData.unshift(x);
		}
		else {
			self.lastRow.rowData.push(x);
		}
	};

	// #clear {{{2

	/**
	 * Reset the CSV data buffer.
	 */

	Csv.prototype.clear = function () {
		var self = this;

		self.lastRowId = -2;
		self.data = [];
		self.lastRow = null;
		self.order = null;
	};

	// #toString {{{2

	/**
	 * Render the entire set of data accumulated to a string.
	 */

	Csv.prototype.toString = function () {
		var self = this;
		var i, row;

		var s = '';
		var sep = '"' + self.opts.separator + '"';
		var len = self.order != null ? self.order.length : self.data.length;

		var quoteRegexp = /"/g;

		for (i = 0; i < len; i += 1) {
			row = self.order != null ? self.getRowById(self.order[i]) : self.data[i];
			if (i > 0) {
				s += '\r\n';
			}
			s += '"' + row.rowData.map(function (s) {
				return s.replace(quoteRegexp, '""');
			}).join(sep) + '"';
		}

		return s;
	};

	// #getRowById {{{2

	Csv.prototype.getRowById = function (rowId) {
		var self = this;

		return self.data[rowId].rowId === rowId
			? self.data[rowId]
			: underscore.findWhere(self.data, {rowId: rowId});
	};

	// #updateVisibility {{{2

	Csv.prototype.updateVisibility = function (rowId, hide) {
		var self = this;
		var row = self.getRowById(rowId);

		if (row != null) {
			row.hidden = hide;
		}
	};

	// #setOrder {{{2

	Csv.prototype.setOrder = function (rowId, pos) {
		var self = this;

		if (self.order == null) {
			self.order = [];
		}

		self.order[pos] = rowId;
	};

	// GridTable {{{1
	// JSDoc Types {{{2

	/**
	 * @typedef {function} GridTable~RowRenderCb
	 * A callback that gets executed when a row is rendered in the table.
	 *
	 * @param {jQuery} tr
	 * The row we've just finished rendering.
	 *
	 * @param {object} opts
	 * Additional information for the callback.
	 *
	 * @param {boolean} opts.isGroup
	 * True if we're in group output.
	 *
	 * @param {boolean} opts.groupMode
	 * The group output mode, either "summary" or "detail."
	 *
	 * @param {string} opts.groupField
	 * In group output, detail mode, when rendering a group (i.e. non-leaf node): the name of the field
	 * that is currently being rendered.  Example: When grouping by [State, County] this property can
	 * either by "State" or "County" depending on what part of the tree is being rendered.
	 *
	 * @param {string} opts.rowValElt
	 * In group output, detail mode, when rendering a group (i.e. non-leaf node): the shared value of
	 * the field given by `opts.groupField` for all rows in the grouping currently being rendered.
	 * Following the previous example, it could be "New Mexico" or "Donut County."
	 *
	 * @param {metadataNode} opts.groupMetadata
	 * In group output, detail mode, when rendering a group (i.e. non-leaf node): additional metadata
	 * from the grouping process.  Can be used to find the number of children, for example.
	 *
	 * @param {Array.<object>} rowData
	 * In group output, detail mode, when rendering a row (i.e. leaf node): the data that has been
	 * rendered.
	 *
	 * @param {number} rowNum
	 * In group output, detail mode, when rendering a row (i.e. leaf node): the unique row identifier.
	 */

	/**
	 * @typedef {function} GridTable~AddCols_Value_Plain
	 *
	 * @param {Array.<object>} rowData
	 * The data of the row that has been rendered.
	 *
	 * @param {number} rowNum
	 * The unique ID of thw row that was rendered.
	 */

	/**
	 * @typedef {function} GridTable~AddCols_Value_Pivot
	 *
	 * @param {object} data
	 * @param {number} groupNum
	 */

	/**
	 * @typedef GridTable~AddCols
	 *
	 * @property {string} name
	 * The name of the column to add, which appears in the table header.
	 *
	 * @property {GridTable~AddCols_Value_Plain|GridTable~AddCols_Value_Pivot} value
	 * A function that is called to determine what gets put into the table cell.
	 */

	/**
	 * @typedef GridTable~CtorOpts
	 *
	 * @property {boolean} [drawInternalBorders=true]
	 * If true, draw borders between the cells in the table.
	 *
	 * @property {boolean} [zebraStriping=true]
	 * If true, use subtle alternating background colors in the table rows.
	 *
	 * @property {boolean} [generateCsv=true]
	 * If true, allow the generation of a CSV file from the table contents.
	 *
	 * @property {boolean} [stealGridFooter=true]
	 * If true, absorb the element specified by `footer` into the table footer.
	 *
	 * @property {object} [addClass]
	 * Additional classes to add when generating the table.
	 *
	 * @property {string} [addClass.table]
	 * Classes to add on the table element itself.
	 *
	 * @property {Array.<GridTable~AddCols>} [addCols]
	 * Columns to add to the table.  These are always computed as rows are rendered, and they are not
	 * backed by the View so they can't be sorted or filtered.  This option is best used as a way of
	 * adding some UI to the table row.
	 *
	 * @property {object} [events]
	 * Callbacks to bind on various events.
	 *
	 * @property {GridTable~RowRenderCb} [events.rowRender]
	 * A callback to invoke when a row is rendered.
	 *
	 * @property {jQuery} [footer]
	 * **Internal** An element to put into the table footer.
	 *
	 * @property {boolean} [fixedHeight]
	 * **Internal** If true, configure the table to scroll within the parent element.
	 */

	// Constructor {{{2

	/**
	 * @class
	 * @extends GridRenderer
	 *
	 * An abstract base class for all grid tables (which are responsible for building the DOM elements
	 * to represent the data in a tabular format).  Concrete subclasses must implement the following
	 * methods:
	 *
	 *   - `drawHeader(columns, data, typeInfo, opts)`
	 *   - `drawBody(data, typeInfo, columns, cont, opts)`
	 *   - `addWorkHandler()`
	 *   - `canRender()`
	 *
	 * @property {number} UNIQUE_ID
	 * A unique number for this grid table, used to generate namespaces for event handlers.
	 *
	 * @property {string} id
	 *
	 * @property {Grid} grid
	 *
	 * @property {object} defn
	 *
	 * @property {View} view
	 *
	 * @property {object} features
	 *
	 * @property {GridTable~CtorOpts} opts
	 * Additional options for the renderer.
	 *
	 * @property {Timing} timing
	 *
	 * @property {Array.<number>} selection
	 * An array of the row IDs of selected rows.  The row ID here refers to that used by the source, so
	 * the selection maps directly back to the underlying source data.
	 *
	 * @property {boolean} needsRedraw
	 * If true, then the view has done something that requires us to be redrawn.
	 *
	 * @property {OrdMap} colConfig
	 */

	var GridTable = makeSubclass('GridTable', GridRenderer, function () {
		var self = this;

		self.super.ctor.apply(self, arguments);

		self.selection = [];
		self.needsRedraw = false;
		self.contextMenuSelectors = [];

		underscore.defaults(self.opts, {
			drawInternalBorders: true,
			zebraStriping: true,
			generateCsv: true,
			stealGridFooter: true
		});
	});

	// Events {{{2

	/**
	 * Fired when columns have been resized automatically.  No longer used.
	 *
	 * @event GridTable#columnResize
	 */

	/**
	 * Fired when the current GridRenderer subclass instance is unable to render the data from the view,
	 * potentially because the view performed an operation (e.g. pivot) that this renderer is not able
	 * to show the result of.
	 *
	 * @event GridTable#unableToRender
	 *
	 * @param {View~OperationsPerformed} ops
	 * The operations performed by the view.
	 */

	/**
	 * Fired when the output has been limited according to the renderer's limit configuration.
	 *
	 * @event GridTable#limited
	 */

	/**
	 * Fired when all output is being shown, even though the grid is configured to limit output.  Most
	 * likely, this is due to the number of rows not reaching the threshold configured for limiting.
	 *
	 * @event GridTable#unlimited
	 */

	/**
	 * Fired when asynchronous CSV generation is finished.
	 *
	 * @event GridTable#csvReady
	 */

	/**
	 * Fired periodically while generating the CSV file to indicate progress.  Before rendering starts,
	 * it will be fired with a `progress` value of 0.  After rendering is done, it will be fired with a
	 * `progress` value of 100.
	 *
	 * @event GridTable#generateCsvProgress
	 *
	 * @param {number} progress
	 * The progress on a scale from 0 to 100.
	 */

	/**
	 * Fired when rendering has started.
	 *
	 * @event GridTable#renderBegin
	 */

	/**
	 * Fired when rendering has finished.
	 *
	 * @event GridTable#renderEnd
	 */

	mixinEventHandling(GridTable, [
			'columnResize'        // A column is resized.
		, 'unableToRender'      // A grid table can't render the data in the view it's bound to.
		, 'limited'             // The grid table isn't rendering all possible rows.
		, 'unlimited'           // The grid table is rendering all possible rows.
		, 'csvReady'            // CSV data has been generated.
		, 'generateCsvProgress' // CSV generation progress.
		, 'renderBegin'
		, 'renderEnd'
		, 'selectionChange'
	]);

	// #_validateFeatures {{{2

	GridTable.prototype._validateFeatures = function () {
		var self = this;

		if (self.features.block && !jQuery.blockUI) {
			log.error('GRID TABLE // CONFIG',
								'Feature "block" requires BlockUI library, which is not present');
			self.features.block = false;
		}

		if (self.features.limit) {
			self._validateLimit();

			self.scrollEvents = ['DOMContentLoaded', 'load', 'resize', 'scroll'].map(function (x) {
				return x + '.wcdv_gt_' + self.UNIQUE_ID;
			}).join(' ');
		}

		if (self.features.floatingHeader) {
			self._validateFloatTableHeader();
		}
	};

	// #_validateLimit {{{2

	/**
	 * Make sure the limit configuration is good.  If there's anything wrong, the limit feature is
	 * disabled automatically.
	 */

	GridTable.prototype._validateLimit = function () {
		var self = this;

		if (self.features.limit) {
			if (self.defn.table.limit.threshold === undefined) {
				debug.warn('GRID TABLE - PLAIN // DRAW', 'Disabling limit feature because no limit threshold was provided');
				self.features.limit = false;
			}
		}
	};

	// #_validateFloatTableHeader {{{2

	GridTable.prototype._validateFloatTableHeader = function () {
		var self = this;

		if (!self.features.floatingHeader) {
			return;
		}

		var config = getPropDef({}, self.defn, 'table', 'floatingHeader');

		if (config.method != null) {

			// The user requested a specific method for doing the floating header, make sure that the
			// library required is actually available.

			switch (config.method) {
			case 'floatThead':
				if (jQuery.prototype.floatThead == null) {
					log.error('GRID TABLE // CONFIG', 'Requested floating header method "floatThead" is not available');
					self.features.floatingHeader = false;
				}
				break;
			case 'fixedHeaderTable':
				if (jQuery.prototype.fixedHeaderTable == null) {
					log.error('GRID TABLE // CONFIG', 'Requested floating header method "fixedHeaderTable" is not available');
					self.features.floatingHeader = false;
				}
				break;
			case 'tabletool':
				if (window.TableTool == null) {
					log.error('GRID TABLE // CONFIG', 'Requested floating header method "tabletool" is not available');
					self.features.floatingHeader = false;
				}
				break;
			default:
				log.error('GRID TABLE // CONFIG', 'Unrecognized floating header method: ' + config.method);
				self.features.floatingHeader = false;
			}
		}
		else {

			// The user didn't request a specific method for doing the floating header, so let's look at
			// what libraries are available and pick based on that.

			if (jQuery.prototype.floatThead) {
				config.method = 'floatThead';
			}
			else if (jQuery.prototype.fixedHeaderTable) {
				config.method = 'fixedHeaderTable';
			}
			else if (window.TableTool) {
				config.method = 'tabletool';
			}
			else {
				self.features.floatingHeader = false;
			}
		}

		self.defn.table.floatingHeader = config;
	};

	// #setCss {{{2

	GridTable.prototype.setCss = function (elt, field) {
		var self = this;
		var fcc = self.colConfig.get(field);

		if (fcc == null) {
			return;
		}

		var css = [
			{ configName: 'width'        , cssName: 'width'      },
			{ configName: 'minWidth'     , cssName: 'min-width'  },
			{ configName: 'maxWidth'     , cssName: 'max-width'  },
			{ configName: 'cellAlignment', cssName: 'text-align' }
		];

		for (var i = 0; i < css.length; i += 1) {
			if (fcc[css[i].configName] !== undefined) {
				elt.css(css[i].cssName, fcc[css[i].configName]);
			}
		}
	};

	// #setAlignment {{{2

	/**
	 * Set the alignment on a table cell.
	 *
	 * @param {HTMLElement} elt
	 * The element to set alignment on.
	 *
	 * @param {Grid~FieldColConfig} [fcc]
	 * Column configuration for the field that this cell is based on.
	 *
	 * @param {Grid~FieldTypeInfo} [fti]
	 * Type information for the field that this cell is based on.
	 *
	 * @param {string} [overrideType]
	 * Override the type of the field, used when an aggregate function produces a result with a
	 * different type than the source field (e.g. distinctValues of a date produces a string, not a
	 * date, so `overrideType` should be "string").
	 *
	 * @param {string} [fallback]
	 * Fallback default alignment when no alignment is determined by DataVis.
	 */

	GridTable.prototype.setAlignment = function (elt, fcc, fti, overrideType, fallback) {
		fcc = fcc || {};
		fti = fti || {};

		if (elt instanceof jQuery) {
			elt = elt.get(0);
		}

		if (!(elt instanceof Element)) {
			throw new Error('Call Error: `elt` must be an instance of Element');
		}

		var type = overrideType || fti.type;
		var alignment = fcc.cellAlignment || fallback;

		if (alignment == null && (type === 'number' || type === 'currency')) {
			alignment = 'right';
		}

		switch (alignment) {
		case 'left':
			elt.classList.add('wcdvgrid_textLeft');
			break;
		case 'right':
			elt.classList.add('wcdvgrid_textRight');
			break;
		case 'center':
			elt.classList.add('wcdvgrid_textCenter');
			break;
		case 'justify':
			elt.classList.add('wcdvgrid_textJustify');
			break;
		default:
			// We don't have a class for every possible value, so just set the style rule on the element in
			// those cases.  This should be extremely rare, given what we've covered above.
			elt.style.setProperty('text-align', alignment);
		}
	};

	// #_addSortingToHeader {{{2

	/**
	 * Attaches a sort icon to the given table header element, which (1) indicates the current sort, and
	 * (2) when clicked brings up a menu to allow sorting by that header.
	 *
	 * @param {any} data
	 *
	 * @param {string} orientation
	 * Indicates whether the sorting is `horizontal` (i.e. sorting reorders columns) or `vertical` (i.e.
	 * sorting reorders rows).
	 *
	 * @param {View~SortSpec} spec
	 * The sort spec.
	 *
	 * @param {Element} th
	 * Where to place the sort icon.
	 *
	 * @param {Array.<View~AggInfo>} agg
	 * Aggregate functions which we can sort by their results.
	 */

	GridTable.prototype._addSortingToHeader = function (data, orientation, spec, container, agg) {
		var self = this;

		if (!self.features.sort) {
			return;
		}

		if (['horizontal', 'vertical'].indexOf(orientation) < 0) {
			throw new Error('Call Error: `orientation` must be "horizontal" or "vertical"');
		}
		if (!(container instanceof Element)) {
			throw new Error('Call Error: `container` must be an Element');
		}

		var sortIcon_orientationClass = 'wcdv_sort_icon_' + orientation;

		/**
		 * @param {Element} span
		 * The sort indicator span to replace.
		 *
		 * @param {string} [dir]
		 * What direction we're sorting by, ascending or descending.
		 */

		var replaceSortIndicator = function (span, dir) {
			if (!(span instanceof Element)) {
				throw new Error('Call Error: `span` must be an Element');
			}
			if (dir != null) {
				if (!underscore.isString(dir)) {
					throw new Error('Call Error: `dir` must be null or a string');
				}
				else if (dir.toUpperCase() !== 'ASC' && dir.toUpperCase() !== 'DESC') {
					throw new Error('Call Error: `dir` must be either "ASC" or "DESC"');
				}
			}

			var th = container.closest('th');

			for (var i = 0; i < span.children.length; i += 1) {
				span.children[i].classList.remove('wcdv_sort_arrow_active');
			}
			th.classList.remove('wcdv_sort_column_active');
			th.classList.remove('wcdv_bg-primary');

			if (dir != null) {
				th.classList.add('wcdv_sort_column_active');
				th.classList.add('wcdv_bg-primary');

				// Yes, this is backwards.  The FontAwesome icon for "ascending" points upwards, but I want to
				// color the one that points dowards, indicating that is the direction of increasing values.

				for (var i = 0; i < span.children.length; i += 1) {
					var child = span.children[i];
					child.classList.remove('wcdv_sort_arrow_active');
					if (child.classList.contains('fa-sort-desc')) {
						child.classList.add('wcdv_sort_arrow_' + (dir.toUpperCase() === 'ASC' ? 'active' : 'inactive'));
					}
					if (child.classList.contains('fa-sort-asc')) {
						child.classList.add('wcdv_sort_arrow_' + (dir.toUpperCase() === 'DESC' ? 'active' : 'inactive'));
					}
				}
			}
		};

		/**
		 * Set the sorting for the view to the current orientation/spec, on the specified aggregate number
		 * and in the specified direction.
		 *
		 * @param {string} dir
		 *
		 * @param {number} [aggNum]
		 * If missing, no aggregate number is added to the sort spec.  Used when sorting directly by the
		 * field (e.g. in plain output) or by the group field index (e.g. in group detail output).
		 */

		var setSort = function (dir, aggNum) {
			if (!underscore.isString(dir)) {
				throw new Error('Call Error: `dir` must be a string');
			}
			else if (dir.toUpperCase() !== 'ASC' && dir.toUpperCase() !== 'DESC') {
				throw new Error('Call Error: `dir` must be either "ASC" or "DESC"');
			}

			if (aggNum != null && !underscore.isNumber(aggNum)) {
				throw new Error('Call Error: `aggNum` must be a number');
			}

			jQuery('span.' + sortIcon_orientationClass + '.fa-stack').each(function (i, elt) {
				replaceSortIndicator(elt);
			});

			jQuery('span.' + sortIcon_class).each(function (i, elt) {
				replaceSortIndicator(elt, dir);
			});

			spec.aggNum = aggNum;
			spec.dir = dir;

			var sortSpec = self.view.getSort() || {};
			sortSpec[orientation] = deepCopy(spec);
			self.view.setSort(sortSpec, self.makeProgress('Sort'));
		};

		// Set the sort direction in the arrow icon.  The way we do this is by building a single
		// FontAwesome "stack" from the up and down carets.  Then we can style the one we want.

		var ascArrow = document.createElement('span');
		ascArrow.classList.add('fa');
		ascArrow.classList.add('fa-sort-asc');
		ascArrow.classList.add('fa-stack-1x');

		var descArrow = document.createElement('span');
		descArrow.classList.add('fa');
		descArrow.classList.add('fa-sort-desc');
		descArrow.classList.add('fa-stack-1x');

		var sortIcon_class = gensym();

		var sortIcon_span = fontAwesome('fa-stack', orientation === 'horizontal' ? 'fa-rotate-270' : null).get(0);
		sortIcon_span.classList.add(sortIcon_class);
		sortIcon_span.classList.add(sortIcon_orientationClass);
		sortIcon_span.classList.add('wcdv_sort_icon');
		sortIcon_span.appendChild(ascArrow);
		sortIcon_span.appendChild(descArrow);

		var sortIcon_menu_items = {};

		if (spec.field != null || spec.groupFieldIndex != null || spec.pivotFieldIndex != null) {

			// We're sorting by a field.  This can occur in these situations:
			//
			//   1. Sorting plain output by any column.
			//   2. Sorting group/pivot output by a field that we've grouped by.
			//   3. Sorting pivot output by a field that we've pivotted by.

			var name = spec.field != null
				? spec.field
				: spec.groupFieldIndex != null
				? data.groupFields[spec.groupFieldIndex]
				: spec.pivotFieldIndex != null
				? data.pivotFields[spec.pivotFieldIndex]
				: 'Unknown'
			;

			sortIcon_menu_items[gensym()] = {
				name: name + ', Ascending',
				icon: 'fa-sort-amount-asc',
				callback: function () {
					setSort('asc');
				}
			};
			sortIcon_menu_items[gensym()] = {
				name: name + ', Descending',
				icon: 'fa-sort-amount-desc',
				callback: function () {
					setSort('desc');
				}
			};
			sortIcon_menu_items[gensym()] = '----';
		}
		else {

			// We're sorting by the result of an aggregate function.

			underscore.each(agg, function (aggInfo, aggNum) {
				if (spec.aggType != null && spec.aggNum !== aggNum) {
					return;
				}

				var aggType = aggInfo.instance.getType();
				sortIcon_menu_items[gensym()] = {
					name: aggInfo.instance.getFullName() + ', Ascending',
					icon: 'fa-sort-amount-asc',
					callback: function () {
						setSort('asc', aggNum);
					}
				};
				sortIcon_menu_items[gensym()] = {
					name: aggInfo.instance.getFullName() + ', Descending',
					icon: 'fa-sort-amount-desc',
					callback: function () {
						setSort('desc', aggNum);
					}
				};
				sortIcon_menu_items[gensym()] = '----';
			});
		}

		// Include an option to reset the sort.  This is just as much to fluff up the all-too-common
		// two-entry menu as anything else.

		sortIcon_menu_items.reset = {
			name: 'Reset Sort',
			icon: 'fa-ban',
			callback: function () {
				self.view.clearSort();
			}
		};

		// Create the context menu.
		//
		// TODO The plugin allow the reuse of the menu among multiple targets.  See if we can use that
		// within the grid.
		//
		// TODO Does spawning a bunch of these (i.e. every time the table is redrawn) use a bunch of
		// memory?  Is there a way to destroy the menu to reclaim it?

		var sortIcon_menu = jQuery.contextMenu({
			selector: '.' + sortIcon_class,
			appendTo: self.ui.contextMenus,
			trigger: 'left',
			callback: function (itemKey, opt) {
				console.log(itemKey);
			},
			items: sortIcon_menu_items
		});

		self.contextMenuSelectors.push('.' + sortIcon_class);

		container.appendChild(sortIcon_span);

		// Now check the existing sort specification in the view to see if any of the sort icons that we
		// just created should be lit up.

		var sortSpec_copy = deepCopy(self.view.getSort());
		var spec_copy = deepCopy(spec);

		if (sortSpec_copy[orientation]) {
			var currentDir = sortSpec_copy[orientation].dir;

			// Delete things that would be in the view's spec that aren't in the spec we were provided by
			// the caller (because they're independent of the user interface reflecting the sort).  This way
			// we can just do an object-object comparison to see if what we just made corresponds to the
			// sort that is already set in the view.  Crucially, for grid tables that redraw when the view
			// is updated, this is the only way you're ever going to see what the sort is.

			delete sortSpec_copy[orientation].dir;

			// Note that `aggNum` is an important part of the spec when sorting group or pivot aggregates
			// (i.e. total rows/columns) because they have their own row/column, and aren't thrown together
			// like cell aggregates are.

			if (spec.aggType == null) {
				delete sortSpec_copy[orientation].aggNum;
				delete spec_copy.aggNum;
			}

			//debug.info('GRID TABLE // ADD SORTING', 'orientation = %s ; spec = %O ; current = %O ; dir = %s',
			//	orientation, spec_copy, sortSpec_copy[orientation], currentDir);

			if (underscore.isEqual(sortSpec_copy[orientation], spec_copy)) {
				replaceSortIndicator(sortIcon_span, currentDir);
			}
		}
	};

	// #_addFilterToHeader {{{2

	GridTable.prototype._addFilterToHeader = function (container, field, displayText) {
		var self = this;

		if (self.grid.filterControl == null) {
			return;
		}

		jQuery(fontAwesome('fa-filter', 'wcdv_filter_icon', 'Click to add a filter for "' + field + '"'))
			.on('click', function () {
				self.grid.filterControl.addField(field, displayText, {
					openControls: true
				});
			})
			.tooltip({
				classes: {
					'ui-tooltip': 'ui-corner-all ui-widget-shadow wcdv_info_tooltip wcdv_border-primary'
				},
				show: { delay: 1000 }
			})
			.appendTo(container);
	};

	// #_addDrillDownHandler {{{2

	GridTable.prototype._addDrillDownHandler = function (tbl, data) {
		var self = this;

		tbl.on('mousedown', function (evt) {
			if (evt.detail > 1) {
				evt.preventDefault();
			}
		});
		tbl.on('dblclick', 'td.wcdv_drill_down', function () {
			if (window.getSelection) {
				window.getSelection().removeAllRanges();
			}
			else if (document.selection) {
				document.selection.empty();
			}

			var elt = jQuery(this);
			var filter = deepCopy(self.view.getFilter());
			var rowValIndex = elt.attr('data-rowval-index');
			var colValIndex = elt.attr('data-colval-index');

			if (rowValIndex != null) {
				underscore.each(data.rowVals[rowValIndex], function (x, i) {
					var gs = data.groupSpec[i];
					filter[data.groupFields[i]] = gs.fun != null
						? GROUP_FUNCTION_REGISTRY.get(gs.fun).valueToFilter(x)
						: { '$eq': x };
				});
			}

			if (colValIndex != null) {
				underscore.each(data.colVals[colValIndex], function (x, i) {
					var ps = data.pivotSpec[i];
					filter[data.pivotFields[i]] = ps.fun != null
						? GROUP_FUNCTION_REGISTRY.get(ps.fun).valueToFilter(x)
						: { '$eq': x };
				});
			}

			debug.info('GRID TABLE - PIVOT // DRILL DOWN',
				'Creating new perspective: filter = %O', filter);

			window.setTimeout(function () {
				self.view.prefs.addPerspective(null, 'Drill Down', { view: { filter: filter } }, { isTemporary: true }, null, { onDuplicate: 'replace' });
			});
		});
	};

	// #_addDrillDownClass {{{2

	GridTable.prototype._addDrillDownClass = function (elt) {
		elt.classList.add('wcdv_drill_down');
	};

	// #addSortHandler {{{2

	GridTable.prototype.addSortHandler = function () {
		var self = this;

		// Register the event handler for when a sort occurs in the view.  The way this works is that
		// the view will invoke the callback for each row in order.  We just append them to the table
		// body in that same order, and boom: all the rows are sorted.
		//
		// However, we DON'T want to do this if we're limiting the output because we're currently only
		// showing part of the data.  So, when we sort, we need to completely redraw the window (e.g.
		// rows 21-40) that we're showing.
		//
		// FIXME - This will cause problems with multiple grids (some supporting sorting, some not)
		// using the same view.

		self.view.off('sort');

		if (self.features.sort) {
	//		if (self.features.limit) {
				self.view.on('sortEnd', function () {
					debug.info('GRID TABLE // HANDLER (View.sortEnd)', 'Marking table to be redrawn');
					self.needsRedraw = true;
				}, { who: self });
	//		}
	//		else {
	//			self.view.on('sort', function (rowNum, position) {
	//				var elt = jQuery(document.getElementById(self.defn.table.id + '_' + rowNum));
	//
	//				// Add one to the position (which is 0-based) to match the 1-based row number in CSS.
	//
	//				elt.removeClass('even odd');
	//				elt.addClass((position + 1) % 2 === 0 ? 'even' : 'odd');
	//				self.ui.tbody.append(elt);
	//
	//				self.csv.setOrder(rowNum, position);
	//			}, { who: self });
	//		}
		}
	};

	// #addFilterHandler {{{2

	GridTable.prototype.addFilterHandler = function () {
		var self = this;

		// Register the event handler for when a filter occurs in the view.  The way this works is that
		// the view will invoke the callback for each row and indicate if it should be shown or hidden.
		//
		// However, we DON'T want to do this if we're limiting the output because we're currently only
		// showing part of the data.  So, when we filter, we need to completely redraw the window (e.g.
		// rows 21-40) that we're showing.
		//
		// We also can't use this approach when we're using preferences, because those can cause the data
		// to be filtered down before our grid actually creates all the rows.  (The prefs are applied
		// before the grid table is created.)  At that point, showing or hiding rows is irrelevant because
		// the grid table doesn't event know what the unfiltered ones are, it's only ever seen the data
		// with filters applied.

		self.view.off('filter');

	//	if (self.features.limit || self.view.opts.saveViewConfig) {
			self.view.on(View.events.filterEnd, function () {
				debug.info('GRID TABLE // HANDLER (View.filterEnd)', 'Marking table to be redrawn');
				self.needsRedraw = true;
			}, { who: self });
	//	}
	//	else {
	//		var even = false; // Rows are 1-based to match our CSS zebra-striping.
	//
	//		self.view.on(View.events.filter, function (rowNum, hide) {
	//			if (isNothing(self.ui.tr[rowNum])) {
	//				debug.info('GRID TABLE // HANDLER (View.filter)', 'We were told to ' + (hide ? 'hide' : 'show') + ' row ' + rowNum + ', but it doesn\'t exist');
	//				return;
	//			}
	//
	//			self.ui.tr[rowNum].removeClass('even odd');
	//			if (hide) {
	//				self.ui.tr[rowNum].hide();
	//			}
	//			else {
	//				self.ui.tr[rowNum].show();
	//				self.ui.tr[rowNum].addClass(even ? 'even' : 'odd');
	//				even = !even;
	//			}
	//
	//			self.csv.updateVisibility(rowNum, hide);
	//		}, { who: self });
	//	}
	};

	// #_addRowReorderHandler {{{2

	GridTable.prototype._addRowReorderHandler = function () {
		var self = this;

		self.ui.tbody._makeSortableTable(underscore.bind(self.view.source.swapRows, self.view.source));
	};

	// #_addRowSelectHandler {{{2

	/**
	 * Add an event handler for the row select checkboxes.  The event is bound on `self.ui.tbody` and
	 * looks for checkbox inputs inside TD elements with class `wcdv-row-select-col` to actually handle
	 * the events.  The handler calls `self.select(ROW_NUM)` or `self.unselect(ROW_NUM)` when the
	 * checkbox is changed.
	 */

	GridTable.prototype._addRowSelectHandler = function () {
		var self = this;

		self.ui.tbody.on('change', 'td.wcdv-row-select-col > input[type="checkbox"]', function () {
			if (this.checked) {
				self.select(+(jQuery(this).attr('data-row-num')));
			}
			else {
				self.unselect(+(jQuery(this).attr('data-row-num')));
			}
		});
	};

	// #_getAggInfo {{{2

	GridTable.prototype._getAggInfo = function (data) {
		var ai = objFromArray(['cell', 'group', 'pivot', 'all'], [[]]);
		ai = underscore.mapObject(ai, function (val, key) {
			return underscore.filter(
				getPropDef([], data, 'agg', 'info', key),
				function (aggInfo) {
					return !aggInfo.isHidden;
				}
			);
		});
		return ai;
	};

	// #_setupFullValueWin {{{2

	/**
	 * Setup the behavior to show the full value of a cell when it's been truncated due to having the
	 * `maxHeight` property set in the column config.
	 *
	 * For plain output, you need to set:
	 *
	 *   - `data-row-num` on the TR
	 *   - `data-wcdv-field` on the TD
	 *
	 * For group & pivot output, you need to set:
	 *
	 *   - `data-rowval-index` on the TR (for group & cell aggregates)
	 *   - `data-colval-index` on the TD (for pivot & cell aggregates)
	 *   - `data-wcdv-agg-scope` on the TD
	 *   - `data-wcdv-agg-num` on the TD
	 */

	GridTable.prototype._setupFullValueWin = function (data) {
		var self = this;

		// Create a window that will show the full value of a cell whose display has been truncated by
		// setting the `maxHeight` property in the column configuration.

		var fullValueWinDiv = document.createElement('div');

		var fullValueWinEffect = {
			effect: 'fade',
			duration: 100
		};

		var fullValueWin = jQuery('<div>', { title: 'Full Value' }).dialog({
			autoOpen: false,
			modal: true,
			width: 800,
			maxHeight: 600,
			classes: {
				"ui-dialog": "ui-corner-all wcdv_dialog",
				"ui-dialog-titlebar": "ui-corner-all",
			},
			show: fullValueWinEffect,
			hide: fullValueWinEffect,
		});

		fullValueWin.append(fullValueWinDiv);

		// When the "show full value" button is clicked, use the attached data attributes to determine the
		// value that will be shown in the window.

		self.ui.tbody.on('click', 'button.wcdv_show_full_value', function (evt) {
			evt.stopPropagation();

			var btn = jQuery(this);
			var td = btn.parents('td');
			var tr = td.parents('tr');

			var field
				, rowNum
				, rvi
				, cvi
				, aggScope
				, aggNum
				, aggInfo
				, aggResult
				, val;

			if (data.isPlain) {
				field = td.attr('data-wcdv-field');
				rowNum = +tr.attr('data-row-num');
				val = getProp(data, 'data', rowNum, 'rowData', field, 'cachedRender');
				setElement(fullValueWinDiv, val);
			}
			else if (data.isGroup || data.isPivot) {
				aggScope = td.attr('data-wcdv-agg-scope');
				aggNum = +td.attr('data-wcdv-agg-num');

				switch (aggScope) {
				case 'cell':
					rvi = +tr.attr('data-rowval-index');
					cvi = +td.attr('data-colval-index');
					aggResult = data.agg.results[aggScope][aggNum][rvi][cvi];
					break;
				case 'group':
					rvi = +tr.attr('data-rowval-index');
					aggResult = data.agg.results[aggScope][aggNum][rvi];
					break;
				case 'pivot':
					cvi = +td.attr('data-colval-index');
					aggResult = data.agg.results[aggScope][aggNum][cvi];
					break;
				case 'all':
					aggResult = data.agg.results[aggScope][aggNum];
					break;
				}

				aggInfo = data.agg.info[aggScope][aggNum];
				field = getProp(aggInfo, 'fields', 0);

				if (isElement(aggResult)) {
					setElement(fullValueWinDiv, aggResult);
				}
				else {
					if (aggInfo.instance.inheritFormatting) {
						val = format(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
							overrideType: aggInfo.instance.getType()
						});
						setElement(fullValueWinDiv, val, {
							field: aggInfo.fields[0],
							colConfig: aggInfo.colConfig[0],
							typeInfo: aggInfo.typeInfo[0]
						});
					}
					else {
						val = format(null, null, aggResult, {
							overrideType: aggInfo.instance.getType(),
							convert: false
						});
						setElement(fullValueWinDiv, val);
					}
				}
			}

			fullValueWin.dialog('open');
		});
	};

	// #draw {{{2

	GridTable.prototype.draw = function (root, opts, cont) {
		var self = this;

		return self.super.draw(root, opts, function (ok, data, typeInfo) {
			if (!ok) {
				return cont();
			}

			// Configuration for floating header feature.

			if (!self.features.floatingHeader || self.defn.table.floatingHeader.method !== 'tabletool') {
				root.css({ 'overflow-x': 'auto' });
			}

			// Configuration for limit feature.

			if (self.features.limit && self.defn.table.limit.method === 'more') {
				self.scrollEventElement = self.opts.fixedHeight ? self.root : window;
				jQuery(self.scrollEventElement).on(self.scrollEvents, function () {
					if (typeof self.moreVisibleHandler === 'function') {
						self.moreVisibleHandler();
					}
				});
			}

			self.csv = new Csv();

			self.ui = {
				tbl: jQuery('<table>'),
				thead: jQuery('<thead>'),
				tbody: jQuery('<tbody>'),
				tfoot: jQuery('<tfoot>'),
				thMap: {},
				tr: {},
				progress: jQuery('<div>'),
				contextMenus: jQuery('<div>')
			};

			self._addDrillDownHandler(self.ui.tbl, data);

			if (self.features.block) {
				var blockConfig = {
					overlayCSS: {
						opacity: 0.9,
						backgroundColor: '#FFF'
					}
				};

				if (self.features.progress && getProp(self.defn, 'table', 'progress', 'method') === 'jQueryUI') {
					blockConfig.message = jQuery('<div>')
						.append(jQuery('<h1>').text('Working...'))
						.append(self.ui.progress);
				}
			}

			self.ui.contextMenus.appendTo(document.body);

			self.view.on(View.events.workBegin, function () {
				if (self.features.block) {
					debug.info('GRID TABLE // HANDLER (View.workBegin)', 'Blocking table body');
					if (getProp(self.defn, 'table', 'block', 'wholePage')) {
						jQuery.blockUI(blockConfig);
					}
					else {
						self.ui.tbl.block(blockConfig);
					}
				}
				if (self.features.floatingHeader) {
					switch (getProp(self.defn, 'table', 'floatingHeader', 'method')) {
					case 'tabletool':
						TableTool.update();
						break;
					}
				}
			}, { who: self });

			self.view.on(View.events.workEnd, function () {
				if (self.features.block) {
					debug.info('GRID TABLE // HANDLER (View.workEnd)', 'Unblocking table body');
					if (getProp(self.defn, 'table', 'block', 'wholePage')) {
						jQuery.unblockUI();
					}
					else {
						self.ui.tbl.unblock();
					}
				}
				if (self.features.floatingHeader) {
					switch (getProp(self.defn, 'table', 'floatingHeader', 'method')) {
					case 'tabletool':
						TableTool.update();
						break;
					}
				}
			}, { who: self });

			/*
			 * Determine what columns will be in the table.  This comes from the user, or from the data
			 * itself.  We may then add columns for extra features (like row selection or reordering).
			 */

			var columns = determineColumns(self.colConfig, data, typeInfo);

			self.drawHeader(columns, data, typeInfo, opts);

			if (self.features.footer) {
				self.drawFooter(columns, data, typeInfo);
			}

			self.addSortHandler();

			if (self.features.rowSelect) {
				if (typeof self._addRowSelectHandler !== 'function') {
					log.warn('Requested feature "rowSelect" is not available: `_addRowSelectHandler` method does not exist');
				}
				else {
					self._addRowSelectHandler();
				}
			}

			if (self.features.rowReorder) {
				self._addRowReorderHandler();
			}

			if (self.opts.zebraStriping) {
				self.ui.tbl.addClass('zebra');
			}

			if (getProp(self.opts, 'addClass', 'table')) {
				self.ui.tbl.addClass(getProp(self.opts, 'addClass', 'table'));
			}

			self.ui.tbl.append(self.ui.thead);

			if (self.features.incremental && !getProp(self.defn, 'table', 'incremental', 'appendBodyLast')) {
				self.ui.tbl.append(self.ui.tbody);

				if (self.features.footer) {
					self.ui.tbl.append(self.ui.tfoot);
				}
			}

			// IMPORTANT: We use appendChild() here instead of jQuery's append() because the latter will
			// re-run any <script> elements in the footer, which we don't want.

			self.root.get(0).appendChild(self.ui.tbl.get(0));

			/*
			 * Draw the body.
			 */

			self.drawBody(data, typeInfo, columns, function () {
				if (!self.features.incremental || getProp(self.defn, 'table', 'incremental', 'appendBodyLast')) {
					self.ui.tbl.append(self.ui.tbody);

					if (self.features.footer) {
						self.ui.tbl.append(self.ui.tfoot);
					}
				}

				self.timing.stop(['Grid Table', 'Draw']);
			}, opts);

			// Activate TableTool using this attribute, if the user asked for it.

			if (self.features.floatingHeader) {
				debug.info('GRID TABLE // DRAW', 'Enabling floating header using method "%s"',
					getProp(self.defn, 'table', 'floatingHeader', 'method'));
				switch (getProp(self.defn, 'table', 'floatingHeader', 'method')) {
				case 'floatThead':
					var floatTheadConfig = {
						zIndex: 1
					};

					if (self.opts.fixedHeight) {
						floatTheadConfig.position = 'fixed';
						floatTheadConfig.scrollContainer = true;
					}
					else {
						floatTheadConfig.responsiveContainer = function () {
							return self.root;
						};
					}

					self.grid.on('showControls', function () {
						self.ui.tbl.floatThead('reflow');
					}, { who: self });
					self.grid.on('hideControls', function () {
						self.ui.tbl.floatThead('reflow');
					}, { who: self });
					self.grid.filterControl.on(['fieldAdded', 'fieldRemoved'], function () {
						self.ui.tbl.floatThead('reflow');
					}, { who: self });
					self.grid.aggregateControl.on(['fieldAdded', 'fieldRemoved'], function () {
						self.ui.tbl.floatThead('reflow');
					}, { who: self });

					self.ui.tbl.floatThead(floatTheadConfig);
					break;
				case 'tabletool':
					if (self.opts.fixedHeight) {
						self.ui.tbl.attr('data-tttype', 'fixed');
						self.ui.tbl.attr('data-ttheight', self.grid.rootHeight);
					}
					else {
						self.ui.tbl.attr('data-tttype', 'sticky');
					}
					if (data.isPlain) {
						var pinnedColumns = 0;
						underscore.each(columns, function (field) {
							var fcc = self.colConfig.get(field);
							if (fcc != null && fcc.isPinned) {
								pinnedColumns += 1;
							}
						});
						if (pinnedColumns > 0) {
							if (self.features.rowSelect) {
								pinnedColumns += 1;
							}
							self.ui.tbl.attr('data-tttype', 'sidescroll');
							self.ui.tbl.attr('data-ttsidecells', pinnedColumns);
						}
					}
					else if ((data.isGroup || data.isPivot) && getProp(self.defn, 'table', 'whenGroup', 'pinRowvals')) {
						self.ui.tbl.attr('data-tttype', 'sidescroll');
						self.ui.tbl.attr('data-ttsidecells', data.groupFields.length);
					}
					break;
				}
			}

			// This isn't fast or reliable but it is one way to get rid of excess "show full value" buttons
			// if the cell doesn't actually get cut off.  It's fine for small numbers of cells, but once you
			// get over like 1000 cells it's going to take a while.  Plus, it technically needs to be rerun
			// whenever the table size changes.  I just want to leave it here in case I need it later.

			// jQuery(self.ui.tbody).find('div.wcdv_maxheight_wrapper').each(function (i, elt) {
			// 	var s = window.getComputedStyle(elt);
			// 	var height = s.height.slice(0, -2);
			// 	var maxHeight = s.maxHeight.slice(0, -2);
			// 	if (+height < +maxHeight) {
			// 		jQuery(elt).children('button.wcdv_show_full_value').hide();
			// 	}
			// });

			self.addWorkHandler();

			self.fire('renderEnd');
			self.drawLock.unlock();

			if (typeof cont === 'function') {
				return cont();
			}
		});
	};

	// #drawHeader_aggregates {{{2

	/**
	 * Add TH elements for all the aggregates to the specified TR.
	 *
	 * @param {Object} data
	 *
	 * @param {Element} tr
	 * Where to put the TH elements.
	 */

	GridTable.prototype.drawHeader_aggregates = function (data, tr, displayOrderIndex, displayOrderMax) {
		var self = this;
		var ai = self._getAggInfo(data);

		underscore.each(ai.group, function (aggInfo, aggIndex) {
			var aggNum = aggInfo.aggNum,
				text = aggInfo.instance.getFullName(),
				span = jQuery('<span>')
					.addClass('wcdv_heading_title')
					.text(text),
				headingThControls = jQuery('<div>'),
				headingThContainer = jQuery('<div>')
					.addClass('wcdv_heading_container')
					.append(span, headingThControls),
				th = jQuery('<th>')
					.append(headingThContainer)
					.appendTo(tr);

			if (self.opts.drawInternalBorders || data.agg.info.group.length > 1) {
				if (displayOrderIndex > 0 && aggIndex === 0) {
					th.addClass('wcdv_bld'); // border-left: double
				}
				if (displayOrderIndex < displayOrderMax - 1 && aggIndex === ai.group.length - 1) {
					th.addClass('wcdv_brd'); // border-right: double
				}
				if (aggIndex > 0) {
					th.addClass('wcdv_pivot_colval_boundary');
				}
			}
			self.csv.addCol(text);
			self._addSortingToHeader(data, 'vertical', {aggType: 'group', aggNum: aggNum}, headingThControls.get(0), ai.group);
			self.setAlignment(th, aggInfo.colConfig[0], aggInfo.typeInfo[0], aggInfo.instance.getType());
		});
	};

	// #drawHeader_addCols {{{2

	/**
	 * Add user-defined columns to the header.
	 */

	GridTable.prototype.drawHeader_addCols = function (tr, typeInfo, opts) {
		var self = this;
		var span, th;

		if (self.opts.addCols) {
			underscore.each(self.opts.addCols, function (addCol) {
				span = jQuery('<span>')
					.text(addCol.name);

				th = jQuery('<th>')
					.append(span)
					.appendTo(tr);

				self.csv.addCol(addCol.name);

				// When the added column is an aggregate function over some field, we can use that information
				// to look up the colConfig and typeInfo of the field to determine the alignment.  For example
				// if the aggregate is Max(Age) we can look up Age and find it's a number and therefore should
				// be right-aligned.
				//
				// TODO Implement this for the aggregate type as well, as aggregates like Sum() only produce
				// numbers which should be right-aligned.

				if (getProp(opts, 'pivotConfig', 'aggField')) {
					self.setAlignment(th, self.colConfig.get(opts.pivotConfig.aggField), typeInfo.get(opts.pivotConfig.aggField));
				}
			});
		}
	};

	// #drawBody_rowVals {{{2

	/**
	 * Draw the rowvals from a single group.  For example, if grouping by "State" and "County", group
	 * number 0 might be the rowval `["Alabama", "Autauga"]` — and that's what this function would put
	 * out as TH elements.
	 *
	 * @param {object} data
	 *
	 * @param {Element} tr
	 * The row to attach the TH elements to.
	 *
	 * @param {number} rowValIndex
	 * What group number you want to print out.
	 */

	GridTable.prototype.drawBody_rowVals = function (data, tr, rowValIndex) {
		var self = this;

		if (!(tr instanceof Element)) {
			throw new Error('Call Error: `tr` must be an instance of Element');
		}

		if (typeof rowValIndex !== 'number') {
			throw new Error('Call Error: `rowValIndex` must be a number');
		}

		// Create the cells that show the values of the grouped columns.
		//
		// EXAMPLE
		// -------
		//
		//   groupFields = ["First Name", "Last Name"]
		//   rowVals = [["Luke", "Skywalker"], ...]
		//
		// <tr>
		//   <th>Luke</th>
		//   <th>Skywalker</th>
		//   ... row[col] | col ∉ groupFields ...
		// </tr>

		var leafMetadataNode = data.groupMetadata.lookup.byRowValIndex[rowValIndex];
		var metadataNode = leafMetadataNode;
		var th = [];
		var i;

		// Iterate through the group fields from last to first, navigating through the group metadata tree
		// from leaf (last group field) to root (first group field).  Along the way, construct the <TH>
		// elements for the rowval elements in reverse order.

		for (i = data.groupFields.length - 1; i >= 0; i -= 1) {
			var groupField = data.groupFields[i];
			var groupSpec = data.groupSpec[i];
			var fcc = self.colConfig.get(groupField) || {};
			var t = self.typeInfo.get(groupField);
			var v = metadataNode.rowValCell || metadataNode.rowValElt;

			if (groupSpec.fun != null) {
				t = {
					type: GROUP_FUNCTION_REGISTRY.get(groupSpec.fun).resultType
				};
				v = metadataNode.rowValElt;
			}

			// The rowValCell is a representative cell that matches the rowValElt.  If there is more than
			// one rowVal containing the same rowValElt, the rowValCell is shared between them all.  It's
			// the same representative cell.  Because it's shared, we need to enable `saferCaching` so any
			// Element produced by a `render` function on the cell doesn't get reused and moved around on
			// the page.  A good example of this issue can be seen in the allowHtml tests, on the link3 and
			// link4 fields which use a `render` function to create an <A> element.
			//
			// After more difficulty was discovered, `saferCaching` was turned on by default.  This will
			// have some performance impacts, but until a different way is found to implement this, it's
			// necessary.

			v = format(fcc, t, v);

			// TH (th[i])
			//   DIV (headingThContainer)
			//     SPAN (headingThValue)
			//     DIV (headingThControls)

			var headingThValue = document.createElement('span');
			headingThValue.classList.add('wcdv_heading_title');

			var headingThControls = document.createElement('div');

			var headingThContainer = document.createElement('div');
			headingThContainer.classList.add('wcdv_heading_container');
			headingThContainer.appendChild(headingThValue);
			headingThContainer.appendChild(headingThControls);

			th[i] = document.createElement('th');
			th[i].appendChild(headingThContainer);

			if (v instanceof jQuery) {
				v = v.get(0);
			}

			if (v instanceof Element) {
				headingThValue.appendChild(v);
			}
			else if (fcc.allowHtml) {
				headingThValue.innerHTML = v;
			}
			else {
				headingThValue.innerText = v;
			}

			self.csv.addCol(headingThValue.innerText, {
				prepend: true
			});

			if (data.isPivot && i === data.groupFields.length - 1) {
				self._addSortingToHeader(data, 'horizontal', {rowVal: data.rowVals[rowValIndex], aggNum: 0}, headingThControls, getPropDef([], data, 'agg', 'info', 'cell'));
			}

			metadataNode = metadataNode.parent;
		}

		for (i = 0; i < data.groupFields.length; i += 1) {
			tr.appendChild(th[i]);
		}
	};

	// #drawBody_groupAggregates {{{2

	/**
	 * Render the group aggregate results in a row.
	 *
	 * @param {any} data
	 *
	 * @param {Element} tr
	 * Row to which we add the group aggregate results.
	 *
	 * @param {number} groupNum
	 * Group number (a.k.a. the rowVal index) to render the aggregate results for.
	 *
	 * @param {number} displayOrderIndex
	 * What position we're rendering the group aggregate results in.  When greater than zero, draw a
	 * left border.
	 *
	 * @param {number} displayOrderMax
	 * The max number of positions for rendering data.  When this isn't the last thing rendered, draw a
	 * right border.
	 */

	GridTable.prototype.drawBody_groupAggregates = function (data, tr, groupNum, displayOrderIndex, displayOrderMax) {
		var self = this;
		var ai = self._getAggInfo(data);

		// Go through all the group aggregates and create columns for each one in the specified row.

		underscore.each(ai.group, function (aggInfo, aggGroupIndex) {
			var aggNum = aggInfo.aggNum;
			var aggType = aggInfo.instance.getType();
			var aggResult = data.agg.results.group[aggNum][groupNum];
			var text;

			var td = document.createElement('td');
			td.setAttribute('data-rowval-index', groupNum);
			td.setAttribute('data-wcdv-agg-scope', 'group');
			td.setAttribute('data-wcdv-agg-num', aggNum);

			if (aggResult instanceof jQuery) {
				aggResult = aggResult.get(0);
			}

			if (aggResult instanceof Element) {
				td.appendChild(aggResult);
				self.csv.addCol(getElement(aggResult).innerText);
			}
			else {
				if (aggInfo.instance.inheritFormatting) {
					text = format(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
						overrideType: aggType
					});
					setTableCell(td, text, {
						field: aggInfo.fields[0],
						colConfig: aggInfo.colConfig[0],
						typeInfo: aggInfo.typeInfo[0]
					});
					td.setAttribute('data-wcdv-field', aggInfo.fields[0]);
				}
				else {
					text = format(null, null, aggResult, {
						overrideType: aggType,
						convert: false
					});
					setTableCell(td, text);
				}
				self.csv.addCol(td.innerText);
			}

			// Allow drilldown, but only when there's no group function set.  This limitation is currently
			// in place because we lack the ability to set filters that match all group functions' results.
			// For example, day of week, because we can't filter to show "only Mondays."

			if (underscore.every(data.groupSpec, function (gs) {
				return gs.fun == null || GROUP_FUNCTION_REGISTRY.get(gs.fun).canFilter
			})) {
				self._addDrillDownClass(td);
			}

			// Decide how we should draw borders based on the display order index & max.

			if (self.opts.drawInternalBorders || data.agg.info.group.length > 1) {
				if (displayOrderIndex > 0 && aggGroupIndex === 0) {
					td.classList.add('wcdv_bld'); // border-left: double
				}
				if (displayOrderIndex < displayOrderMax - 1 && aggGroupIndex === ai.group.length - 1) {
					td.classList.add('wcdv_brd'); // border-right: double
				}
				if (aggGroupIndex > 0) {
					td.classList.add('wcdv_pivot_colval_boundary');
				}
			}

			self.setAlignment(td, aggInfo.colConfig[0], aggInfo.typeInfo[0], aggInfo.instance.getType());
			tr.appendChild(td);
		});
	};

	// #clear {{{2

	/**
	 * Remove the table from page.
	 */

	GridTable.prototype.clear = function () {
		var self = this;

		if (getProp(self, 'ui', 'contextMenus') != null) {
			self.ui.contextMenus.remove();
		}

		debug.info('GRID TABLE // CLEAR', 'Removing %d context menus', self.contextMenuSelectors.length);

		underscore.each(self.contextMenuSelectors, function (sel) {
			jQuery.contextMenu('destroy', sel);
		});

		self.contextMenuSelectors = [];

		if (self.features.limit && self.defn.table.limit.method === 'more') {
			jQuery(self.scrollEventElement).off(self.scrollEvents);
		}

		// Remove the event handler from clicking on the "show full value" buttons.

		if (getProp(self, 'ui', 'tbody') != null) {
			self.ui.tbody.off('click', 'button.wcdv_show_full_value');
		}

		self.view.off('*', self, {silent: true});

		if (self.opts.footer != null && self.opts.stealGridFooter) {
			self.grid.ui.content.get(0).appendChild(self.opts.footer.get(0));
		}

		self.root.children().remove();
	};

	// #makeProgress {{{2

	GridTable.prototype.makeProgress = function (thing) {
		var self = this;

		if (!self.features.progress) {
			return;
		}

		if (getProp(self.defn, 'table', 'progress', 'method') === 'NProgress') {
			return {
				begin: function () {
					debug.info('GRID TABLE - PLAIN // PROGRESS (' + thing + ')', 'Begin');
					if (window.NProgress !== undefined) {
						window.NProgress.start();
					}
				},
				update: function (amount, estTotal) {
					debug.info('GRID TABLE - PLAIN // PROGRESS (' + thing + ')', sprintf$1.sprintf('Update: %d / %d = %.0f%%', amount, estTotal, (amount / estTotal) * 100));
					if (window.NProgress !== undefined) {
						window.NProgress.set(amount / estTotal);
					}
				},
				end: function () {
					debug.info('GRID TABLE - PLAIN // PROGRESS (' + thing + ')', 'End');
					if (window.NProgress !== undefined) {
						window.NProgress.done();
						jQuery('.nprogress-custom-parent').removeClass('nprogress-custom-parent');
					}
				}
			};
		}
		else if (getProp(self.defn, 'table', 'progress', 'method') === 'jQueryUI') {
			return {
				begin: function () {
					debug.info('GRID TABLE - PLAIN // PROGRESS (' + thing + ')', 'Begin');
					self.ui.progress.progressbar({
						'classes': {
							'ui-progressbar': 'wcdvgrid_progressbar',
							'ui-progressbar-value': 'wcdvgrid_progressbar'
						}
					});
				},
				update: function (amount, estTotal) {
					debug.info('GRID TABLE - PLAIN // PROGRESS (' + thing + ')', sprintf$1.sprintf('Update: %d / %d = %.0f%%', amount, estTotal, (amount / estTotal) * 100));
					self.ui.progress.progressbar('value', (amount / estTotal) * 100);
				},
				end: function () {
					debug.info('GRID TABLE // PROGRESS (' + thing + ')', 'End');
					self.ui.progress.progressbar('destroy');
				}
			};
		}
	};

	// #getCsv {{{2

	GridTable.prototype.getCsv = function () {
		var self = this;

		return self.csv.toString();
	};

	// #getSelection {{{2

	/**
	 * Get the currently selected rows.
	 *
	 * @return {object}
	 * Information on what rows are selected.  Contains the following properties:
	 *
	 * - `rowIds` — An array of the unique IDs of the selected rows.  Probably not that useful to you,
	 *   but it's available.
	 *
	 * - `rows` — An array of the data represented by each row.  Each row is an object, each key in the
	 *   object is a field in the source data.  Values are references to the actual data used by the
	 *   grid, so don't mess with their internal structures.
	 *
	 * The ordering of the results is not guaranteed to have any relationship to the order of the rows
	 * from the source, or the order in which they were checked.
	 */

	GridTable.prototype.getSelection = function () {
		var self = this;

		return {
			rowIds: self.selection,
			rows: underscore.map(self.selection, function (rowId) {
				return self.data.dataByRowId[rowId];
			})
		};
	};

	// #setSelection {{{2

	/**
	 * Set the currently selected rows.  This is different from {@link GridTable#select} and {@link
	 * GridTable#unselect} because this straight-up sets the selection (the other methods add to and
	 * remove from the selection).
	 *
	 * @param {number[]} [what]
	 * Set the selection to the specified row IDs, or select nothing if not specified.
	 */

	GridTable.prototype.setSelection = function (what) {
		var self = this;
		var data = self.data.data;

		if (self.data.isGroup) {
			data = underscore.flatten(data);
		}
		else if (self.data.isPivot) {
			log.error('Selection is not supported for pivotted data, because there is no way to see or change the selection in the user interface');
			return;
		}

		if (what == null) {
			self.selection = [];
		}
		else if (underscore.isArray(what)) {
			self.selection = what;
		}
		else {
			log.error('GridTable#setSelection(): parameter `what` must be null/undef or an array');
			return false;
		}

		// Try to reflect these changes in the user interface.

		if (typeof self._updateSelectionGui === 'function') {
			self._updateSelectionGui();
		}

		self.fire('selectionChange', null, self.getSelection().rows);
	};

	// #select {{{2

	/**
	 * Adds to the current selection.
	 *
	 * To add all rows where the field "Model" is Civic, Fit, or Accord:
	 *
	 * ```
	 * grid.select((row) => { ['Civic', 'Fit', 'Accord'].indexOf(row['Model'].value) >= 0 });
	 * ```
	 *
	 * @param {number|number[]|function} [what]
	 * Behaves as follows:
	 *
	 * - When not specified, adds all rows to the selection.
	 * - When a number or array of numbers, adds all those row IDs to the selection.
	 * - When a function, adds all rows that pass that filter to the selection.
	 */

	GridTable.prototype.select = function (what) {
		var self = this;
		var data = self.data.data;

		if (self.data.isGroup) {
			data = underscore.flatten(data);
		}
		else if (self.data.isPivot) {
			log.error('Selection is not supported for pivotted data, because there is no way to see or change the selection in the user interface');
			return;
		}

		if (what == null) {
			// Select all.
			self.selection = underscore.pluck(data, 'rowNum');
		}
		else if (underscore.isArray(what)) {
			// Add elements to the selection.
			self.selection = underscore.union(self.selection, what);
		}
		else if (typeof what === 'function') {
			// Add passing rows to the selection.
			var passing = underscore.filter(data, function (d) {
				return what(d.rowData);
			});
			self.selection = underscore.union(self.selection, underscore.pluck(passing, 'rowNum'));
		}
		else if (!underscore.contains(self.selection, what)) {
			// Add item to ths selection.
			self.selection.push(what);
		}

		// Try to reflect these changes in the user interface.

		if (typeof self._updateSelectionGui === 'function') {
			self._updateSelectionGui();
		}

		self.fire('selectionChange', null, self.getSelection().rows);
	};

	// #unselect {{{2

	/**
	 * Removes from the current selection.
	 *
	 * To remove all rows where the field "Make" is Honda:
	 *
	 * ```
	 * grid.unselect((row) => { row['Make'].value === 'Honda' });
	 * ```
	 *
	 * @param {number|number[]|function} [what]
	 * Behaves as follows:
	 *
	 * - When not specified, removes all rows from the selection.
	 * - When a number or array of numbers, removes all those row IDs from the selection.
	 * - When a function, removes all rows that pass that filter from the selection.
	 */

	GridTable.prototype.unselect = function (what) {
		var self = this;
		var data = self.data.data;

		if (self.data.isGroup) {
			data = underscore.flatten(data);
		}
		else if (self.data.isPivot) {
			log.error('Selection is not supported for pivotted data, because there is no way to see or change the selection in the user interface');
			return;
		}

		if (what == null) {
			// Unselect all.
			self.selection = [];
		}
		else if (underscore.isArray(what)) {
			// Remove elements from the selection.
			self.selection = underscore.difference(self.selection, what);
		}
		else if (typeof what === 'function') {
			// Remove passing elements from the selection.
			self.selection = underscore.reject(self.selection, function (x) {
				return what(self.data.dataByRowId[x]);
			});
		}
		else {
			// Remove item from the selection.
			self.selection = underscore.without(self.selection, what);
		}

		// Try to reflect these changes in the user interface.

		if (typeof self._updateSelectionGui === 'function') {
			self._updateSelectionGui();
		}

		self.fire('selectionChange', null, self.getSelection().rows);
	};

	// #isSelected {{{2

	/**
	 * Tells if a row is selected.
	 *
	 * @param {number} what
	 * Row ID to check.
	 *
	 * @return {boolean}
	 * True if the row is selected, false if it isn't.
	 */

	GridTable.prototype.isSelected = function (what) {
		var self = this;

		return self.selection.indexOf(what) >= 0;
	};

	// #_updateSelectionGui {{{2

	GridTable.prototype._updateSelectionGui = function () {
		log.error('GridTable#_updateSelectionGui(): Must be implemented by subclass');
	};

	// GridTablePlain {{{1
	// Constructor {{{2

	/**
	 * The GridTablePlain is in charge of displaying the HTML table of data.
	 *
	 * @class
	 * @extends GridTable
	 *
	 * @property {Grid~Features} features
	 *
	 * @property {object} defn
	 *
	 * @property {View} view
	 *
	 * @property {Element} root
	 *
	 * @property {object} colConfig Map associating field name with the configuration of the
	 * corresponding column in this grid table.
	 *
	 * @property {Timing} timing
	 *
	 * @property {boolean} needsRedraw True if the grid needs to redraw itself when the view is done
	 * working.
	 */

	var GridTablePlain = makeSubclass('GridTablePlain', GridTable, function (grid, defn, view, features, opts, timing, id) {
		var self = this;

		self.super.ctor.apply(self, arguments);

		self.features.filter = false;

		debug.info('GRID TABLE - PLAIN', 'Constructing grid table; features = %O', features);

		self.addFilterHandler();
	});

	// #canRender {{{2

	/**
	 * Responds whether or not this grid table can render the type of data requested.
	 *
	 * @param {string} what
	 * The kind of data the caller wants us to show.  Must be one of: plain, group, or pivot.
	 *
	 * @return {boolean}
	 * True if this grid table can render that kind of data, false if it can't.
	 */

	GridTablePlain.prototype.canRender = function (what) {
		switch (what) {
		case 'plain':
			return true;
		case 'group':
		case 'pivot':
			return false;
		}
	};

	// #drawHeader {{{2

	/**
	 * Render the header columns of a GridTablePlain.
	 *
	 * @param {Array.<string>} columns A list of the fields that are to be included as columns within
	 * the GridTablePlain.
	 *
	 * @param {View~Data} data
	 *
	 * @param {Source~TypeInfo} typeInfo
	 *
	 * @param {object} opts
	 */

	GridTablePlain.prototype.drawHeader = function (columns, data, typeInfo, opts) {
		var self = this;

		var headingTr, headingTh, filterTr;

		var headingThCss = {
			'white-space': 'nowrap'
		};

		var filterThCss = {
			'white-space': 'nowrap',
			'padding-top': 4,
			'vertical-align': 'top'
		};

		headingTr = jQuery('<tr>');
		filterTr = jQuery('<tr>', {
			'class': 'wcdv_grid_filterrow'
		});

		self.csv.addRow();

		/*
		 * Create the checkbox that allows the user to select all rows.
		 */

		if (self.features.rowSelect) {
			self.ui.checkAll_thead = jQuery('<input>', { 'name': 'checkAll', 'type': 'checkbox' })
				.on('change', function (evt) {
					self.checkAll(evt);
				});

			headingTh = jQuery('<th>')
				.addClass('wcdv_group_col_spacer')
				.append(self.ui.checkAll_thead)
				.appendTo(headingTr);
			if (self.opts.drawInternalBorders) {
				headingTh.addClass('wcdv_pivot_colval_boundary');
			}

			if (self.features.filter) {
				filterTr.append(jQuery('<th>').css(filterThCss));
			}
		}

		var progress = self.makeProgress('Filter');

		/*
		 * Set up the GridFilterSet instance that manages the (potentially multiple) filters on each
		 * column of the View that belongs to this GridTablePlain.
		 */

		if (self.features.filter) {
			self.defn.gridFilterSet = new GridFilterSet(self.view, null, self, progress);
		}

		/*
		 * Configure every column which comes from the data (i.e. not the "select all" checkbox, and not
		 * the editing "options" column).
		 */

		underscore.each(columns, function (field, colIndex) {
			var fcc = self.colConfig.get(field) || {};

			if (self.features.rowSelect) {
				colIndex += 1; // Add a column for the row selection checkbox.
			}

			var headingText = fcc.displayText || field;

			// headingTh <TH>
			//   headingThContainer <DIV>
			//     headingThSpan <SPAN>
			//     headingThControls <DIV>

			var headingSpan = jQuery('<span>', {
				'class': 'wcdv_heading_title',
				'data-wcdv-field': field,
				'data-wcdv-draggable-origin': 'GRID_TABLE_HEADER',
			})
				.text(headingText)
				._makeDraggableField();

			self.csv.addCol(headingText);

			var headingThControls = jQuery('<div>');

			var headingThContainer = jQuery('<div>')
				.addClass('wcdv_heading_container')
				.append(headingSpan, headingThControls);

			var headingTh = jQuery('<th>', { id: gensym() })
				.css(headingThCss)
				.append(headingThContainer);

			// In the plain grid table output, the only way to sort is vertically by field.

			self._addSortingToHeader(data, 'vertical', {field: field}, headingThControls.get(0));

			self._addFilterToHeader(headingThControls, field, headingText);


			if (self.opts.drawInternalBorders) {
				headingTh.addClass('wcdv_pivot_colval_boundary');
			}

			/*
			 * Configure filtering for this column.  This mainly involves creating a button, which when
			 * clicked adds (for this column) a filter to the GridFilterSet instance.
			 */

			if (self.features.filter) {

				// Add a TH to the TR that will contain the filters.  Every filter will actually be a DIV
				// inside this TH.
				//
				// The ID attribute here is used to provide a selector to NProgress, so the progress bar
				// will be drawn in the header cell for the column we're filtering by.  You can't pass an
				// element to NProgress for this, it needs to be a selector string.  Passing ('#' + id) was
				// the easiest way to do it.
				//
				// Unfortunately, the ID attribute is copied when using TableTool so this might mess us up.

				var filterThId = gensym();
				var filterTh = jQuery('<th>', { id: filterThId }).addClass('wcdv_grid_filtercol filter_col_' + colIndex).css(filterThCss);
				self.setCss(filterTh, field);
				filterTr.append(filterTh);

				// Create the "button" (really a SPAN) that will add the filter to the grid, and stick it
				// onto the end of the column heading TH.

				jQuery(fontAwesome('F0B0', null, 'Click to add a filter on this column'))
					.css({'cursor': 'pointer', 'margin-left': '0.5ex'})
					.on('click', function () {
						// When using TableTool, we need to put the filter UI into the floating (clone) header,
						// instead of the original (variable `filterTh` holds the original).  This jQuery will
						// always do the right thing.

						var thead = jQuery(this).closest('thead');
						var tr = thead.children('tr:eq(1)');
						var th = tr.children('th.filter_col_' + colIndex);

						var adjustTableToolHeight = function () {
							if (self.features.floatingHeader) {
								// Update the height of the original, non-floating header to be the same as that of
								// the floating header.  This is needed because otherwise the floating header will
								// cover up the first rows of the table body as we add filters.  TableTool does not
								// keep the heights of the original and clone in sync on its own (using the `update`
								// function only synchronizes the widths).

								var trHeight = tr.innerHeight();

								debug.info('GRID TABLE - PLAIN // ADD FILTER', 'Adjusting original table header height to ' + trHeight + 'px to match floating header height');
								filterTr.innerHeight(trHeight);
							}
						};

						var onRemove = adjustTableToolHeight;

						self.defn.gridFilterSet.add(field, th, {
							filterType: fcc.filter,
							filterButton: jQuery(this),
							makeRemoveButton: true,
							onRemove: onRemove,
							autoUpdateInputWidth: true,
							sizingElement: filterTh
						});

						adjustTableToolHeight();
					})
					.appendTo(headingTh);
			}

			self.setCss(headingTh, field);
			self.setAlignment(headingTh, fcc, typeInfo.get(field));

			self.ui.thMap[field] = headingTh;
			headingTr.append(headingTh);
		});

		if (self.opts.addCols) {
			self.drawHeader_addCols(headingTr, typeInfo, opts);
		}

		/*
		 * Create a column with buttons that allows the user to reorder the rows.
		 */

		if (self.features.rowReorder) {
			headingTh = jQuery('<th>')
				.text('Options')
				.appendTo(headingTr);
			if (self.opts.drawInternalBorders) {
				headingTh.addClass('wcdv_pivot_colval_boundary');
			}

			if (self.features.filter) {
				headingTh = jQuery('<th>').css(filterThCss).appendTo(filterTr);
				if (self.opts.drawInternalBorders) {
					headingTh.addClass('wcdv_pivot_colval_boundary');
				}
			}
		}

		self.ui.thead.append(headingTr);

		if (self.features.filter) {
			self.ui.thead.append(filterTr);
		}
	};

	// #drawBody {{{2

	GridTablePlain.prototype.drawBody = function (data, typeInfo, columns, cont, opts) {
		var self = this;
		var useLimit = self.features.limit;
		var limitConfig = getPropDef({}, self.defn, 'table', 'limit');

		if (self.features.limit && limitConfig && data.data.length > limitConfig.threshold) {
			debug.info('GRID TABLE - PLAIN // DRAW', 'Limiting output to first ' + limitConfig.threshold + ' rows');
		}

		if (self.opts.generateCsv) {
			self.addDataToCsv(data);
		}

		// Clear out the body of the table.  We do this in case somebody invokes this function multiple
		// times.  This function draws the entirety of the data, we certainly don't want to just tack rows
		// on to the end.

		self.ui.tbody.children().remove();

		self._setupFullValueWin(data);

		var renderDataRow = function (row) {
			var tr, td;

			tr = document.createElement('tr');
			tr.setAttribute('id', self.defn.table.id + '_' + row.rowNum);
			tr.setAttribute('data-row-num', row.rowNum);

			// Create the check box which selects the row.

			if (self.features.rowSelect) {
				var checkbox = jQuery('<input>', {
					'type': 'checkbox',
					'data-row-num': row.rowNum,
				});
				td = jQuery('<td>').addClass('wcdv_group_col_spacer').append(checkbox).appendTo(tr);
				if (self.opts.drawInternalBorders) {
					td.addClass('wcdv_pivot_colval_boundary');
				}
			}

			// Create the data cells.

			underscore.each(columns, function (field, colIndex) {
				var fcc = self.colConfig.get(field) || {};
				var cell = row.rowData[field];

				var td = document.createElement('td');
				var value = format(fcc, typeInfo.get(field), cell);

				setTableCell(td, value, {
					field: field,
					colConfig: self.colConfig,
					typeInfo: typeInfo
				});

				if (fcc.maxHeight != null) {
					td.setAttribute('data-wcdv-field', field);
				}

				self.setCss(jQuery(td), field);
				self.setAlignment(td, fcc, typeInfo.get(field));

				if (self.opts.drawInternalBorders) {
					td.classList.add('wcdv_pivot_colval_boundary');
				}

				tr.appendChild(td);
			});

			if (self.opts.addCols) {
				underscore.each(self.opts.addCols, function (addColSpec) {
					var value = addColSpec.value(row.rowData, row.rowNum);
					var td = document.createElement('td');

					if (!(value instanceof jQuery || value instanceof Element)) {
						value = format(null, null, value);
					}

					setTableCell(td, value);

					if (self.opts.drawInternalBorders) {
						td.classList.add('wcdv_pivot_colval_boundary');
					}

					tr.appendChild(td);
				});
			}

			// Create button used as the "handle" for dragging/dropping rows.

			if (self.features.rowReorder) {
				jQuery('<td>').append(self.makeRowReorderBtn()).appendTo(tr);
			}

			self.ui.tr[row.rowNum] = jQuery(tr);
			self.ui.tbody.append(tr);
		};

		var renderShowMore = function (rowNum) {
			var tr;

			tr = document.createElement('tr');
			tr.classList.add('wcdvgrid_more');

			var colSpan = columns.length
				+ (self.features.rowSelect ? 1 : 0)
				+ (getPropDef(0, self.opts, 'addCols', 'length'))
				+ (self.features.rowReorder ? 1 : 0);

			var showMore = function () {
				tr.parentNode.removeChild(tr); // Eliminate the "more" row.
				render(rowNum + 1, limitConfig.chunkSize, nextChunk);
			};

			var td = jQuery('<td>', {
				colspan: colSpan
			})
				.on('click', showMore)
				.append(fontAwesome('F13A'))
				.append(jQuery('<span>Showing rows '
												+ '1–'
												+ (rowNum + 1)
												+ ' of '
												+ data.data.length
												+ '.</span>')
									.css({
									'padding-left': '0.5em',
								}))
				.append(jQuery('<span>Click to load ' + limitConfig.chunkSize + ' more rows.</span>')
								.css({
									'padding-left': '0.5em',
									'padding-right': '0.5em'
								}))
				.append(fontAwesome('F13A'));

			self.moreVisibleHandler = onVisibilityChange(self.scrollEventElement, td, function(isVisible) {
				if (isVisible && getProp(self.defn, 'table', 'limit', 'autoShowMore')) {
					debug.info('GRID TABLE - PLAIN // MORE', '"Show More Rows" button scrolled into view');
					showMore();
				}
			});

			tr.appendChild(td.get(0));
			self.ui.tbody.append(tr);
		};

		var render = function (startIndex, howMany, nextChunk) {
			var atLimit = false;

			if (startIndex == null) {
				startIndex = 0;
			}

			if (howMany == null) {
				howMany = data.data.length;
			}

			debug.info('GRID TABLE - PLAIN // DRAW', 'Rendering rows '
				+ startIndex
				+ ' - '
				+ Math.min(useLimit && startIndex === 0 ? limitConfig.threshold - 1 : Number.POSITIVE_INFINITY
					, startIndex + howMany - 1
					, data.data.length - 1)
					+ ' '
					+ (data.data.length - 1 <= startIndex + howMany - 1
						? '[END]'
						: ('/ ' + data.data.length - 1)));

			for (var rowNum = startIndex; rowNum < data.data.length && rowNum < startIndex + howMany && !atLimit; rowNum += 1) {
				renderDataRow(data.data[rowNum]);

				if (!self.features.incremental
						&& useLimit
						&& limitConfig.method === 'more'
						&& rowNum !== data.data.length - 1 // [0]
						&& ((startIndex === 0 && rowNum === limitConfig.threshold - 1) // [1]
								|| (startIndex > 0 && rowNum === startIndex + limitConfig.chunkSize - 1))) { // [2]

					// Condition [0]: We haven't reached the end of the data.
					// Condition [1]: We've reached the initial threshold for showing the more button.
					// Condition [2]: We're showing additional rows because they clicked the more button.

					renderShowMore(rowNum);
					atLimit = true;
				}
			}

			if (atLimit) {
				self.fire('limited');
			}
			else {
				self.fire('unlimited');
			}

			self._updateSelectionGui();

			if (self.features.floatingHeader) {
				switch (getProp(self.defn, 'table', 'floatingHeader', 'method')) {
				case 'tabletool':
					TableTool.update();
					break;
				}
			}

			if (rowNum === data.data.length) {
				// All rows have been produced, so we're done!

				delete self.moreVisibleHandler;

				//self.ui.tbl.css({'table-layout': 'auto'}); // XXX - Does nothing?!

				if (typeof cont === 'function') {
					return cont();
				}

				// Nothing to do next, but we're done here.

				return;
			}
			else if (typeof nextChunk === 'function') {
				return nextChunk(startIndex, howMany);
			}

			if (typeof cont === 'function') {
				return cont();
			}

			// Nothing to do next, but we're done here.

			return;
		};

		var nextChunk;

		if (self.features.incremental) {
			var incrementalConfig = self.defn.table.incremental;
			if (incrementalConfig.method === 'setTimeout') {
				nextChunk = function (startIndex, howMany) {
					window.setTimeout(function () {
						render(startIndex + howMany, howMany, nextChunk);
					}, incrementalConfig.delay);
				};

				// Kick off the initial render starting at index 0.

				window.setTimeout(function () {
					render(0, incrementalConfig.chunkSize, nextChunk);
				}, incrementalConfig.delay);
			}
			else if (incrementalConfig.method === 'requestAnimationFrame') {
				nextChunk = function (startIndex, howMany) {
					window.requestAnimationFrame(function () {
						render(startIndex + howMany, howMany, nextChunk);
					});
				};

				// Kick off the initial render starting at index 0.

				window.requestAnimationFrame(function () {
					render(0, incrementalConfig.chunkSize, nextChunk);
				});
			}
			else {
				throw new GridTablePlainError('Invalid value for `table.incremental.method` (' + incrementalConfig.method + ') - must be either "setTimeout" or "requestAnimationFrame"');
			}
		}
		else {
			render();
		}

		//self.ui.tbl.css({'table-layout': 'fixed'}); // XXX - Does nothing?!
	};

	// #drawFooter {{{2

	GridTablePlain.prototype.drawFooter = function (columns, data, typeInfo) {
		var self = this;

		var makeSelectAll = function (tr) {
			self.ui.checkAll_tfoot = jQuery('<input>', { 'name': 'checkAll', 'type': 'checkbox' })
				.on('change', function (evt) {
					self.checkAll(evt);
				});
			jQuery('<td>', {'class': 'wcdv_group_col_spacer'}).append(self.ui.checkAll_tfoot).appendTo(tr);
		};

		var makeAggregateRow = function () {

			var tr = jQuery('<tr>');

			// Add the "select all" checkbox when row selection is enabled.

			if (self.features.rowSelect) {
				makeSelectAll(tr);
			}

			// Create the columns for the data fields, which contain aggregate function results over those
			// fields.

			var didFooterCell = false;

			tr.append(underscore.map(columns, function (field, colIndex) {
				var fcc = self.colConfig.get(field) || {};
				var colTypeInfo = typeInfo.get(field);
				var td = jQuery('<td>');
				var footerConfig = getProp(self.defn, 'table', 'footer', field);
				var aggResult;
				var footerVal;

				self.setCss(td, field);
				self.setAlignment(td, fcc, typeInfo.get(field));

				if (footerConfig == null) {
					if (didFooterCell) {
						td.addClass('wcdv_divider');
					}

					didFooterCell = false;
				}
				else {
					if (colIndex > 0) {
						td.addClass('wcdv_divider');
					}

					didFooterCell = true;

					// Although the footer config is an aggregate spec, there is one place we allow more
					// flexibility.  If the fields aren't set, use the field for the column in which we're
					// displaying this footer.  This is merely a convenience for the most common case.

					if (footerConfig.fields == null) {
						footerConfig.fields = [field];
					}

					debug.info('GRID TABLE - PLAIN // FOOTER - ' + field, 'Creating footer using config: %O', footerConfig);

					var aggInfo = new AggregateInfo('all', footerConfig, 0, self.colConfig, typeInfo, function (tag, fti) {
						if (fti.needsDecoding) {
							debug.info('GRID TABLE - PLAIN // FOOTER - ' + field + ' // ' + tag, 'Converting data: { field = "%s", type = "%s" }',
								fti.field, fti.type);

							self.view.source.convertAll(data.dataByRowId, fti.field);
						}

						fti.deferDecoding = false;
						fti.needsDecoding = false;
					});
					aggResult = aggInfo.instance.calculate(data.data);
					var aggResult_formatted;

					if (isElement(aggResult)) {
						footerVal = aggResult;
					}
					else {
						if (aggInfo.instance.inheritFormatting) {
							aggResult_formatted = format(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
								overrideType: aggInfo.instance.getType()
							});
						}
						else {
							aggResult_formatted = format(null, null, aggResult, {
								overrideType: aggInfo.instance.getType(),
								convert: false
							});
						}

						if (aggInfo.debug) {
							debug.info('GRID TABLE - PLAIN // FOOTER - ' + field, 'Aggregate result: %s',
								JSON.stringify(aggResult));
						}

						switch (typeof footerConfig.format) {
						case 'function':
							footerVal = footerConfig.format(aggResult_formatted);
							break;
						case 'string':
							footerVal = sprintf$1.sprintf(footerConfig.format, aggResult_formatted);
							break;
						default:
							throw new Error('Footer config for field "' + field + '": `format` must be a function or a string');
						}
					}

					if (isElement(footerVal)) {
						td.append(footerVal);
					}
					else {
						td.text(footerVal);
					}
				}

				return td;
			}));

			// ...

			if (self.features.rowReorder) {
				tr.append(jQuery('<td>').text('Options'));
			}

			// Finish the row that contains the aggregate functions.

			self.ui.tfoot.append(tr);
		};

		/*
		 * Create a row in the footer for an external footer that we've absorbed into the grid.
		 */

		var makeExternalFooterRow = function () {
			if (self.opts.footer == null || !self.opts.stealGridFooter) {
				return;
			}

			var tr = jQuery('<tr>');

			if (!isVisible(self.opts.footer)) {
				tr.hide();
			}

			if (self.features.rowSelect) {
				// Circumventing the correct logic here because TableTool requires an empty footer in order to
				// implement horizontal scrolling; if you omit the footer (with a TR and all appropriate TD's
				// in it) then you can't scroll horizontally.
				{
					// There is an aggregate row, so it contains the "select all" checkbox.
					jQuery('<td>', {'class': 'wcdv_group_col_spacer'}).appendTo(tr);
				}
			}

			tr.append(jQuery('<td>', {'colspan': columns.length}).append(self.opts.footer));

			if (self.features.rowReorder) {
				tr.append(jQuery('<td>'));
			}

			self.ui.tfoot.append(tr);
		};

		makeAggregateRow();
		makeExternalFooterRow();
	};

	// #makeRowReorderBtn {{{2

	GridTablePlain.prototype.makeRowReorderBtn = function () {

		return jQuery('<button type="button" class="drag-handle fa">')
			.html(fontAwesome('f07d',null,'Drag or press up/down arrows to move'));
	};

	// #updateFeatures {{{2

	/**
	 * Change the features of this grid table, then redraw the grid table.
	 *
	 * @param {Object} f
	 * The new features to apply.  Any features not indicated will maintain their current settings.
	 *
	 * @method
	 */

	GridTablePlain.prototype.updateFeatures = function (f) {
		var self = this;

		underscore.each(f, function (v, k) {
			self.features[k] = v;
		});

		self.draw(self.root);
	};

	// #addWorkHandler {{{2

	GridTablePlain.prototype.addWorkHandler = function () {
		var self = this;

		self.view.on(View.events.workEnd, function (info, ops) {
			debug.info('GRID TABLE - PLAIN // HANDLER (View.workEnd)', 'View has finished doing work');

			if (ops.group || ops.pivot) {
				debug.info('GRID TABLE - PLAIN // HANDLER (View.workEnd)', 'Unable to render this data: %O', ops);
				self.fire('unableToRender', null, ops);
				return;
			}

			debug.info('GRID TABLE - PLAIN // HANDLER (View.workEnd)', 'Redrawing because the view has done work');
			self.draw(self.root);
		}, { who: self });
	};

	//GridTablePlain.prototype.addWorkHandler = function () {
	//	var self = this;
	//
	//	// Sets up callbacks responsible for correctly redrawing the grid when the view has done work
	//	// (e.g. sorting or filtering) that will change what is displayed.  This is only needed when
	//	// limiting output because otherwise, sort and filter callbacks don't need to redraw the whole
	//	// grid, and they are taken care of by the 'sort' and 'filter' events on a row-by-row basis.
	//
	//	self.view.on(View.events.workEnd, function (info, ops) {
	//		debug.info('GRID TABLE // HANDLER (View.workEnd)', 'View has finished doing work');
	//
	//		if (ops.group || ops.pivot) {
	//
	//			// If the data is grouped or pivotted, we can't render it.  Emit the "unable to render" event
	//			// so that our Grid instance can replace us with a GridTableGroup or GridTablePivot instance
	//			// which can render the data.
	//
	//			self.fire(GridTable.events.unableToRender);
	//			return;
	//		}
	//
	//		if (self.needsRedraw) {
	//			debug.info('GRID TABLE // HANDLER (View.workEnd)', 'Redrawing because the view has done work');
	//
	//			self.needsRedraw = false;
	//
	//			return self.view.getData(function (data) {
	//				return self.view.getTypeInfo(function (typeInfo) {
	//					self.timing.start(['Grid Table', 'Redraw triggered by view']);
	//
	//					// Determine what columns will be in the table.  This comes from the user, or from the
	//					// data itself.  We may then add columns for extra features (like row selection or
	//					// reordering).
	//
	//					var columns = determineColumns(self.defn, data, typeInfo);
	//
	//					// Draw the body.
	//
	//					self.drawBody(data, typeInfo, columns, function () {
	//						self.timing.stop(['Grid Table', 'Redraw triggered by view']);
	//
	//						// Potentially the columns resized as a result of sorting, filtering, or adding new data.
	//						self.fire(GridTable.events.columnResize);
	//					});
	//				});
	//			});
	//		}
	//		else {
	//			// Potentially the columns resized as a result of sorting, filtering, or adding new data.
	//			self.fire(GridTable.events.columnResize);
	//		}
	//	}, { who: self });
	//};

	// #addDataToCsv {{{2

	/**
	 * Add all data to the CSV file.  Because plain tables frequently don't show all the data, it's not
	 * enough to perform the CSV generation inside the `render()` method like we do with other GridTable
	 * implementations.
	 *
	 * @param {object} data
	 */

	GridTablePlain.prototype.addDataToCsv = function (data) {
		var self = this;
		var columns = determineColumns(self.colConfig, data, self.typeInfo);

		debug.info('GRID TABLE - PLAIN // GENERATE CSV', 'Started generating CSV file');
		self.fire('generateCsvProgress', null, 0);

		self.csv.clear();

		self.csv.addRow();
		underscore.each(columns, function (field, colIndex) {
			var fcc = self.colConfig.get(field) || {};
			self.csv.addCol(fcc.displayText || field);
		});

		var howMany = data.data.length / 10;

		var f = function (startIndex) {
			var endIndex = Math.min(data.data.length, startIndex + howMany);
			for (var i = startIndex; i < endIndex; i += 1) {
				var row = data.data[i];

				self.csv.addRow();
				underscore.each(columns, function (field, colIndex) {
					var fcc = self.colConfig.get(field) || {};
					var cell = row.rowData[field];
					var value = format(fcc, self.typeInfo.get(field), cell);

					if (value instanceof Element) {
						self.csv.addCol(jQuery(value).text());
					}
					else if (value instanceof jQuery) {
						self.csv.addCol(value.text());
					}
					else if (fcc.allowHtml && self.typeInfo.get(field).type === 'string' && value.charAt(0) === '<') {
						self.csv.addCol(jQuery(value).text());
					}
					else {
						self.csv.addCol(value);
					}
				});
			}

			if (i === data.data.length) {
				debug.info('GRID TABLE - PLAIN // GENERATE CSV', 'Finished generating CSV file');
				self.fire('generateCsvProgress', null, 100);
				self.fire('csvReady');
			}
			else {
				self.fire('generateCsvProgress', null, Math.floor((i / data.data.length) * 100));
				setTimeout(function () {
					return f(i);
				}, 100);
			}
		};

		return f(0);
	};

	// #_updateSelectionGui {{{2

	/**
	 * Update the checkboxes in the grid table to match what the current selection is.
	 */

	GridTablePlain.prototype._updateSelectionGui = function () {
		var self = this;

		// True if there are no rows to select.
		var isDisabled = self.data.data.length === 0;

		// True if all rows are selected.
		var isAllChecked = !isDisabled && self.selection.length === self.data.data.length;

		// True if some rows are selected, but not all of them.
		var isIndeterminate = !isDisabled && !isAllChecked && self.selection.length > 0;

		var updateCheckboxState = function (elt) {
			elt.prop('disabled', isDisabled);
			elt.prop('checked', isAllChecked);
			elt.prop('indeterminate', isIndeterminate);
		};

		// First, deselect all rows (remove "selected" class and uncheck the box).

		self.root.find('tbody td.wcdv_selected_row').removeClass('wcdv_selected_row');
		self.root.find('tbody td:first-child input[type="checkbox"]').prop('checked', false);

		// Next, find all the TR elements which correspond to selected rows.

		var trs = self.root.find('tbody tr').filter(function (_idx, elt) {
			return self.selection.indexOf(+(jQuery(elt).attr('data-row-num'))) >= 0;
		});

		// Set the "check all" input in the header.

		if (self.ui.checkAll_thead) {
			updateCheckboxState(self.ui.checkAll_thead);
			updateCheckboxState(self.ui.checkAll_thead.parents('div.tabletool').find('input[name="checkAll"]'));
		}

		// Set the "check all" input in the footer.

		if (self.ui.checkAll_tfoot) {
			updateCheckboxState(self.ui.checkAll_tfoot);
			updateCheckboxState(self.ui.checkAll_tfoot.parents('div.tabletool').find('input[name="checkAll"]'));
		}

		// Finally, select appropriate rows (add "selected" class and check the box).

		trs.children('td').addClass('wcdv_selected_row');
		trs.find('td:first-child input[type="checkbox"]').prop('checked', true);
	};

	// #checkAll {{{2

	/**
	 * Event handler for using the "check all" checkbox.
	 *
	 * @param {Event} evt
	 * The event generated by the browser when the checkbox is changed.
	 */

	GridTablePlain.prototype.checkAll = function (evt) {
		var self = this;

		// Synchronize with floating header clone.
		jQuery(evt.target).parents('div.tabletool').find('input[name="checkAll"]').prop('checked', evt.target.checked);

		// Either select or unselect all rows.
		if (evt.target.checked) {
			self.select();
		}
		else {
			self.unselect();
		}
	};

	// #_addRowReorderHandler {{{2

	GridTablePlain.prototype._addRowReorderHandler = function () {

		// configureRowReordering(self.ui.tbody, _.bind(self.view.source.swapRows, self.view.source));
	};

	// #_addRowSelectHandler {{{2

	/**
	 * Add an event handler for the row select checkboxes.  The event is bound on `self.ui.tbody` and
	 * looks for checkbox inputs inside TD elements with class `wcdv_group_col_spacer` to actually handle
	 * the events.  The handler calls `self.select(ROW_NUM)` or `self.unselect(ROW_NUM)` when the
	 * checkbox is changed.
	 */

	GridTablePlain.prototype._addRowSelectHandler = function () {
		var self = this;

		self.ui.tbody.on('change', '.wcdv_group_col_spacer > input[type="checkbox"]', function () {
			if (this.checked) {
				self.select(+(jQuery(this).attr('data-row-num')));
			}
			else {
				self.unselect(+(jQuery(this).attr('data-row-num')));
			}
		});
	};

	// GridTableGroupDetail {{{1
	// Constructor {{{2

	/**
	 * @class
	 * @extends GridTable
	 */

	var GridTableGroupDetail = makeSubclass('GridTableGroupDetail', GridTable, function (grid, defn, view, features, opts, timing, id) {
		var self = this;

		self.super.ctor.apply(self, arguments);

		self.features.sort = false;

		debug.info('GRID TABLE - GROUP - DETAIL', 'Constructing grid table; features = %O', features);
	});

	// #canRender {{{2

	/**
	 * Responds whether or not this grid table can render the type of data requested.
	 *
	 * @param {string} what
	 * The kind of data the caller wants us to show.  Must be one of: plain, group, or pivot.
	 *
	 * @return {boolean}
	 * True if this grid table can render that kind of data, false if it can't.
	 */

	GridTableGroupDetail.prototype.canRender = function (what) {
		switch (what) {
		case 'group':
			return true;
		case 'plain':
		case 'pivot':
			return false;
		}
	};

	// #drawHeader {{{2

	GridTableGroupDetail.prototype.drawHeader = function (columns, data, typeInfo, opts) {
		var self = this,
			headingTr,
			headingSpan,
			headingTh,
			headingThContainer,
			headingThControls,
			headingThCss = {
				'white-space': 'nowrap'
			};

		underscore.each(data.groupFields, function (field, fieldIdx) {
			var fcc = self.colConfig.get(field) || {};

			headingTr = jQuery('<tr>');

			if (self.features.rowSelect) {
				if (fieldIdx === 0) {
					self.ui.checkAll_thead = jQuery('<input>', {
						'name': 'checkAll',
						'type': 'checkbox',
						'class': 'wcdv_select_group',
						'data-group-id': '0'
					})
						.on('change', function (evt) {
							self.checkAll(evt);
						});

					headingTh = jQuery('<th>')
						.addClass('wcdv_group_col_spacer')
						.append(self.ui.checkAll_thead)
						.appendTo(headingTr);
				}
				else {
					jQuery('<th>')
						.addClass('wcdv_group_col_spacer')
						.appendTo(headingTr);
				}
			}

			// Add spacers for the previous group fields.

			for (var i = 0; i < fieldIdx + 1; i += 1) {
				jQuery('<th>')
					.addClass('wcdv_group_col_spacer')
					.appendTo(headingTr)
				;
			}

			// headingTh <TH>
			//   headingThContainer <DIV>
			//     headingSpan <SPAN>
			//     headingThControls <DIV>

			headingSpan = jQuery('<span>')
				.attr({
					'data-wcdv-field': field,
					'data-wcdv-draggable-origin': 'GRID_TABLE_HEADER'
				})
				.addClass('wcdv_heading_title')
				.text(fcc.displayText || field)
				._makeDraggableField()
			;

			headingThControls = jQuery('<div>');

			headingThContainer = jQuery('<div>')
				.addClass('wcdv_heading_container')
				.append(headingSpan, headingThControls);

			headingTh = jQuery('<th>')
				.attr('colspan', columns.length - fieldIdx)
				.css(headingThCss)
				.append(headingThContainer)
			;

			self._addSortingToHeader(data, 'vertical', {groupFieldIndex: fieldIdx}, headingThControls.get(0));

			self.setCss(headingTh, field);

			self.ui.thMap[field] = headingTh;

			headingTr.append(headingTh);
			self.ui.thead.append(headingTr);
		});

		headingTr = jQuery('<tr>');

		// Add spacers for all the group fields.

		if (self.features.rowSelect) {
			jQuery('<th>')
				.addClass('wcdv_group_col_spacer')
				.appendTo(headingTr);
		}

		for (var i = 0; i < data.groupFields.length + 1; i += 1) {
			jQuery('<th>')
				.addClass('wcdv_group_col_spacer')
				.appendTo(headingTr)
			;
		}

		// Make headers for all the normal (non-grouped) columns.

		underscore.each(columns, function (field, colIndex) {
			var fcc = self.colConfig.get(field) || {};

			if (data.groupFields.indexOf(field) >= 0) {
				return;
			}

			headingSpan = jQuery('<span>')
				.attr({
					'data-wcdv-field': field,
					'data-wcdv-draggable-origin': 'GRID_TABLE_HEADER'
				})
				.addClass('wcdv_heading_title')
				.text(fcc.displayText || field)
				._makeDraggableField()
			;

			headingThControls = jQuery('<div>');

			headingThContainer = jQuery('<div>')
				.addClass('wcdv_heading_container')
				.append(headingSpan, headingThControls);

			headingTh = jQuery('<th>')
				.css(headingThCss)
				.append(headingThContainer);

			if (colIndex > 0) {
				headingTh.addClass('wcdv_pivot_colval_boundary');
			}

			self._addSortingToHeader(data, 'vertical', {field: field}, headingThControls.get(0));

			self.setCss(headingTh, field);
			self.setAlignment(headingTh, fcc, typeInfo.get(field));

			self.ui.thMap[field] = headingTh;
			headingTr.append(headingTh);
		});

		self.ui.thead.append(headingTr);
	};

	// #drawBody {{{2

	GridTableGroupDetail.prototype.drawBody = function (data, typeInfo, columns, cont, opts) {
		var self = this;

		// TYPES OF CHECKBOXES:
		//
		//   .wcdv_select_row
		//     * data-row-num = What the rowNum for this data row is.
		//     * [tr] data-wcdv-rowValIndex = What rowVal this row is in.
		//
		//   .wcdv_select_group

		if (!data.isGroup) {
			if (typeof cont === 'function') {
				return cont();
			}
			else {
				return;
			}
		}

		if (self.opts.generateCsv) {
			self.addDataToCsv(data);
		}

		// }}}3

		/*
		self.ui.tbody.on('change', 'input[type="checkbox"].wcdv_select_row', function () {
			var elt = jQuery(this);
			var tr = elt.closest('tr');
			var isChecked = elt.prop('checked');
			var rowNum = +tr.attr('data-row-num');
			var rowValIndex = +tr.attr('data-wcdv-rowValIndex');
			var rowValMetadata = data.groupMetadata.lookup.byRowValIndex[rowValIndex];

			debug.info('GRID TABLE // GROUP - DETAIL // SELECT',
				'Selecting data row: rowNum = %d, rowValIndex = %d, parentGroupId = %s, parentGroupInfo = %O',
				rowNum, rowValIndex, rowValMetadata.id, self.groupInfo[rowValMetadata.id]);

			self.groupInfo[rowValMetadata.id].numSelected += isChecked ? 1 : -1;

			percolateUp(self.groupInfo[rowValMetadata.id]);
		});

		self.ui.tbody.on('change', 'input[type="checkbox"].wcdv_select_group', function () {
			var elt = jQuery(this);
			var tr = elt.closest('tr');
			var isChecked = elt.prop('checked');
			var groupMetadataId = +tr.attr('data-wcdv-toggles-group');

			percolateDown(self.groupInfo[groupMetadataId], isChecked);
			percolateUp(self.groupInfo[groupMetadataId]);
		});
		*/

		var isRendered = {}; // isRendered[metadataId] => boolean
		var lastRenderedTr = {}; // lastRenderedTr[metadataId] => jQuery <TR>

		// groupInfo {{{3

		// groupInfo[id] -> {
		//   metadata
		//   numSelected
		//   checkbox
		// }

		self.groupInfo = (function () {
			var mapping = {};

			function recur(node) {
				mapping[node.id] = {
					metadata: node,
					numSelected: 0
				};
				if (node.children != null) {
					underscore.each(node.children, recur);
				}
			}

			recur(data.groupMetadata);
			mapping[0].checkbox = self.ui.checkAll_thead;
			return mapping;
		})();

		// toggleGroup() {{{3

		/*
		 * Toggle a sub-group open/closed.  This is meant to be used as a jQuery event handler, e.g. for a
		 * click event.
		 */

		function toggleGroup() {

			/*
			 * Toggle the visibility of the subgroup.
			 *
			 *   - metadataId: number
			 *     What group we are expanding/collapsing.
			 *
			 *   - show: boolean
			 *     If true, show the rows in the group; otherwise hide them.
			 *
			 *   - tr: jQuery (TR)
			 *     The table row for the subgroup header.
			 */

			function toggle(metadataId, show, tr) {
				// Within the group metadata, the rowValIndex is only defined for things which are leaves in
				// the grouping tree and therefore complete a rowVal.

				var rowValIndex = self.data.groupMetadata.lookup.byId[metadataId].rowValIndex;

				debug.info('GRID TABLE // GROUP (DETAIL) // TOGGLE', 'show = %s, id = %s, rowValIndex = %s', show, metadataId, rowValIndex);

				// Check if we're expanding a leaf, thus fully expanding an entire group, and see if we need
				// to render table rows for all the records in that group.

				if (show && !isRendered[metadataId]) {
					debug.info('GRID TABLE // GROUP (DETAIL) // TOGGLE', 'Rendering: group metadata ID = %s', metadataId);
					render(metadataId, 0, tr);
				}

				// Set the visibility for all affected table rows.  These can be for children of the current
				// node in the tree (i.e. when expanding the current node does not complete a group), or for
				// records in a fully expanded group: we don't distinguish between these two when it comes to
				// showing/hiding as the attributes used on the elements are the same.

				self.ui.tbody
					.find('tr')
					.filter(function (i, elt) {
						return jQuery(elt).attr('data-wcdv-in-group') === '' + metadataId;
					})
					.each(function (i, elt) {
						elt = jQuery(elt);
						if (elt.attr('data-wcdv-toggles-group')) {
							toggle(+elt.attr('data-wcdv-toggles-group'), show && elt.attr('data-wcdv-expanded') === '1', elt);
						}
						if (show) {
							elt.show();
						}
						else {
							elt.hide();
						}
					})
				;

				if (self.ui.tbl.floatThead) {
					self.ui.tbl.floatThead('reflow');
				}
			}

			var elt = jQuery(this);
			var tr = elt.closest('tr');
			var op = tr.attr('data-wcdv-expanded') === '0' ? 'show' : 'hide';

			if (op === 'show') {
				tr.find('.spinner').show();
			}
			window.setTimeout(function () {
				toggle(+tr.attr('data-wcdv-toggles-group'), op === 'show', tr);
				if (op === 'show') {
					tr.find('.spinner').hide();
				}
				tr.attr('data-wcdv-expanded', op === 'show' ? '1' : '0');
				elt.attr('data-wcdv-expanded', op === 'show' ? '1' : '0');
				elt.html(fontAwesome(op === 'show' ? 'fa-minus-square-o' : 'fa-plus-square-o'));
			});
		}

		// render() {{{3

		/**
		 * @param {number} [metadataId=0]
		 * @param {number} [startIndex=0]
		 * @param {jQuery} [afterElement]
		 */

		function render(metadataId, startIndex, afterElement, showAll) {
			if (metadataId != null && typeof metadataId !== 'number') {
				throw new Error('Call Error: `metadataId` must be null or a number');
			}
			if (startIndex != null && typeof startIndex !== 'number') {
				throw new Error('Call Error: `startIndex` must be null or a number');
			}
			if (afterElement != null && !(afterElement instanceof jQuery)) {
				throw new Error('Call Error: `afterElement` must be null or an instance of jQuery');
			}

			if (metadataId == null) metadataId = 0;
			if (startIndex == null) startIndex = 0;

			if (startIndex > 0 && afterElement == null)
				throw new Error('Call Error: `afterElement` required when `startIndex` > 0');

			var metadataNode = data.groupMetadata.lookup.byId[metadataId];

			if (metadataNode == null)
				throw new Error('No group metadata for specified ID: ' + metadataId);

			var limitConfig = self.defn.table.limit;

			var showMoreTr;

			if (afterElement != null && startIndex > 0) {
				showMoreTr = afterElement.nextAll('tr.wcdvgrid_more[data-wcdv-in-group="' + metadataId + '"]');
				afterElement = showMoreTr.prev();
				showMoreTr.remove();
			}

			if (metadataNode.children) {
				// We're rendering sub-groups.

				var i, j;
				var childMetadataNode;
				var childTr;
				var checkbox;
				var expandBtn;
				var infoText, infoTextSpan;
				var fcc;
				var t, v;
				var rowValElt, rowValEltSpan;
				var showMoreTd;
				var colSpan;

				var trans = {
					'group:singular': 'group',
					'group:plural': 'groups',
					'row:singular': 'row',
					'row:plural': 'rows'
				};

				var childRowValElts = mergeSort2(underscore.pluck(metadataNode.children, 'rowValElt'));
				var childRowValEltsLen = childRowValElts.length;

				var howMany = !self.features.limit || showAll ? childRowValEltsLen
					: startIndex === 0 ? limitConfig.threshold
					: limitConfig.chunkSize;

				for (i = startIndex; i < childRowValEltsLen && i < startIndex + howMany; i += 1) {
					childMetadataNode = metadataNode.children[childRowValElts[i]];

					childTr = jQuery('<tr>')
						.attr('data-wcdv-in-group', metadataNode.id)
						.attr('data-wcdv-toggles-group', childMetadataNode.id)
						.attr('data-wcdv-expanded', '0')
					;

					// Insert spacer columns for previous group fields.

					for (j = 0; j < childMetadataNode.groupFieldIndex; j += 1) {
						jQuery('<th>', {'class': 'wcdv_group_col_spacer'})
							.appendTo(childTr);
					}

					var disabled = childMetadataNode.children == null && childMetadataNode.rows.length === 0;

					expandBtn = jQuery('<button>', {
						'type': 'button',
						'class': 'wcdv_icon_button wcdv_expand_button',
						'data-wcdv-expanded': '0',
						'disabled': disabled
					})
						.html(fontAwesome(disabled ? 'fa-square-o' : 'fa-plus-square-o'));

					jQuery('<th>', {'class': 'wcdv_group_col_spacer'})
						.append(expandBtn)
						.appendTo(childTr);

					// Create the check box which selects the row.

					if (self.features.rowSelect) {
						checkbox = jQuery('<input>', {
							'type': 'checkbox',
							'class': 'wcdv_select_group',
							'data-group-id': childMetadataNode.id,
						});
						self.groupInfo[childMetadataNode.id].checkbox = checkbox;
						jQuery('<th>', {'class': 'wcdv_group_col_spacer'})
							.append(checkbox)
							.appendTo(childTr);
					}

					fcc = self.colConfig.get(childMetadataNode.groupField) || {};
					t = self.typeInfo.get(childMetadataNode.groupField);
					v = childMetadataNode.rowValCell || childMetadataNode.rowValElt;

					if (childMetadataNode.groupSpec.fun != null) {
						t = {
							type: GROUP_FUNCTION_REGISTRY.get(childMetadataNode.groupSpec.fun).resultType
						};
						v = childMetadataNode.rowValElt;
					}

					rowValElt = format(fcc, t, v);
					rowValEltSpan = jQuery('<span>');

					if (rowValElt instanceof Element || rowValElt instanceof jQuery) {
						rowValEltSpan.append(rowValElt);
					}
					else if (fcc.allowHtml) {
						rowValEltSpan.html(rowValElt);
					}
					else {
						rowValEltSpan.text(rowValElt);
					}

					infoText = '(';
					if (childMetadataNode.children != null) {
						infoText += childMetadataNode.numChildren + ' ';
						infoText += (childMetadataNode.numChildren === 1 ? trans['group:singular'] : trans['group:plural']) + ', ';
					}
					infoText += childMetadataNode.numRows + ' ';
					infoText += childMetadataNode.numRows === 1 ? trans['row:singular'] : trans['row:plural'];
					infoText += ')';

					infoTextSpan = jQuery('<span>').css({'margin-left': '0.5em'}).text(infoText);

					var spinnerDiv = jQuery('<div>', {'class': 'spinner'})
						.append(jQuery('<div>', {'class': 'bounce1'}))
						.append(jQuery('<div>', {'class': 'bounce2'}))
						.append(jQuery('<div>', {'class': 'bounce3'}))
						.hide();

					jQuery('<th>', {
						'class': 'wcdv_group_value',
						'data-wcdv-field': childMetadataNode.groupField,
						'colspan': columns.length - childMetadataNode.groupFieldIndex
					})
						.append(rowValEltSpan)
						.append(infoTextSpan)
						.append(spinnerDiv)
						.appendTo(childTr);

					if (afterElement != null) {
						afterElement.after(childTr);
					}
					else {
						self.ui.tbody.append(childTr);
					}

					afterElement = childTr;

					var rowRenderCb = getProp(self.opts, 'events', 'rowRender');
					if (typeof rowRenderCb === 'function') {
						rowRenderCb(childTr, {
							isGroup: true,
							groupMode: 'detail',
							groupField: childMetadataNode.groupField,
							rowValElt: childMetadataNode.rowValCell.value,
							groupMetadata: childMetadataNode
						});
					}
				}

				isRendered[metadataNode.id] = true;

				if (i < childRowValEltsLen - 1) {
					// Not all children were rendered.

					lastRenderedTr[metadataNode.id] = childTr;
					for (var p = metadataNode.parent; p != null; p = p.parent) {
						lastRenderedTr[p.id] = childTr;
					}

					showMoreTr = jQuery('<tr>', {'class': 'wcdvgrid_more', 'data-wcdv-in-group': metadataNode.id});

					// Insert spacer columns for previous group fields.

					for (j = 0; j < childMetadataNode.groupFieldIndex; j += 1) {
						jQuery('<th>', {'class': 'wcdv_group_col_spacer'})
							.appendTo(showMoreTr);
					}

					colSpan = columns.length
						+ 1 // for the "expand" button column
						+ (self.features.rowSelect ? 1 : 0)
						+ (self.features.rowReorder ? 1 : 0)
						- (metadataNode.groupFieldIndex || 0);

					spinnerDiv = jQuery('<div>', {'class': 'spinner'})
						.append(jQuery('<div>', {'class': 'bounce1'}))
						.append(jQuery('<div>', {'class': 'bounce2'}))
						.append(jQuery('<div>', {'class': 'bounce3'}))
						.hide();

					showMoreTd = jQuery('<td>', {
						'class': 'wcdv_show_more',
						'data-wcdv-in-group': metadataNode.id,
						'data-wcdv-show-more-start': i,
						'colspan': colSpan
					})
						.append(fontAwesome('F13A'))
						.append(jQuery('<span>Showing rows 1–' + i + ' of ' + childRowValEltsLen + '.</span>')
							.css({'padding-left': '0.5em'}))
						.append(jQuery('<button type="button">Load ' + limitConfig.chunkSize + ' more rows.</button>')
							.css({'margin-left': '0.5em'}))
						.append(jQuery('<button type="button" class="wcdv_show_all">Load all rows.</button>')
							.css({'margin-left': '0.5em'})
						)
						.append(spinnerDiv)
						.appendTo(showMoreTr);

					childTr.after(showMoreTr);
				}
			}
			else if (metadataNode.rows) {
				// We're rendering data rows.

				var isSelected;
				var checkbox;
				var row;
				var rowTr;
				var showMoreTd;
				var colSpan;

				var howMany = (!self.features.limit || showAll) ? metadataNode.rows.length - startIndex
					: startIndex === 0 ? limitConfig.threshold
					: limitConfig.chunkSize;

				for (i = startIndex; i < metadataNode.rows.length && i < startIndex + howMany; i += 1) {
					row = metadataNode.rows[i];

					rowTr = jQuery('<tr>', {
						'id': self.defn.table.id + '_' + i,
						'data-row-num': row.rowNum,
						'data-wcdv-in-group': metadataNode.id,
						'data-wcdv-rowValIndex': metadataNode.rowValIndex
					});

					// Insert some space to "indent" the data.
					// TODO When does one of these work differently from the other?

					//jQuery('<td>', {'colspan': data.groupFields.length + 1}).appendTo(rowTr);
					for (var spacerIndex = 0; spacerIndex < data.groupFields.length + 1; spacerIndex += 1) {
						jQuery('<td>', {'class': 'wcdv_group_col_spacer'}).appendTo(rowTr);
					}

					// Create the check box which selects the row.

					if (self.features.rowSelect) {
						isSelected = self.isSelected(row.rowNum);
						checkbox = jQuery('<input>', {
							'type': 'checkbox',
							'data-row-num': row.rowNum,
							'class': 'wcdv_select_row',
							'checked': isSelected
						});
						jQuery('<td>', {'class': 'wcdv_group_col_spacer'}).append(checkbox).appendTo(rowTr);
					}

					// Create the data cells.

					underscore.each(columns, function (field, colIndex) {
						if (data.groupFields.indexOf(field) >= 0) {
							return;
						}

						var fcc = self.colConfig.get(field) || {};
						var cell = row.rowData[field];

						var td = jQuery('<td>', {'data-wcdv-field': field});
						if (colIndex > 0) {
							td.addClass('wcdv_pivot_colval_boundary');
						}
						var value = format(fcc, typeInfo.get(field), cell);

						if (value instanceof Element || value instanceof jQuery) {
							td.append(value);
						}
						else if (fcc.allowHtml && typeInfo.get(field).type === 'string') {
							td.html(value);
						}
						else if (value === '') {
							td.html('&nbsp;');
						}
						else {
							td.text(value);
						}

						self.setCss(td, field);
						self.setAlignment(td, fcc, typeInfo.get(field));

						rowTr.append(td);
					});

					if (self.features.rowSelect && isSelected) {
						rowTr.children('td').addClass('wcdv_selected_row');
					}

					self.ui.tr[i] = rowTr;
					afterElement.after(rowTr);
					afterElement = rowTr;

					var rowRenderCb = getProp(self.opts, 'events', 'rowRender');
					if (typeof rowRenderCb === 'function') {
						rowRenderCb(rowTr, {
							isGroup: true,
							groupMode: 'details',
							rowData: row.rowData,
							rowNum: row.rowNum
						});
					}
				}

				isRendered[metadataNode.id] = true;

				if (i < metadataNode.rows.length - 1) {
					// Not all children were rendered.

					lastRenderedTr[metadataNode.id] = rowTr;
					for (var p = metadataNode.parent; p != null; p = p.parent) {
						lastRenderedTr[p.id] = rowTr;
					}

					showMoreTr = jQuery('<tr>', {'class': 'wcdvgrid_more', 'data-wcdv-in-group': metadataNode.id});

					// Insert spacer columns for previous group fields.

					for (j = 0; j < metadataNode.groupFieldIndex + 1; j += 1) {
						jQuery('<th>', {'class': 'wcdv_group_col_spacer'})
							.appendTo(showMoreTr);
					}

					colSpan = columns.length
						+ 1 // for the "expand" button column
						+ (self.features.rowSelect ? 1 : 0)
						+ (self.features.rowReorder ? 1 : 0)
						- (metadataNode.groupFieldIndex + 1);

					spinnerDiv = jQuery('<div>', {'class': 'spinner'})
						.append(jQuery('<div>', {'class': 'bounce1'}))
						.append(jQuery('<div>', {'class': 'bounce2'}))
						.append(jQuery('<div>', {'class': 'bounce3'}))
						.hide();

					showMoreTd = jQuery('<td>', {
						'class': 'wcdv_show_more',
						'data-wcdv-in-group': metadataNode.id,
						'data-wcdv-show-more-start': i,
						'colspan': colSpan
					})
						.append(fontAwesome('F13A'))
						.append(jQuery('<span>Showing rows 1–' + i + ' of ' + metadataNode.rows.length + '.</span>')
							.css({'padding-left': '0.5em'}))
						.append(jQuery('<button type="button">Load ' + limitConfig.chunkSize + ' more rows.</button>')
							.css({'margin-left': '0.5em'}))
						.append(jQuery('<button type="button" class="wcdv_show_all">Load all rows.</button>')
							.css({'margin-left': '0.5em'})
						)
						.append(spinnerDiv)
						.appendTo(showMoreTr);

					rowTr.after(showMoreTr);
				}
			}

			self._updateSelectionGui();

			if (self.features.floatingHeader) {
				switch (getProp(self.defn, 'table', 'floatingHeader', 'method')) {
				case 'tabletool':
					TableTool.update();
					break;
				}
			}
		}

		// showMore() {{{3

		function showMore(showAll) {
			var elt = jQuery(this).closest('td');
			var metadataId = +(elt.attr('data-wcdv-in-group'));
			var startIndex = +(elt.attr('data-wcdv-show-more-start'));
			var afterElement = lastRenderedTr[metadataId];

			afterElement.nextAll('tr.wcdvgrid_more[data-wcdv-in-group="' + metadataId + '"]').find('.spinner').show();

			window.setTimeout(function () {
				render(metadataId, startIndex, afterElement, showAll);
				// No need to hide the spinner because the "show more" row should be gone.
			});
		}

		// }}}3

		render();
		self.ui.tbody.on('click', 'button.wcdv_expand_button', toggleGroup);
		self.ui.tbody.on('click', 'td.wcdv_show_more button.wcdv_show_all', function (evt) {
			evt.stopPropagation();
			showMore.call(this, true);
		});
		self.ui.tbody.on('click', 'td.wcdv_show_more', function (evt) {
			showMore.call(this, false);
		});

		self._updateSelectionGui();

		if (self.features.floatingHeader) {
			switch (getProp(self.defn, 'table', 'floatingHeader', 'method')) {
			case 'tabletool':
				TableTool.update();
				break;
			}
		}

		if (typeof cont === 'function') {
			return cont();
		}
	};

	// #drawFooter {{{2

	GridTableGroupDetail.prototype.drawFooter = function (columns, data, typeInfo) {
		var self = this;

		var makeSelectAll = function (tr) {
			self.ui.checkAll_tfoot = jQuery('<input>', {
				'name': 'checkAll',
				'type': 'checkbox',
				'class': 'wcdv_select_group',
				'data-group-id': '0'
			})
				.on('change', function (evt) {
					self.checkAll(evt);
				});
			jQuery('<td>', {'class': 'wcdv_group_col_spacer'}).append(self.ui.checkAll_tfoot).appendTo(tr);
		};

		var makeAggregateRow = function () {

			var tr = jQuery('<tr>');

			// Add the "select all" checkbox when row selection is enabled.

			if (self.features.rowSelect) {
				makeSelectAll(tr);
			}

			for (var spacerIndex = 0; spacerIndex < data.groupFields.length + 1; spacerIndex += 1) {
				jQuery('<td>', {'class': 'wcdv_group_col_spacer'}).appendTo(tr);
			}

			// Create the columns for the data fields, which contain aggregate function results over those
			// fields.

			var didFooterCell = false;

			tr.append(underscore.map(columns, function (field, colIndex) {
				if (data.groupFields.indexOf(field) >= 0) {
					return;
				}

				var fcc = self.colConfig.get(field) || {};
				var colTypeInfo = typeInfo.get(field);
				var td = jQuery('<td>');
				var footerConfig = getProp(self.defn, 'table', 'footer', field);
				var aggResult;
				var footerVal;

				self.setCss(td, field);
				self.setAlignment(td, fcc, typeInfo.get(field));

				if (footerConfig == null) {
					if (didFooterCell) {
						td.addClass('wcdv_divider');
					}

					didFooterCell = false;
				}
				else {
					if (colIndex > 0) {
						td.addClass('wcdv_divider');
					}

					didFooterCell = true;

					// Although the footer config is an aggregate spec, there is one place we allow more
					// flexibility.  If the fields aren't set, use the field for the column in which we're
					// displaying this footer.  This is merely a convenience for the most common case.

					if (footerConfig.fields == null) {
						footerConfig.fields = [field];
					}

					debug.info('GRID TABLE - PLAIN // FOOTER - ' + field, 'Creating footer using config: %O', footerConfig);

					var aggInfo = new AggregateInfo('all', footerConfig, 0, self.colConfig, typeInfo, function (tag, fti) {
						if (fti.needsDecoding) {
							debug.info('GRID TABLE - PLAIN // FOOTER - ' + field + ' // ' + tag, 'Converting data: { field = "%s", type = "%s" }',
								fti.field, fti.type);

							self.view.source.convertAll(data.dataByRowId, fti.field);
						}

						fti.deferDecoding = false;
						fti.needsDecoding = false;
					});
					aggResult = aggInfo.instance.calculate(data.groupMetadata.rows);
					var aggResult_formatted;

					if (isElement(aggResult)) {
						footerVal = aggResult;
					}
					else {
						if (aggInfo.instance.inheritFormatting) {
							aggResult_formatted = format(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
								overrideType: aggInfo.instance.getType()
							});
						}
						else {
							aggResult_formatted = format(null, null, aggResult, {
								overrideType: aggInfo.instance.getType(),
								convert: false
							});
						}

						if (aggInfo.debug) {
							debug.info('GRID TABLE - PLAIN // FOOTER - ' + field, 'Aggregate result: %s',
								JSON.stringify(aggResult));
						}

						switch (typeof footerConfig.format) {
						case 'function':
							footerVal = footerConfig.format(aggResult_formatted);
							break;
						case 'string':
							footerVal = sprintf$1.sprintf(footerConfig.format, aggResult_formatted);
							break;
						default:
							throw new Error('Footer config for field "' + field + '": `format` must be a function or a string');
						}
					}

					if (footerVal instanceof Element || footerVal instanceof jQuery) {
						td.append(footerVal);
					}
					else {
						td.text(footerVal);
					}
				}

				return td;
			}));

			// Finish the row that contains the aggregate functions.

			self.ui.tfoot.append(tr);
		};

		var makeExternalFooterRow = function () {
			// Create a new footer row for an external footer that we've absorbed into the grid.

			if (self.opts.footer == null || !self.opts.stealGridFooter) {
				return;
			}

			var tr = jQuery('<tr>');

			if (!isVisible(self.opts.footer)) {
				tr.hide();
			}

			if (self.features.rowSelect) {
				// Circumventing the correct logic here because TableTool requires an empty footer in order to
				// implement horizontal scrolling; if you omit the footer (with a TR and all appropriate TD's
				// in it) then you can't scroll horizontally.
				{
					// There is an aggregate row, so it contains the "select all" checkbox.
					jQuery('<td>', {'class': 'wcdv_group_col_spacer'}).appendTo(tr);
				}
			}
			// colspan = (spacers: # groupFields + 1) + (columns: # fields - # groupFields) = (# fields) + 1
			jQuery('<td>', {'colspan': columns.length + 1}).append(self.opts.footer).appendTo(tr);
			self.ui.tfoot.append(tr);
		};

		makeAggregateRow();
		makeExternalFooterRow();
	};

	// #addWorkHandler {{{2

	GridTableGroupDetail.prototype.addWorkHandler = function () {
		var self = this;

		self.view.on(View.events.workEnd, function (info, ops) {
			debug.info('GRID TABLE - GROUP - DETAIL // HANDLER (View.workEnd)', 'View has finished doing work');

			if (!ops.group || ops.pivot) {
				self.fire('unableToRender', null, ops);
				return;
			}

			debug.info('GRID TABLE - GROUP - DETAIL // HANDLER (View.workEnd)', 'Redrawing because the view has done work');
			self.draw(self.root);
		}, { who: self });
	};

	// #_addRowSelectHandler {{{2

	/**
	 * Add an event handler for the row select checkboxes.  The event is bound on `self.ui.tbody` and
	 * looks for checkbox inputs inside TD elements with class `wcdv_group_col_spacer` to actually handle
	 * the events.  The handler calls `self.select(ROW_NUM)` or `self.unselect(ROW_NUM)` when the
	 * checkbox is changed.
	 */

	GridTableGroupDetail.prototype._addRowSelectHandler = function () {
		var self = this;

		self.ui.tbody.on('change', 'input[type="checkbox"].wcdv_select_row', function () {
			var elt = jQuery(this);
			var rowNum = +elt.attr('data-row-num');
			var isChecked = elt.prop('checked');

			if (isChecked) {
				self.select(rowNum);
			}
			else {
				self.unselect(rowNum);
			}
		});

		self.ui.tbody.on('change', 'input[type="checkbox"].wcdv_select_group', function () {
			var elt = jQuery(this);
			var isChecked = elt.prop('checked');
			var groupMetadataId = +elt.attr('data-group-id');
			var rowNums = [];

			// Find all rows that are a descendant of the selected group.

			function recur(node) {
				if (node.children == null) {
					rowNums = rowNums.concat(underscore.pluck(self.data.data[node.rowValIndex], 'rowNum'));
				}
				else {
					underscore.each(node.children, recur);
				}
			}

			recur(self.data.groupMetadata.lookup.byId[groupMetadataId]);

			if (isChecked) {
				self.select(rowNums);
			}
			else {
				self.unselect(rowNums);
			}
		});
	};

	// #_updateSelectionGui {{{2

	/**
	 * Update the checkboxes in the grid table to match what the current selection is.
	 */

	GridTableGroupDetail.prototype._updateSelectionGui = function () {
		var self = this;

		// First, deselect all rows (remove "selected" class and uncheck the box).

		self.root.find('tbody td.wcdv_selected_row').removeClass('wcdv_selected_row');
		self.root.find('tbody input[type="checkbox"].wcdv_select_row').prop('checked', false);
		self.root.find('tbody input[type="checkbox"].wcdv_select_group').prop('checked', false);

		// Next, find all the TR elements which correspond to selected rows.

		var trs = self.root.find('tbody tr').filter(function (_idx, elt) {
			return self.selection.indexOf(+(jQuery(elt).attr('data-row-num'))) >= 0;
		});

		// Select appropriate rows (add "selected" class and check the box).

		trs.children('td').addClass('wcdv_selected_row');
		trs.find('input[type="checkbox"].wcdv_select_row').prop('checked', true);

		// ===============================================================================================
		//
		//   DETERMINE GROUPING (HIERARCHICAL, PARENT) CHECKBOX STATES
		//
		// ===============================================================================================

		// Initialize the structure with no rows selected in any leaf.

		var numSelected = {};

		underscore.each(underscore.keys(self.data.groupMetadata.lookup.byId), function (id) {
			numSelected[id] = 0;
		});

		// Determine how many are selected in each leaf of the tree.

		for (var i = 0; i < self.selection.length; i += 1) {
			var s = self.selection[i];
			var id = getProp(self.data, 'groupMetadata', 'lookup', 'byRowNum', s, 'id');

			if (id == null) {
				// This can happen when the selected row has been filtered out, so there's no group metadata
				// entry for that row number.

				continue;
			}

			if (numSelected[id] == null) {
				numSelected[id] = 0;
			}

			numSelected[id] += 1;
		}

		// Determine how many are selected at all non-leaf nodes.

		(function () {
			function postorder(node) {
				if (node.children != null) {
					numSelected[node.id] = 0;
					underscore.each(node.children, function (c) {
						postorder(c);
						numSelected[node.id] += numSelected[c.id];
					});
				}
			}

			postorder(self.data.groupMetadata);
		})();

		underscore.each(numSelected, function (count, id) {
			var numRows = self.data.groupMetadata.lookup.byId[id].numRows;
			var checkbox = self.root.find('input[type="checkbox"][data-group-id="' + id + '"].wcdv_select_group');

			if (checkbox.length === 0) {
				// This can happen when the rows for the sub-groups haven't been rendered yet.

				return;
			}

			if (numRows === 0) {
				checkbox.prop({
					disabled: true,
					indeterminate: false,
					checked: false,
				});
			}
			else if (count === 0) {
				checkbox.prop({
					disabled: false,
					indeterminate: false,
					checked: false,
				});
			}
			else if (numRows === count) {
				checkbox.prop({
					disabled: false,
					indeterminate: false,
					checked: true,
				});
			}
			else {
				checkbox.prop({
					disabled: false,
					indeterminate: true,
					checked: false,
				});
			}
		});
	};

	// #checkAll {{{2

	/**
	 * Event handler for using the "check all" checkbox.
	 *
	 * @param {Event} evt
	 * The event generated by the browser when the checkbox is changed.
	 */

	GridTableGroupDetail.prototype.checkAll = function (evt) {
		var self = this;

		// Synchronize with floating header clone.
		jQuery(evt.target).parents('div.tabletool').find('input[name="checkAll"]').prop('checked', evt.target.checked);

		// Either select or unselect all rows.
		if (evt.target.checked) {
			self.select();
		}
		else {
			self.unselect();
		}
	};

	// #addDataToCsv {{{2

	/**
	 * Add all data to the CSV file.  Because plain tables frequently don't show all the data, it's not
	 * enough to perform the CSV generation inside the `render()` method like we do with other GridTable
	 * implementations.
	 *
	 * @param {object} data
	 */

	GridTableGroupDetail.prototype.addDataToCsv = function (data) {
		var self = this;
		var columns = determineColumns(self.colConfig, data, self.typeInfo);

		debug.info('GRID TABLE - GROUP DETAIL // GENERATE CSV', 'Started generating CSV file');
		self.fire('generateCsvProgress', null, 0);

		self.csv.clear();

		self.csv.addRow();

		underscore.each(data.groupFields, function (fieldName) {
			var fcc = self.colConfig.get(fieldName) || {};
			self.csv.addCol(fcc.displayText || fieldName);
		});
		underscore.each(underscore.difference(columns, data.groupFields), function (fieldName) {
			var fcc = self.colConfig.get(fieldName) || {};
			self.csv.addCol(fcc.displayText || fieldName);
		});

		function recur(depth, metadataNode) {
			if (metadataNode.children != null) {
				underscore.each(underscore.keys(metadataNode.children).sort(), function (childName) {
					self.csv.addRow();
					for (var j = 0; j < depth; j += 1) {
						self.csv.addCol();
					}
					self.csv.addCol(childName);
					for (var j = depth + 1; j < columns.length; j += 1) {
						self.csv.addCol();
					}
					recur(depth + 1, metadataNode.children[childName]);
				});
			}
			else {
				underscore.each(metadataNode.rows, function (row) {
					self.csv.addRow();
					for (var j = 0; j < depth; j += 1) {
						self.csv.addCol();
					}
					underscore.each(underscore.difference(columns, data.groupFields), function (field, colIndex) {
						var fcc = self.colConfig.get(field) || {};
						var cell = row.rowData[field];
						var value = format(fcc, self.typeInfo.get(field), cell);

						if (value instanceof Element) {
							self.csv.addCol(jQuery(value).text());
						}
						else if (value instanceof jQuery) {
							self.csv.addCol(value.text());
						}
						else if (fcc.allowHtml && self.typeInfo.get(field).type === 'string' && value.charAt(0) === '<') {
							self.csv.addCol(jQuery(value).text());
						}
						else {
							self.csv.addCol(value);
						}
					});
				});
			}
		}

		recur(0, data.groupMetadata);

		debug.info('GRID TABLE - PLAIN // GENERATE CSV', 'Finished generating CSV file');
		self.fire('generateCsvProgress', null, 100);
		self.fire('csvReady');
	};

	// GridTableGroupSummary {{{1
	// Constructor {{{2

	/**
	 * @class
	 * @extends GridTable
	 */

	var GridTableGroupSummary = makeSubclass('GridTableGroupSummary', GridTable, function (grid, defn, view, features, opts, timing, id) {
		var self = this;

		self.super.ctor.apply(self, arguments);

		self.features.limit = false;
		self.features.rowSelect = false;
		self.features.footer = false;

		debug.info('GRID TABLE - GROUP - SUMMARY', 'Constructing grid table; features = %O', features);

		setPropDef(['rowVals', 'groupAggregates'], self.opts, 'displayOrder');
	});

	// #canRender {{{2

	/**
	 * Responds whether or not this grid table can render the type of data requested.
	 *
	 * @param {string} what
	 * The kind of data the caller wants us to show.  Must be one of: plain, group, or pivot.
	 *
	 * @return {boolean}
	 * True if this grid table can render that kind of data, false if it can't.
	 */

	GridTableGroupSummary.prototype.canRender = function (what) {
		switch (what) {
		case 'group':
			return true;
		case 'plain':
		case 'pivot':
			return false;
		}
	};

	// #drawHeader {{{2

	GridTableGroupSummary.prototype.drawHeader = function (columns, data, typeInfo, opts) {
		var self = this,
			tr = jQuery('<tr>'),
			headingSpan,
			headingTh,
			headingThControls,
			headingThContainer;

		self.csv.addRow();

		underscore.each(self.opts.displayOrder, function (what, displayOrderIndex) {
			if (typeof what === 'string') {
				if (what === 'rowVals') {
					underscore.each(data.groupFields, function (field, fieldIdx) {
						var fcc = self.colConfig.get(field) || {};
						var headingText = fcc.displayText || field;

						// headingTh <TH>
						//   headingThContainer <DIV>
						//     headingThSpan <SPAN>
						//     headingThControls <DIV>

						headingSpan = jQuery('<span>', {
							'class': 'wcdv_heading_title',
							'data-wcdv-field': field,
							'data-wcdv-draggable-origin': 'GRID_TABLE_HEADER',
						})
							.text(headingText)
							._makeDraggableField();

						headingThControls = jQuery('<div>');

						headingThContainer = jQuery('<div>')
							.addClass('wcdv_heading_container')
							.append(headingSpan, headingThControls);

						headingTh = jQuery('<th>')
							.append(headingThContainer);

						self.csv.addCol(fcc.displayText || field);

						self._addSortingToHeader(data, 'vertical', {groupFieldIndex: fieldIdx}, headingThControls.get(0), getProp(data, 'agg', 'info', 'group'));

						self.setCss(headingTh, field);

						self.ui.thMap[field] = headingTh;
						tr.append(headingTh);
					});
				}
				else if (what === 'groupAggregates') {
					self.drawHeader_aggregates(data, tr, displayOrderIndex, self.opts.displayOrder.length);
				}
				else if (what === 'addCols') {
					self.drawHeader_addCols(tr, typeInfo, opts);
				}
			}
		});

		// Add the row for this pivot field to the THEAD.
		self.ui.thead.append(tr);
	};

	// #drawBody {{{2

	GridTableGroupSummary.prototype.drawBody = function (data, typeInfo, columns, cont, opts) {
		var self = this;
		var ai = self._getAggInfo(data);
		var aggType, aggInfo, rowAgg;

		self._setupFullValueWin(data);

		underscore.each(data.data, function (rowGroup, groupNum) {
			var tr = document.createElement('tr');
			tr.setAttribute('data-rowval-index', groupNum);

			self.csv.addRow();

			underscore.each(self.opts.displayOrder, function (what, displayOrderIndex) {
				if (typeof what === 'string') {
					if (what === 'rowVals') {
						self.drawBody_rowVals(data, tr, groupNum);
					}
					else if (what === 'groupAggregates') {
						self.drawBody_groupAggregates(data, tr, groupNum, displayOrderIndex, self.opts.displayOrder.length);
					}
					else if (what === 'addCols') {
						// Generate the user's custom-defined additional columns.  If the `value` function returns an
						// Element or jQuery instance, we just put that in the <TD> that we make.  Otherwise (e.g. it
						// returns a string or number) we format it according to the type of the field that the pivot
						// function was operating on.
						//
						// EXAMPLE:
						//
						// Aggregate Function = sum
						// Aggregate Field    = Amount : number -> $0,0.00
						//
						// If the `value` function adds up the sums, yielding a grand total of them all, then we format
						// that using Numeral exactly as specified for the "Amount" field.

						underscore.each(self.opts.addCols, function (addCol) {
							var td = document.createElement('td');
							var addColResult = addCol.value(data.data, groupNum, rowAgg, aggType);
							var addColText;

							if (addColResult instanceof jQuery) {
								addColResult = addColResult.get(0);
							}

							if (addColResult instanceof Element) {
								td.appendChild(addColResult);
								self.csv.addCol(addColResult.innerText);
							}
							else {
								if (aggInfo.instance.inheritFormatting) ;
								else {
									addColText = format(null, null, addColResult, {
										alwaysFormat: true,
										convert: false
									});
								}
								td.innerText = addColText;
								self.csv.addCol(addColText);
							}

							if (getProp(opts, 'pivotConfig', 'aggField')) {
								self.setAlignment(td, self.colConfig.get(opts.pivotConfig.aggField), typeInfo.get(opts.pivotConfig.aggField));
							}

							tr.appendChild(td);
						});
					}
				}
			});

			self.ui.tbody.append(tr);
		});

		var renderTotalRow = function () {
			var tr;

			tr = jQuery('<tr>', {'class': 'wcdv_btd'});
			self.csv.addRow();

			underscore.each(self.opts.displayOrder, function (what) {
				switch (what) {
				case 'rowVals':
					for (var i = 0; i < data.groupFields.length - 1; i += 1) {
						self.csv.addCol('');
					}
					self.csv.addCol('Total');

					var span = jQuery('<span>', {'class': 'wcdv_heading_title'})
						.text('Total');
					var headingThControls = jQuery('<div>');
					var headingThContainer = jQuery('<div>')
						.addClass('wcdv_heading_container')
						.append(span, headingThControls);
					var th = jQuery('<th>')
						.attr({'colspan': data.groupFields.length})
						.append(headingThContainer)
						.appendTo(tr);

					break;
				case 'groupAggregates':
					underscore.each(ai.all, function (aggInfo, aiAllIndex) {
						var aggResult
							, text
							, td;

						td = jQuery('<td>');
						td.attr('data-wcdv-agg-scope', 'all');
						td.attr('data-wcdv-agg-num', aggInfo.aggNum);
						aggResult = data.agg.results.all[aggInfo.aggNum];

						if (isElement(aggResult)) {
							td.append(aggResult);
							self.csv.addCol(getElement(aggResult).innerText);
						}
						else {
							if (aggInfo.instance.inheritFormatting) {
								text = format(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
									overrideType: aggInfo.instance.getType()
								});
								setTableCell(td, text, {
									field: aggInfo.fields[0],
									colConfig: aggInfo.colConfig[0],
									typeInfo: aggInfo.typeInfo[0]
								});
							}
							else {
								text = format(null, null, aggResult, {
									overrideType: aggInfo.instance.getType(),
									convert: false
								});
								setTableCell(td, text);
							}
							self.csv.addCol(td.innerText);
						}

						if (self.opts.drawInternalBorders || ai.cell.length > 1) {
							td.addClass(aiAllIndex === 0 ? 'wcdv_pivot_aggregate_boundary' : 'wcdv_pivot_colval_boundary');
						}

						self.setAlignment(td, aggInfo.colConfig[0], aggInfo.typeInfo[0], aggInfo.instance.getType());
						td.appendTo(tr);
					});
					break;
				}
			});

			tr.appendTo(self.ui.tbody);
		};

		if (ai.all.length > 0) {
			renderTotalRow();
		}

		if (self.features.floatingHeader) {
			switch (getProp(self.defn, 'table', 'floatingHeader', 'method')) {
			case 'tabletool':
				TableTool.update();
				break;
			}
		}

		self.fire('csvReady');

		if (typeof cont === 'function') {
			return cont();
		}
	};

	// #drawFooter {{{2

	GridTableGroupSummary.prototype.drawFooter = function (columns, data, typeInfo) {
		var self = this;
		var tr;

		// Create the footer row to show aggregate functions.

		tr = jQuery('<tr>');

		// Add the "select all" checkbox when row selection is enabled.

		if (self.features.rowSelect) {
			self.ui.checkAll_tfoot = jQuery('<input>', { 'name': 'checkAll', 'type': 'checkbox' })
				.on('change', function (evt) {
					self.checkAll(evt);
				});
			jQuery('<td>', {'class': 'wcdv_group_col_spacer'}).append(self.ui.checkAll_tfoot).appendTo(tr);
		}

		// Create a new footer row for an external footer that we've absorbed into the grid.

		if (self.opts.footer != null && self.opts.stealGridFooter) {
			tr.append(jQuery('<td>', {'colspan': data.groupFields.length + self._getAggInfo(data).group.length}).append(self.opts.footer));
		}

		if (tr.children().length > 0) {
			self.ui.tfoot.append(tr);
		}
	};

	// #addWorkHandler {{{2

	GridTableGroupSummary.prototype.addWorkHandler = function () {
		var self = this;

		self.view.on(View.events.workEnd, function (info, ops) {
			debug.info('GRID TABLE - GROUP - SUMMARY // HANDLER (View.workEnd)', 'View has finished doing work');

			if (!ops.group || ops.pivot) {
				self.fire('unableToRender', null, ops);
				return;
			}

			debug.info('GRID TABLE - GROUP - SUMMARY // HANDLER (View.workEnd)', 'Redrawing because the view has done work');
			self.draw(self.root);
		}, { who: self });
	};

	// GridTablePivot {{{1
	// Constructor {{{2

	/**
	 * A grid table used for showing data that's been pivotted by the view.
	 *
	 * @class
	 * @extends GridTable
	 */

	var GridTablePivot = makeSubclass('GridTablePivot', GridTable, function (grid, defn, view, features, opts, timing, id) {
		var self = this;

		self.super.ctor.apply(self, arguments);

		self.features.limit = false;
		self.features.footer = false;

		debug.info('GRID TABLE - PIVOT', 'Constructing grid table; features = %O', features);

		setPropDef(['rowVals', 'cells', 'groupAggregates', 'addCols'], self.opts, 'displayOrder');
	});

	// #canRender {{{2

	/**
	 * Responds whether or not this grid table can render the type of data requested.
	 *
	 * @param {string} what
	 * The kind of data the caller wants us to show.  Must be one of: plain, group, or pivot.
	 *
	 * @return {boolean}
	 * True if this grid table can render that kind of data, false if it can't.
	 */

	GridTablePivot.prototype.canRender = function (what) {
		switch (what) {
		case 'pivot':
			return true;
		case 'plain':
		case 'group':
			return false;
		}
	};

	// #drawHeader {{{2

	GridTablePivot.prototype.drawHeader = function (columns, data, typeInfo, opts) {
		var self = this,
			aggInfo,
			tr,
			span,
			headingThControls,
			headingThContainer,
			th;

		// +---------------------------+--------------------------------------+-----------+
		// |                           | COLVAL 1.1              | COLVAL 1.2 |           |
		// +---------------------------+------------+------------+------------+-----------+
		// |                           | COLVAL 2.1 | COLVAL 2.2 | COLVAL 2.1 |           |
		// +-------------+-------------+------------+------------+------------+-----------+
		// | GROUP FIELD | GROUP FIELD |                                      | GROUP AGG |
		// +-------------+-------------+--------------------------------------+-----------+
		//  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

		var displayRowVals = function (tr, pivotFieldNum, displayOrderIndex) {
			underscore.each(data.groupFields, function (field, fieldIdx) {
				var fcc = self.colConfig.get(field) || {};
				span = jQuery('<span>').addClass('wcdv_heading_title').text(fcc.displayText || field);
				self.csv.addCol(fcc.displayText || field);

				headingThControls = jQuery('<div>');

				headingThContainer = jQuery('<div>')
					.addClass('wcdv_heading_container')
					.append(span, headingThControls);

				th = jQuery('<th>')
					.attr({
						'data-wcdv-field': field,
						'data-wcdv-draggable-origin': 'GRID_TABLE_HEADER'
					})
					.append(headingThContainer)
					._makeDraggableField();

				self._addSortingToHeader(data, 'vertical', {groupFieldIndex: fieldIdx}, headingThControls.get(0), getPropDef([], data, 'agg', 'info', 'cell'));

				self.setCss(th, field);

				self.ui.thMap[field] = th;
				tr.append(th);
			});
		};

		//  ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
		// +---------------------------+--------------------------------------+-----------+
		// |                           | COLVAL 1.1              | COLVAL 1.2 |           |
		// +---------------------------+------------+------------+------------+-----------+
		// |                           | COLVAL 2.1 | COLVAL 2.2 | COLVAL 2.1 |           |
		// +-------------+-------------+------------+------------+------------+-----------+
		// | GROUP FIELD | GROUP FIELD |                                      | GROUP AGG |
		// +-------------+-------------+--------------------------------------+-----------+

		var displayRowVals_padding = function (tr) {
			if (data.groupFields.length > 1) {
				tr.append(jQuery('<th>', { colspan: data.groupFields.length - 1 }));
				for (var i = 0; i < data.groupFields.length - 1; i += 1) {
					self.csv.addCol('');
				}
			}
		};

		//                ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
		// +-------------+-------------+--------------------------------------+-----------+
		// |             | PIVOT FIELD | COLVAL 1.1              | COLVAL 1.2 |           |
		// +-------------+-------------+------------+------------+------------+-----------+
		// |             | PIVOT FIELD | COLVAL 2.1 | COLVAL 2.2 | COLVAL 2.1 |           |
		// +-------------+-------------+------------+------------+------------+-----------+
		// | GROUP FIELD | GROUP FIELD |                                      | GROUP AGG |
		// +-------------+-------------+--------------------------------------+-----------+

		var displayCells = function (tr, pivotFieldIdx, displayOrderIndex) {
			var colVal, colValIndex;
			var ai = self._getAggInfo(data);
			// Indicates that we're on the last pivot field, i.e. the last row of the table header.
			var isLastPivotField = pivotFieldIdx === data.pivotFields.length - 1;
			var pivotField = data.pivotFields[pivotFieldIdx];

			var fcc = self.colConfig.get(pivotField) || {};
			var pivotSpec = data.pivotSpec[pivotFieldIdx];
			var fti = self.typeInfo.get(pivotField);

			if (pivotSpec.fun != null) {
				fti = {
					type: GROUP_FUNCTION_REGISTRY.get(pivotSpec.fun).resultType
				};
			}

			var span = jQuery('<span>').addClass('wcdv_heading_title').text(fcc.displayText || pivotField);
			self.csv.addCol(fcc.displayText || pivotField);

			var headingThControls = jQuery('<div>');

			var headingThContainer = jQuery('<div>')
				.addClass('wcdv_heading_container')
				.append(span, headingThControls);

			var th = jQuery('<th>')
				.attr({
					'data-wcdv-field': pivotField,
					'data-wcdv-draggable-origin': 'GRID_TABLE_HEADER'
				})
				.append(headingThContainer)
				._makeDraggableField();

			self._addSortingToHeader(data, 'horizontal', {pivotFieldIndex: pivotFieldIdx}, headingThControls.get(0), getPropDef([], data, 'agg', 'info', 'cell'));

			self.setCss(th, pivotField);

			self.ui.thMap[pivotField] = th;
			tr.append(th);

			// Create headers for the fields that we've pivotted by.  The headers are the column values for
			// those fields.
			//
			// +--------------------------------------------------+----------------+
			// | PIVOT COLVAL 1                                   | PIVOT COLVAL 2 | < PIVOT FIELD #1
			// +----------------+----------------+----------------+----------------+
			// | PIVOT COLVAL A | PIVOT COLVAL B | PIVOT COLVAL C | PIVOT COLVAL A | < PIVOT FIELD #2
			// +----------------+----------------+----------------+----------------+
			//
			// Col Vals = [[1,A], [1,B], [2,A]]
			//
			// When rendering the headers for Pivot Field #1, we go through the col vals and find that "1"
			// is repeated three times.  We don't make a cell for each one, instead we just increment
			// lastColValCount.  When the col val changes to "2", we set the colspan on the previous cell to
			// be however many of that col val we found.

			var lastColVal = null;
			var lastColValCount = 0;

			for (colValIndex = 0; colValIndex < data.colVals.length; colValIndex += 1) {
				colVal = data.colVals[colValIndex][pivotFieldIdx];
				colVal = format(self.colConfig.get(pivotField), fti, colVal);

				if (colVal !== lastColVal || isLastPivotField) {
					if (lastColVal !== null) {
						// The we've hit a different colVal so count up how many of the last one we had to
						// determine the column span.  In the above example, there are three "Kennedy" and two
						// "Roosevelt" so those are the colspans that we would set.

						var colSpan = lastColValCount;

						if (ai.cell.length >= 2) {
							colSpan *= ai.cell.length;
						}

						th.attr('colspan', colSpan);
						tr.append(th);

						for (var i = 0; i < colSpan - 1; i += 1) {
							self.csv.addCol('');
						}
					}

					// Update the tracking information and reset the counter to one.

					lastColVal = colVal;
					lastColValCount = 1;

					span = jQuery('<span>').addClass('wcdv_heading_title');
					setElement(span, colVal, {
						field: pivotField,
						colConfig: fcc,
						typeInfo: fti
					});
					self.csv.addCol(span.text());

					headingThControls = jQuery('<div>');

					headingThContainer = jQuery('<div>')
						.addClass('wcdv_heading_container')
						.append(span, headingThControls);

					th = jQuery('<th>')
						.append(headingThContainer);

					self.setCss(th, colVal);

					// We only allow sorting on the final

					if (isLastPivotField) {
						self._addSortingToHeader(data, 'vertical', {colVal: data.colVals[colValIndex], aggNum: 0}, headingThControls.get(0), getPropDef([], data, 'agg', 'info', 'cell'));
					}

					if (ai.cell.length === 1) {
						aggInfo = data.agg.info.cell[0];
						self.setAlignment(th, aggInfo.colConfig[0], aggInfo.typeInfo[0], aggInfo.instance.getType());
					}
					else if (ai.cell.length > 1) {
						self.setAlignment(th, null, null, null, 'center');
					}

					if (self.opts.drawInternalBorders || ai.cell.length > 1) {
						th.addClass('wcdv_pivot_colval_boundary');
					}
				}
				else {
					lastColValCount += 1;
				}
			}

			// Same logic as when the colVal changes.

			var colSpan = lastColValCount;

			if (ai.cell.length >= 2) {
				colSpan *= ai.cell.length;
			}

			if (th != null) {
				th.attr('colspan', colSpan);
				tr.append(th);
			}

			for (i = 0; i < colSpan - 1; i += 1) {
				self.csv.addCol('');
			}
		};

		// +---------------------------+--------------------------------------+-----------+
		// |                           | COLVAL 1.1              | COLVAL 1.2 |           |
		// +---------------------------+------------+------------+------------+-----------+
		// |                           | COLVAL 2.1 | COLVAL 2.2 | COLVAL 2.1 |           |
		// +-------------+-------------+------------+------------+------------+-----------+
		// | GROUP FIELD | GROUP FIELD |                                      | GROUP AGG |
		// +-------------+-------------+--------------------------------------+-----------+
		//                              ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

		var displayCells_padding = function (tr) {
			var ai = self._getAggInfo(data);
			var hr = jQuery('<hr>', {
				class: 'wcdv_hr_gradient'
			});
			var div = jQuery('<div>&nbsp;</div>');
			var th = jQuery('<th>', {
				class: 'wcdv_pivot_colval_boundary wcdv_cell_empty',
				colspan: data.colVals.length * Math.max(ai.cell.length, 1)
			});
			//hr.appendTo(th);
			div.appendTo(th);
			th.appendTo(tr);
			for (var i = 0; i < data.colVals.length * Math.max(ai.cell.length, 1); i += 1) {
				self.csv.addCol('');
			}
		};

		//                                                                     ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
		// +---------------------------+--------------------------------------+----------------------+
		// |                           | COLVAL 1.1              | COLVAL 1.2 |                      |
		// +---------------------------+------------+------------+------------+----------------------+
		// |                           | COLVAL 2.1 | COLVAL 2.2 | COLVAL 2.1 |                      |
		// +-------------+-------------+------------+------------+------------+-----------+----------+
		// | GROUP FIELD | GROUP FIELD |                                      | GROUP AGG | ADD COLS |
		// +-------------+-------------+--------------------------------------+-----------+----------+

		var displayGroupAggregates_padding = function (tr, displayOrderIndex, displayOrderMax) {
			var numExtraCols = getPropDef(0, data, 'agg', 'info', 'group', 'length')
				+ getPropDef(0, self.opts, 'addCols', 'length');
			if (numExtraCols > 0) {
				var th = jQuery('<th>', { colspan: numExtraCols });
				if (displayOrderIndex > 0) {
					th.addClass('wcdv_bld'); // border-left: double
				}
				if (displayOrderIndex < displayOrderMax - 1) {
					th.addClass('wcdv_brd'); // border-right: double
				}
				tr.append(th);
			}
		};

		// +---------------------------+--------------------------------------+-----------+
		// |                           | COLVAL 1.1              | COLVAL 1.2 |           |
		// +---------------------------+------------+------------+------------+-----------+
		// |                           | COLVAL 2.1 | COLVAL 2.2 | COLVAL 2.1 |           |
		// +-------------+-------------+------------+------------+------------+-----------+
		// | GROUP FIELD | GROUP FIELD |                                      | GROUP AGG |
		// +-------------+-------------+--------------------------------------+-----------+
		//                                                                     ↑↑↑↑↑↑↑↑↑↑↑

		var displayGroupAggregates = function (tr, displayOrderIndex, displayOrderMax) {
				self.drawHeader_aggregates(data, tr, displayOrderIndex, displayOrderMax);
				self.drawHeader_addCols(tr, typeInfo, opts);
		};

		// This produces separate rows in the header for each pivot field.  That's what allows you to
		// see the combinations of column values, like this:
		//
		// Example
		// -------
		//
		//   pivotFields = ["Last Name", "First Name"]
		//   colVals = [["Kennedy", "John"], ["Kennedy", "Robert"], ["Kennedy", "Ted"],
		//              ["Roosevelt", "Franklin"], ["Roosevelt", "Teddy"]]
		//
		// +---------------------+------------------+
		// | Kennedy             | Roosevelt        |
		// +------+--------+-----+----------+-------+
		// | John | Robert | Ted | Franklin | Teddy |
		// +------+--------+-----+----------+-------+

		for (var pivotFieldIdx = 0; pivotFieldIdx < data.pivotFields.length; pivotFieldIdx += 1) {
			self.csv.addRow();
			tr = jQuery('<tr>');
			underscore.each(self.opts.displayOrder, function (what, displayOrderIndex) {
				if (typeof what === 'string') {
					switch (what) {
					case 'rowVals':
						displayRowVals_padding(tr);
						break;
					case 'cells':
						displayCells(tr, pivotFieldIdx);
						break;
					case 'groupAggregates':
						displayGroupAggregates_padding(tr, displayOrderIndex, self.opts.displayOrder.length);
						break;
					}
				}
			});
			tr.appendTo(self.ui.thead);
		}

		self.csv.addRow();
		tr = jQuery('<tr>');
		underscore.each(self.opts.displayOrder, function (what, displayOrderIndex) {
			if (typeof what === 'string') {
				switch (what) {
				case 'rowVals':
					displayRowVals(tr);
					break;
				case 'cells':
					displayCells_padding(tr);
					break;
				case 'groupAggregates':
					displayGroupAggregates(tr, displayOrderIndex, self.opts.displayOrder.length);
					break;
				}
			}
		});
		tr.appendTo(self.ui.thead);
	};

	// #drawBody {{{2

	GridTablePivot.prototype.drawBody = function (data, typeInfo, columns, cont, opts) {
		var self = this;

		var aggType
			;

		opts = opts || {};
		opts.pivotConfig = opts.pivotConfig || {};

		var ai = self._getAggInfo(data);

		if (data.groupFields.length === 0) {
			if (typeof cont === 'function') {
				return cont();
			}
			else {
				return;
			}
		}

		self._setupFullValueWin(data);

		underscore.each(data.data, function (rowGroup, groupNum) {
			self.csv.addRow();

			var tr = document.createElement('tr');
			tr.setAttribute('data-rowval-index', groupNum);

			underscore.each(self.opts.displayOrder, function (what, displayOrderIndex) {
				if (typeof what === 'string') {
					switch (what) {
					case 'rowVals':
						self.drawBody_rowVals(data, tr, groupNum);
						break;
					case 'cells':
						var rowAgg = [];

						// Create the cells that show the result of the aggregate function for all rows matching the
						// column values at the same index.
						//
						// EXAMPLE
						// -------
						//
						//   pivotFields = ["State"]
						//   colVals = ["IL", "IN", "MI", "OH"]
						//
						// Column #1: agg(rowGroup[0]) - rows in the group w/ State = "IL"
						// Column #2: agg(rowGroup[1]) - rows in the group w/ State = "IN"
						// Column #3: agg(rowGroup[2]) - rows in the group w/ State = "MI"
						// Column #4: agg(rowGroup[3]) - rows in the group w/ State = "OH"

						underscore.each(rowGroup, function (colGroup, pivotNum) {
							if (ai.cell.length === 0) {
								// There's no cell aggregate functions, so there isn't anything to put in the cell.
								tr.appendChild(document.createElement('td'));
							}
							else {
								// Every cell aggregate function is going to make a separate cell.
								underscore.each(ai.cell, function (aggInfo, aiCellIndex) {
									var aggNum = aggInfo.aggNum;
									var aggType = aggInfo.instance.getType();
									var agg = data.agg.results.cell[aggNum];
									var aggResult = agg[groupNum][pivotNum];

									var td = document.createElement('td');
									td.classList.add('wcdv_pivot_cell');
									td.setAttribute('data-rowval-index', groupNum);
									td.setAttribute('data-colval-index', pivotNum);
									td.setAttribute('data-wcdv-agg-scope', 'cell');
									td.setAttribute('data-wcdv-agg-num', aggInfo.aggNum);

									rowAgg.push(aggResult);

									var text;

									if (aggResult instanceof jQuery) {
										aggResult = aggResult.get(0);
									}

									if (aggResult instanceof Element) {
										td.appendChild(aggResult);
										self.csv.addCol(aggResult.innerText);
									}
									else {
										if (aggInfo.instance.inheritFormatting) {
											text = format(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
												overrideType: aggType
											});
											setTableCell(td, text, {
												field: aggInfo.fields[0],
												colConfig: aggInfo.colConfig[0],
												typeInfo: aggInfo.typeInfo[0]
											});
										}
										else {
											text = format(null, null, aggResult, {
												overrideType: aggType,
												convert: false
											});
											setTableCell(td, text);
										}
										self.csv.addCol(td.innerText);
									}

									if (underscore.every(data.groupSpec, function (gs) { return gs.fun == null; })
											&& underscore.every(data.pivotSpec, function (ps) { return ps.fun == null; })) {
										self._addDrillDownClass(td);
									}

									if ((self.opts.drawInternalBorders || ai.cell.length > 1) && aiCellIndex === 0) {
										td.classList.add('wcdv_pivot_colval_boundary');
									}

									// REMOVED: How do we let the user set sizes &c. when doing a pivot table?
									// self.setCss(td, col);

									self.setAlignment(td, aggInfo.colConfig[0], aggInfo.typeInfo[0], aggType);

									tr.appendChild(td);
								});
							}
						});
						break;
					case 'groupAggregates':
						self.drawBody_groupAggregates(data, tr, groupNum, displayOrderIndex, self.opts.displayOrder.length);
						break;
					case 'addCols':
						// Generate the user's custom-defined additional columns.  If the `value` function returns an
						// Element or jQuery instance, we just put that in the <TD> that we make.  Otherwise (e.g. it
						// returns a string or number) we format it according to the type of the field that the pivot
						// function was operating on.
						//
						// EXAMPLE:
						//
						// Aggregate Function = sum
						// Aggregate Field    = Amount : number -> $0,0.00
						//
						// If the `value` function adds up the sums, yielding a grand total of them all, then we format
						// that using Numeral exactly as specified for the "Amount" field.

						underscore.each(self.opts.addCols, function (addCol) {
							var addColResult = addCol.value(data.data, groupNum, rowAgg, aggType);
							var td = document.createElement('td');
							var addColText;

							if (addColResult instanceof jQuery) {
								addColResult = addColResult.get(0);
							}

							if (addColResult instanceof Element) {
								td.appendChild(addColResult);
								self.csv.addCol(addColResult.innerText);
							}
							else {
								{
									addColText = format(null, null, addColResult, {
										alwaysFormat: true,
										convert: false
									});
								}
								td.innerText = addColText;
								self.csv.addCol(addColText);
							}

							if (getProp(opts, 'pivotConfig', 'aggField')) {
								self.setAlignment(td, self.colConfig.get(opts.pivotConfig.aggField), typeInfo.get(opts.pivotConfig.aggField));
							}

							tr.appendChild(td);
						});
						break;
					}
				}
			});

			self.ui.tbody.append(tr);
		});

		// ===========================================================================
		//  PIVOT AGGREGATES
		// ===========================================================================

		underscore.each(ai.pivot, function (aggInfo, aiPivotIndex) {
			var span,
				text,
				aggNum = aggInfo.aggNum,
				aggResult,
				headingThControls,
				headingThContainer,
				th,
				tr,
				td;

			tr = jQuery('<tr>');
			self.csv.addRow();

			// Add a class to the first row so it gets the double-bar outline.

			if (aiPivotIndex === 0) {
				tr.addClass('wcdv_btd'); // border-top: double
			}

			underscore.each(self.opts.displayOrder, function (what) {
				if (typeof what === 'string') {
					switch (what) {
					case 'rowVals':

						// Insert the name of the aggregate function in the header.  This will take up as many columns
						// as there are group fields.

						if (data.groupFields.length > 1) {
							for (i = 0; i < data.groupFields.length - 1; i += 1) {
								self.csv.addCol('');
							}
						}

						self.csv.addCol(aggInfo.instance.getFullName());
						span = jQuery('<span>').addClass('wcdv_heading_title').text(aggInfo.instance.getFullName());

						headingThControls = jQuery('<div>');

						headingThContainer = jQuery('<div>')
							.addClass('wcdv_heading_container')
							.append(span, headingThControls);

						th = jQuery('<th>')
							.attr({'colspan': data.groupFields.length})
							.append(headingThContainer)
							.appendTo(tr);

						// Add sorting to the header we just created.

						self._addSortingToHeader(data, 'horizontal', {aggType: 'pivot', aggNum: aggNum}, headingThControls.get(0), getPropDef([], data, 'agg', 'info', 'cell'));

						break;
					case 'cells':
						underscore.each(data.colVals, function (colVal, colValIdx) {
							// Add padding cells in the CSV output so that the pivot aggregates appear staggered.  Since
							// we can't do rowspan in CSV like we can in HTML.

							for (var i = 0; i < aiPivotIndex; i += 1) {
								self.csv.addCol('');
							}

							var td = jQuery('<td>').attr({
								'data-colval-index': colValIdx
							});
							td.attr('data-wcdv-agg-scope', 'pivot');
							td.attr('data-wcdv-agg-num', aggInfo.aggNum);
							var aggResult = data.agg.results.pivot[aggNum][colValIdx];

							if (isElement(aggResult)) {
								td.append(aggResult);
								self.csv.addCol(getElement(aggResult).innerText);
							}
							else {
								if (aggInfo.instance.inheritFormatting) {
									text = format(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
										overrideType: aggInfo.instance.getType()
									});
									setTableCell(td, text, {
										field: aggInfo.fields[0],
										colConfig: aggInfo.colConfig[0],
										typeInfo: aggInfo.typeInfo[0]
									});
								}
								else {
									text = format(null, null, aggResult, {
										overrideType: aggInfo.instance.getType(),
										convert: false
									});
									setTableCell(td, text);
								}
								self.csv.addCol(td.text());
							}

							if (underscore.every(data.pivotSpec, function (ps) { return ps.fun == null; })) {
								self._addDrillDownClass(td.get(0));
							}

							if (ai.cell.length > 1) {
								td.attr('colspan', ai.cell.length);
							}

							if (self.opts.drawInternalBorders || ai.cell.length > 1) {
								td.addClass('wcdv_pivot_colval_boundary');
							}

							self.setAlignment(td, aggInfo.colConfig[0], aggInfo.typeInfo[0], aggInfo.instance.getType());
							td.appendTo(tr);

							// Add padding cells in the CSV output so that the pivot aggregates appear staggered.  Since
							// we can't do rowspan in CSV like we can in HTML.

							for (i = aiPivotIndex + 1; i < ai.pivot.length; i += 1) {
								self.csv.addCol('');
							}
						});
						break;
					case 'groupAggregates':

						// =========================================================================
						//  ALL AGGREGATES
						// =========================================================================

						if (getProp(data, 'agg', 'info', 'all', aggNum)) {
							for (i = 0; i < aiPivotIndex; i += 1) {
								td = jQuery('<td><div>&nbsp;</div></td>');
								if (self.opts.drawInternalBorders || ai.cell.length > 1) {
									td.addClass(i === 0 ? 'wcdv_pivot_aggregate_boundary' : 'wcdv_pivot_colval_boundary');
								}
								td.addClass('wcdv_cell_empty');
								self.csv.addCol('');
								td.appendTo(tr);
							}

							aggInfo = data.agg.info.all[aggNum];
							aggResult = data.agg.results.all[aggNum];
							td = jQuery('<td>');
							td.attr('data-wcdv-agg-scope', 'all');
							td.attr('data-wcdv-agg-num', aggInfo.aggNum);

							if (isElement(aggResult)) {
								td.append(aggResult);
								self.csv.addCol(getElement(aggResult).innerText);
							}
							else {
								if (aggInfo.instance.inheritFormatting) {
									text = format(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
										overrideType: aggInfo.instance.getType()
									});
									setTableCell(td, text, {
										field: aggInfo.fields[0],
										colConfig: aggInfo.colConfig[0],
										typeInfo: aggInfo.typeInfo[0]
									});
								}
								else {
									text = format(null, null, aggResult, {
										overrideType: aggInfo.instance.getType(),
										convert: false
									});
									setTableCell(td, text);
								}
								self.csv.addCol(td.text());
							}

							if (self.opts.drawInternalBorders || ai.cell.length > 1) {
								td.addClass(aiPivotIndex === 0 ? 'wcdv_pivot_aggregate_boundary' : 'wcdv_pivot_colval_boundary');
							}

							self.setAlignment(td, aggInfo.colConfig[0], aggInfo.typeInfo[0], aggInfo.instance.getType());
							td.appendTo(tr);

							for (var i = aiPivotIndex + 1; i < ai.cell.length; i += 1) {
								td = jQuery('<td><div>&nbsp;</div></td>');
								if (self.opts.drawInternalBorders || ai.cell.length > 1) {
									td.addClass('wcdv_pivot_colval_boundary');
								}
								td.addClass('wcdv_cell_empty');
								self.csv.addCol('');
								td.appendTo(tr);
							}
						}
						break;
					}
				}
			});

			tr.appendTo(self.ui.tbody);
		});

		self.fire('csvReady');

		if (typeof cont === 'function') {
			return cont();
		}
	};

	// #addWorkHandler {{{2

	GridTablePivot.prototype.addWorkHandler = function () {
		var self = this;

		self.view.on(View.events.workEnd, function (info, ops) {
			debug.info('GRID TABLE - PIVOT // HANDLER (View.workEnd)', 'View has finished doing work');

			if (!ops.pivot) {
				debug.info('GRID TABLE - PIVOT // HANDLER (View.workEnd)', 'Unable to render this data: %O', ops);
				self.fire('unableToRender', null, ops);
				return;
			}

			debug.info('GRID TABLE - PIVOT // HANDLER (View.workEnd)', 'Redrawing because the view has done work');
			self.draw(self.root);
		}, { who: self });
	};

	// Registry {{{1

	GridRenderer.registry.set('table_plain', GridTablePlain);
	GridRenderer.registry.set('table_group_detail', GridTableGroupDetail);
	GridRenderer.registry.set('table_group_summary', GridTableGroupSummary);
	GridRenderer.registry.set('table_pivot', GridTablePivot);

	// GridRendererHandlebars {{{1

	var GridRendererHandlebars = makeSubclass('GridRendererHandlebars', GridRenderer, function () {
		var self = this;

		self.super.ctor.apply(self, arguments);

		lib.registerHelper('rowval', function (groupField) {
			if (['number', 'string'].indexOf(typeof groupField) < 0) {
				throw new Error('In Handlebars "rowval" helper, `groupField` must be a number or string');
			}

			var groupFieldIndex;

			if (typeof groupField === 'number') {
				groupFieldIndex = groupField;

				if (groupFieldIndex < 0) {
					throw new Error('In Handlebars "rowval" helper, group field index "' + groupField + '" out of range');
				}
			}
			else {
				groupFieldIndex = self.data.groupFields.indexOf(groupField);

				if (groupFieldIndex < 0) {
					throw new Error('In Handlebars "rowval" helper, specified field "' + groupField + '" is not part of group');
				}
			}

			return self.data.rowVals[this.rowValIndex][groupFieldIndex];
		});

		lib.registerHelper('colval', function (pivotField) {
			if (['number', 'string'].indexOf(typeof pivotField) < 0) {
				throw new Error('In Handlebars "rowval" helper, `pivotField` must be a number or string');
			}

			var pivotFieldIndex;

			if (typeof pivotField === 'number') {
				pivotFieldIndex = pivotField;

				if (pivotFieldIndex < 0) {
					throw new Error('In Handlebars "rowval" helper, pivot field index "' + pivotField + '" out of range');
				}
			}
			else {
				pivotFieldIndex = self.data.pivotFields.indexOf(pivotField);

				if (pivotFieldIndex < 0) {
					throw new Error('In Handlebars "rowval" helper, specified field "' + pivotField + '" is not part of pivot');
				}
			}

			return self.data.colVals[this.colValIndex][pivotFieldIndex];
		});
	});

	// #_validateFeatures {{{2

	GridRendererHandlebars.prototype._validateFeatures = function () {
		var self = this;
		self.features.limit = false;
	};


	// #canRender {{{2

	GridRendererHandlebars.prototype.canRender = function (what) {
		return true;
	};

	// #_draw_plain {{{2

	GridRendererHandlebars.prototype._draw_plain = function (root, data, typeInfo, opts) {
		var self = this;
		var html = '';

		if (data.data.length === 0) {
			if (self.empty != null) {
				html += self.empty();
			}
		}
		else {
			if (self.before != null) {
				html += self.before();
			}

			if (self.item != null) {
				underscore.each(data.data, function (row) {
					var context = {};
					underscore.each(row.rowData, function (cell, field) {
						var fcc = self.colConfig.get(field) || {};
						var value = format(fcc, typeInfo.get(field), cell);
						if (value instanceof Element || value instanceof jQuery) {
							value = outerHtml(value);
						}
						context[field] = value;
					});
					html += self.item(context);
				});
			}

			if (self.after != null) {
				html += self.after();
			}
		}

		root.html(html);
	};

	// #_draw_group {{{2

	GridRendererHandlebars.prototype._draw_group = function (root, data, typeInfo, opts) {
		var self = this;
		var html = '';

		if (data.data.length === 0) {
			if (self.empty != null) {
				html += self.empty();
			}
		}
		else {
			if (self.before != null) {
				html += self.before();
			}

			if (self.item != null) {
				underscore.each(data.data, function (group, rowValIndex) {
					var context = {
						rowValIndex: rowValIndex
					};
					html += self.item(context);
				});
			}

			if (self.after != null) {
				html += self.after();
			}
		}

		root.html(html);
	};

	// #_draw_pivot {{{2

	GridRendererHandlebars.prototype._draw_pivot = function (root, data, typeInfo, opts) {
		var self = this;
		var html = '';

		if (data.data.length === 0) {
			if (self.empty != null) {
				html += self.empty();
			}
		}
		else {
			if (self.before != null) {
				html += self.before();
			}

			if (self.item != null) {
				underscore.each(data.data, function (group, rowValIndex) {
					underscore.each(group, function (pivot, colValIndex) {
						var div = jQuery('<div>').appendTo(root);
						var context = {
							rowValIndex: rowValIndex,
							colValIndex: colValIndex
						};
						html += self.item(context);
					});
				});
			}

			if (self.after != null) {
				html += self.after();
			}
		}

		root.html(html);
	};

	// #draw {{{2

	GridRendererHandlebars.prototype.draw = function (root, cont, opts) {
		var self = this;

		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		return self.super.draw(root, opts, function (ok, data, typeInfo) {
			if (!ok) {
				return cont();
			}

			var k1 = data.isPlain ? 'plain'
				: data.isGroup ? 'group'
				: data.isPivot ? 'pivot'
				: null;

			var configKey = data.isPlain ? 'whenPlain'
				: data.isGroup ? 'whenGroup'
				: data.isPivot ? 'whenPivot'
				: null;

			var config = self.opts[configKey] || {};

			if (config.empty != null) {
				self.empty = lib.compile(config.empty);
			}

			if (config.before != null) {
				self.before = lib.compile(config.before);
			}

			if (config.item != null) {
				self.item = lib.compile(config.item);
			}

			if (config.after != null) {
				self.after = lib.compile(config.after);
			}

			self['_draw_' + k1](root, data, typeInfo, opts);

			self.addWorkHandler();

			self.fire('renderEnd');
			self.drawLock.unlock();

			if (typeof cont === 'function') {
				return cont();
			}
		});
	};

	// #addWorkHandler {{{2

	GridRendererHandlebars.prototype.addWorkHandler = function () {
		var self = this;

		self.view.on('workEnd', function (info, ops) {
			self.draw(self.root, null, self.drawOpts);
		}, { who: self, limit: 1 });
	};

	// Registry

	GridRenderer.registry.set('handlebars', GridRendererHandlebars);

	// ColConfigWin {{{1

	var ColConfigWin = makeSubclass('ColConfigWin', Object, function (grid, colConfig) {
		var self = this;

		self.grid = grid;
		self.colConfig = colConfig;

		grid.on('colConfigUpdate', function (colConfig) {
			self.colConfig = colConfig;
		});
	});

	// #show {{{2

	ColConfigWin.prototype.show = function (posElt, onSave) {
		var self = this;

		var current = self.colConfig.clone();

		var orderWinEffect = {
			effect: 'fade',
			duration: 100
		};

		var orderWin = jQuery('<div>', { title: 'Columns' }).dialog({
			autoOpen: false,
			modal: true,
			width: 600,
			position: {
				my: 'center',
				at: 'center',
				of: window
			},
			classes: {
				"ui-dialog": "ui-corner-all wcdv_dialog",
				"ui-dialog-titlebar": "ui-corner-all",
			},
			buttons: [{
				text: 'OK',
				icon: 'ui-icon-check',
				click: function () {
					// Overwrite the "initial" configuration with one derived from the current one, based on the
					// order of the keys saved by the reordering the table rows.

					self.colConfig.clear();
					underscore.each(keys, function (k) {
						self.colConfig.set(k, current.get(k));
					});

					orderWin.dialog('close');
					onSave(self.colConfig);
				}
			}, {
				text: 'Cancel',
				icon: 'ui-icon-cancel',
				click: function () {
					orderWin.dialog('close');
				}
			}],
			show: orderWinEffect,
			hide: orderWinEffect,
			close: function () {
				orderWin.dialog('destroy');
			}
		});

		var pinnedCount = 0;

		var colTable = jQuery('<table>')
			.addClass('wcdv_colconfigwin_table')
			.appendTo(jQuery('<div>').css({
				'max-height': '40ex',
				'overflow-y': 'scroll'
			}).appendTo(orderWin));

		var colTableHeader = jQuery('<thead><th class="wcdv_bottom_border_teal">Field</th><th class="wcdv_bottom_border_teal">Display</th><th colspan="5" class="wcdv_bottom_border_teal">Options</th>')
			.appendTo(colTable);

		var keys = current.keys();

		var colTableBody = jQuery('<tbody>')
			._makeSortableTable(function (oldIndex, newIndex) {
				colTableBody.children('tr').eq(newIndex).effect('highlight', 750);
				moveArrayElement(keys, oldIndex, newIndex);
			})
			.appendTo(colTable);

		current.each(function (colConfig, field) {
			var tr, td;

			tr = jQuery('<tr>');
			td = jQuery('<td>')
				.text(field)
				.appendTo(tr);

			td = jQuery('<td>')
				.css('color', colConfig.displayText ? '#000000' : '#C0C0C0')
				.text(colConfig.displayText || field)
				.appendTo(tr);
			var displayTextTd = td;

			td = jQuery('<td>')
				.addClass('wcdv_width_1em')
				.appendTo(tr);

			var renameBtn = jQuery('<button>', {
				'type': 'button',
				'title': 'Rename column in table.'
			})
				.addClass('wcdv_icon_button')
				.append(fontAwesome('fa-pencil'))
				.on('click', function () {
					var newName = prompt('Rename field "' + field + '" to what?');

					if (newName) {
						colConfig.displayText = newName;
						displayTextTd
							.css('color', colConfig.displayText ? '#000000' : '#C0C0C0')
							.text(newName);
					}
				})
				.appendTo(td)
			;

			td = jQuery('<td>')
				.addClass('wcdv_width_1em')
				.appendTo(tr);

			var isPinnedCheckbox = jQuery('<input>', {
				'type': 'checkbox',
				'title': 'Pin column to left side of table?'
			})
				.prop('checked', getPropDef(false, colConfig, 'isPinned'))
				.on('change', function () {
					colConfig.isPinned = isPinnedCheckbox.prop('checked');
					if (colConfig.isPinned) {
						pinnedCount += 1;
					}
					else {
						pinnedCount -= 1;
					}
					if (pinnedCount > 0) {
						pinnedMsg.show();
					}
					else {
						pinnedMsg.hide();
					}
				})
				.appendTo(td)
				._makeIconCheckbox('fa-thumb-tack');

			if (getPropDef(false, colConfig, 'isPinned')) {
				pinnedCount += 1;
			}

			td = jQuery('<td>')
				.addClass('wcdv_width_1em')
				.appendTo(tr);

			var isHiddenCheckbox = jQuery('<input>', {
				'type': 'checkbox',
				'title': 'Hide column?'
			})
				.prop('disabled', !getPropDef(true, colConfig, 'canHide'))
				.prop('checked', getPropDef(false, colConfig, 'isHidden'))
				.on('change', function () {
					colConfig.isHidden = isHiddenCheckbox.prop('checked');
				})
				.appendTo(td)
				._makeIconCheckbox('fa-ban');

			td = jQuery('<td>')
				.addClass('wcdv_width_1em')
				.appendTo(tr);

			var allowHtmlCheckbox = jQuery('<input>', {
				'type': 'checkbox',
				'title': 'Allow HTML to be rendered?'
			})
				.prop('checked', getPropDef(false, colConfig, 'allowHtml'))
				.on('change', function () {
					colConfig.allowHtml = allowHtmlCheckbox.prop('checked');
				})
				.appendTo(td)
				._makeIconCheckbox('fa-code');

			/*
			td = jQuery('<td>')
				.addClass('wcdv_width_1em')
				.appendTo(tr);

			var configBtn = jQuery('<button>', {'type': 'button', 'title': 'Click to configure column'})
				.addClass('wcdv_icon_button')
				.append(fontAwesome('fa-gear'))
				.on('click', function () {
					self.showConfigWin(field);
				})
				.appendTo(td);
			*/

			td = jQuery('<td>')
				.addClass('wcdv_width_1em')
				.appendTo(tr);

			var dragButton = jQuery('<button>', {
				'type': 'button',
				'title': 'Click and drag to reorder columns'
			})
				.addClass('wcdv_icon_button drag-handle')
				.append(fontAwesome('fa-arrows-v'))
				.appendTo(td);

			tr.appendTo(colTableBody);
		});

		var pinnedMsg = jQuery('<div>')
			.addClass('wcdv_info_banner')
			.append(fontAwesome('fa-info-circle'))
			.append(' Pinned columns always appear before any others in plain (non-grouped) output, in the relative order shown below.')
			.hide()
			.appendTo(orderWin);

		if (pinnedCount > 0) {
			pinnedMsg.show();
		}

		orderWin.dialog('open');
	};

	// HandlebarsEditor {{{1

	var HandlebarsEditor = makeSubclass('HandlebarsEditor', Object, function (grid, onSave) {
		var self = this;

		var winEffect = {
			effect: 'fade',
			duration: 100
		};

		self.grid = grid;
		self.win = jQuery('<div>', { title: 'Handlebars Configuration' }).dialog({
			autoOpen: false,
			modal: true,
			width: 'auto',
			position: {
				my: 'center',
				at: 'center',
				of: window
			},
			classes: {
				"ui-dialog": "ui-corner-all wcdv_dialog",
				"ui-dialog-titlebar": "ui-corner-all",
			},
			buttons: [{
				text: 'OK',
				icon: 'ui-icon-check',
				click: function () {
					// Update the configuration of the grid.

					self.tabData.each(function (v, k) {
						underscore.each(['empty', 'before', 'item', 'after'], function (t) {
							setProp(v.inputs[t].val(), self.grid.defn, 'rendererOpts', k, t);
						});
					});

					self.win.dialog('close');
					if (typeof onSave === 'function') {
						onSave();
					}
				}
			}, {
				text: 'Cancel',
				icon: 'ui-icon-cancel',
				click: function () {
					self.win.dialog('close');
					if (typeof onCancel === 'function') {
						onCancel();
					}
				}
			}],
			show: winEffect,
			hide: winEffect,
		});

		// Tabs {{{2

		var makeTab = function (name, displayName) {
			var inputs = {};
			var labels = {};

			var li = jQuery('<li>').append(jQuery('<a>', {href: '#wcdv_hbe_' + name}).text(displayName));
			var div = jQuery('<div>', {id: 'wcdv_hbe_' + name});

			underscore.each([
				{id: 'empty', label: 'Empty', rows: 4},
				{id: 'before', label: 'Before', rows: 4},
				{id: 'item', label: 'Item', rows: 8},
				{id: 'after', label: 'After', rows: 4}
			], function (x) {
				labels[x.id] = jQuery('<label>', {
					for: 'wcdv_hbe_' + name + '_' + x.id
				})
					.css('display', 'block')
					.text(x.label + ':');
				inputs[x.id] = jQuery('<textarea>', {
					id: 'wcdv_hbe_' + name + '_' + x.id,
					rows: x.rows,
					cols: 80
				})
					.css('font-family', 'monospace');
				div.append(labels[x.id]);
				div.append(inputs[x.id]);
			});

			return { li: li, div: div, inputs: inputs };
		};

		self.tabData = new OrdMap();
		self.tabData.set('whenPlain', makeTab('whenPlain', 'Plain'));
		self.tabData.set('whenGroup', makeTab('whenGroup', 'Grouped'));
		self.tabData.set('whenPivot', makeTab('whenPivot', 'Pivotted'));

		var tabs = jQuery('<div>').appendTo(self.win);
		var ul = jQuery('<ul>').appendTo(tabs);
		self.tabData.each(function (x) {
			ul.append(x.li);
			tabs.append(x.div);
		});
		tabs.tabs();
	});

	// #show {{{2

	HandlebarsEditor.prototype.show = function () {
		var self = this;

		// Setup the values of each textarea.

		self.tabData.each(function (v, k) {
			var config = getProp(self.grid.defn, 'rendererOpts', k);
			if (config != null) {
				underscore.each(['empty', 'before', 'item', 'after'], function (t) {
					v.inputs[t].val(config[t]);
				});
			}
		});

		self.win.dialog('open');
	};

	// ToolbarSection {{{1

	var ToolbarSection = makeSubclass('ToolbarSection', Object, function () {
		var self = this;

		self.ui = {};
		self.ui.root = jQuery('<div>');
	});

	// #attach {{{2

	ToolbarSection.prototype.attach = function (parent) {
		var self = this;
		self.ui.root.appendTo(parent);
	};

	// #detach {{{2

	ToolbarSection.prototype.detach = function () {
		var self = this;
		self.ui.root.remove();
	};

	// #show {{{2

	ToolbarSection.prototype.show = function () {
		var self = this;
		self.update();
		self.ui.root.show();
	};

	// #hide {{{2

	ToolbarSection.prototype.hide = function () {
		var self = this;
		self.ui.root.hide();
	};

	// #update {{{2

	ToolbarSection.prototype.update = function () {
		// Do nothing.
	};

	// PlainToolbar {{{1

	var PlainToolbar = makeSubclass('PlainToolbar', ToolbarSection, function (grid) {
		var self = this;

		self.super.ctor.apply(self, []);
		self.ui.root.addClass('wcdv_toolbar_section');

		self.grid = grid;

		grid.ui.limit_div = jQuery('<div>').css({'display': 'inline-block'}).appendTo(self.ui.root);

		// Create a checkbox that will toggle the "automatically show more" feature for the grid table.

		self.ui.autoShowMore = makeToggleCheckbox(
			grid.defn,
			['table', 'limit', 'autoShowMore'],
			true,
			'Show More on Scroll',
			grid.ui.limit_div
		);

		// Create a button that will show all the rows when clicked.  We fake this a little bit by just
		// turning off the "limit" feature and letting the grid table be redrawn (changing the features
		// causes it to be redrawn).
		//
		// TODO: This should disable the "automatically show more" checkbox (need to make sure it gets
		// re-enabled if we switch grid tables and come back - as "limit" feature will be reset to its
		// default value).

		jQuery('<button>', {'type': 'button'})
			.on('click', function (evt) {
				grid.renderer.updateFeatures({
					'block': true,
					'progress': true,
					'limit': false
				});
			})
			.text('Show All Rows')
			.appendTo(grid.ui.limit_div)
		;

		self.ui.columnConfig = jQuery('<button>', {
			'type': 'button'
		})
			.append(fontAwesome('fa-columns'))
			.append('Columns')
			.on('click', function (evt) {
				grid.colConfigWin.show(grid.ui.controls, function (colConfig) {
					grid.setColConfig(colConfig, {
						from: 'ui'
					});
				});
			})
			.appendTo(self.ui.root)
		;

		self.ui.handlebarsEditor = jQuery('<button>', {
			'type': 'button'
		})
			.append(fontAwesome('fa-pencil'))
			.append('Handlebars Editor')
			.on('click', function (evt) {
				grid.handlebarsEditor.show();
			})
			.appendTo(self.ui.root)
		;
	});

	// #update {{{2

	PlainToolbar.prototype.update = function () {
		var self = this;

		if (self.grid.renderer.features.limit) {
			self.grid.ui.limit_div.show();
			self.ui.autoShowMore.show();
		}
		else {
			self.grid.ui.limit_div.hide();
			self.ui.autoShowMore.hide();
		}

		switch (self.grid.rendererName) {
		case 'table':
			self.ui.columnConfig.show();
			self.ui.handlebarsEditor.hide();
			break;
		case 'handlebars':
			self.ui.columnConfig.hide();
			self.ui.handlebarsEditor.show();
			break;
		}
	};

	// GroupToolbar {{{1

	var GroupToolbar = makeSubclass('GroupToolbar', ToolbarSection, function (grid) {
		var self = this;

		self.super.ctor.apply(self, []);
		self.ui.root.addClass('wcdv_toolbar_section');

		self.grid = grid;

		var aggSpec;

		grid.view.on('aggregateSet', function (a) {
			aggSpec = deepCopy(a);
		});

		var enableDisable = function (selected) {
			switch (selected) {
			case 'summary':
				self.ui.showTotalRow.prop('disabled', false);
				self.ui.pinRowVals.prop('disabled', false);
				self.ui.columnConfig.prop('disabled', true);
				break;
			case 'detail':
				self.ui.showTotalRow.prop('disabled', true);
				self.ui.pinRowVals.prop('disabled', true);
				self.ui.columnConfig.prop('disabled', false);
				break;
			}
		};

		// Create radio buttons to switch between summary and detail group grid tables.

		self.ui.groupMode = makeRadioButtons(
			grid.defn
			, ['table', 'groupMode']
			, 'detail'
			, null
			, 'groupOutput'
			, [{label: 'Summary', value: 'summary'}
				, {label: 'Detail', value: 'detail'}]
			, null
			, function (selected) {
				enableDisable(selected);
				grid.redraw();
			}
			, self.ui.root
		);

		self.ui.showTotalRow = makeToggleCheckbox(
			grid.defn,
			['table', 'whenGroup', 'showTotalRow'],
			true,
			'Total Row',
			self.ui.root,
			function (isChecked) {
				var agg = grid.view.getAggregate();

				if (!isChecked) {
					aggSpec = deepCopy(agg);
					delete agg.all;
				}
				else {
					agg.all = aggSpec.all;
				}

				grid.view.setAggregate(agg, {
					sendEvent: false
				});
			}
		);

		self.ui.pinRowVals = makeToggleCheckbox(
			grid.defn,
			['table', 'whenGroup', 'pinRowvals'],
			false,
			'Pin Groups',
			self.ui.root,
			function (isChecked) {
				grid.redraw();
			}
		);

		self.ui.columnConfig = jQuery('<button>', {
			'type': 'button'
		})
			.append(fontAwesome('fa-columns'))
			.append('Columns')
			.on('click', function (evt) {
				grid.colConfigWin.show(grid.ui.controls, function (colConfig) {
					grid.setColConfig(colConfig, {
						from: 'ui'
					});
				});
			})
			.appendTo(self.ui.root)
		;

		self.ui.handlebarsEditor = jQuery('<button>', {
			'type': 'button'
		})
			.append(fontAwesome('fa-pencil'))
			.append('Handlebars Editor')
			.on('click', function (evt) {
				grid.handlebarsEditor.show();
			})
			.appendTo(self.ui.root)
		;

		enableDisable(grid.defn.table.groupMode);
	});

	// #update {{{2

	GroupToolbar.prototype.update = function () {
		var self = this;

		switch (self.grid.rendererName) {
		case 'table':
			self.ui.groupMode.show();
			self.ui.showTotalRow.show();
			self.ui.pinRowVals.show();
			self.ui.columnConfig.show();
			self.ui.handlebarsEditor.hide();
			break;
		case 'handlebars':
			self.ui.groupMode.hide();
			self.ui.showTotalRow.hide();
			self.ui.pinRowVals.hide();
			self.ui.columnConfig.hide();
			self.ui.handlebarsEditor.show();
			break;
		}
	};

	// PivotToolbar {{{1

	var PivotToolbar = makeSubclass('PivotToolbar', ToolbarSection, function (grid) {
		var self = this;

		self.super.ctor.apply(self, []);
		self.ui.root.addClass('wcdv_toolbar_section');

		self.grid = grid;

		var aggSpec;

		grid.view.on('aggregateSet', function (a) {
			aggSpec = deepCopy(a);
		});

		self.ui.showTotals = makeToggleCheckbox(
			grid.defn,
			['table', 'whenPivot', 'showTotalCol'],
			true,
			'Total Row/Column',
			self.ui.root,
			function (isChecked) {
				var agg = grid.view.getAggregate();

				if (!isChecked) {
					aggSpec = deepCopy(agg);
					delete agg.group;
					delete agg.pivot;
					delete agg.all;
				}
				else {
					agg.group = aggSpec.group;
					agg.pivot = aggSpec.pivot;
					agg.all = aggSpec.all;
				}

				grid.view.setAggregate(agg, {
					sendEvent: false
				});
			}
		);

		self.ui.pinRowVals = makeToggleCheckbox(
			grid.defn,
			['table', 'whenGroup', 'pinRowvals'],
			false,
			'Pin Groups',
			self.ui.root,
			function (isChecked) {
				grid.redraw();
			}
		);

		self.ui.handlebarsEditor = jQuery('<button>', {
			'type': 'button'
		})
			.append(fontAwesome('fa-pencil'))
			.append('Handlebars Editor')
			.on('click', function (evt) {
				grid.handlebarsEditor.show();
			})
			.appendTo(self.ui.root)
		;
	});

	// #update {{{2

	PivotToolbar.prototype.update = function () {
		var self = this;

		switch (self.grid.rendererName) {
		case 'table':
			self.ui.showTotals.show();
			self.ui.pinRowVals.show();
			self.ui.handlebarsEditor.hide();
			break;
		case 'handlebars':
			self.ui.showTotals.hide();
			self.ui.pinRowVals.hide();
			self.ui.handlebarsEditor.show();
			break;
		}
	};

	// PrefsToolbar {{{1

	var PrefsToolbar = makeSubclass('PrefsToolbar', ToolbarSection, function (grid) {
		var self = this;

		self.super.ctor.apply(self, []);
		self.ui.root.addClass('wcdv_toolbar_section');

		self.grid = grid;

		var div = jQuery('<div>')
			.addClass('wcdv_toolbar_view')
			.css({'display': 'inline-block'})
			.appendTo(self.ui.root)
		;

		var options = {};

		var showHideBtns = function () {
			var p = grid.prefs.getPerspective(dropdown.val());

			if (p == null) {
				throw new Error('No such perspective: ' + dropdown.val());
			}

			if (p.opts.isTemporary) {
				saveAsBtn.show();
			}
			else {
				saveAsBtn.hide();
			}

			if (p.opts.isEssential) {
				renameBtn.hide();
				deleteBtn.hide();
			}
			else {
				renameBtn.show();
				deleteBtn.show();
			}
		};

		// Clicking this button will reset all preferences back to the initial set (i.e. just "Main
		// Perspective" and no changes in the view from its default).  Perhaps useful when you have too
		// many different perspectives set, but I feel better having it as a safety in case your prefs
		// somehow get really messed up and don't work at all anymore.  This button is always shown.

		var resetBtn = jQuery('<button>', {'type': 'button', 'title': 'Reset'})
			.addClass('wcdv_icon_button wcdv_text-primary')
			.append(fontAwesome('fa-undo'))
			.on('click', function () {
				grid.prefs.reset();
			})
			.appendTo(div)
		;

		var backBtn = jQuery('<button>', {'type': 'button'})
			.append(fontAwesome('fa-chevron-circle-left'))
			.attr('title', 'Back')
			.attr('disabled', true)
			.addClass('wcdv_icon_button wcdv_text-primary')
			.on('click', function () {
				grid.prefs.back();
			})
			.appendTo(div)
		;

		var forwardBtn = jQuery('<button>', {'type': 'button'})
			.append(fontAwesome('fa-chevron-circle-right'))
			.attr('title', 'Forward')
			.attr('disabled', true)
			.addClass('wcdv_icon_button wcdv_text-primary')
			.on('click', function () {
				grid.prefs.forward();
			})
			.appendTo(div)
		;

		/*
		var historyBtn = jQuery(fontAwesome('fa-clock-o', 'wcdv_button', 'History'))
			.on('click', function () {
				grid.prefs._historyDebug();
			})
			.appendTo(div)
		;
		*/

		// Dropdown of all the available perspectives, plus an entry that (when selected) prompts for the
		// name of a new perspective.

		var dropdown = jQuery('<select>')
			.append(jQuery('<option>', { value: 'NEW' }).text('New Perspective...'))
			.on('change', function (evt) {
				if (dropdown.val() === 'NEW') {
					var name = prompt('Enter new perspective name', grid.prefs.currentPerspective.name);
					if (name) {
						grid.prefs.addPerspective(null, name);
						grid.prefs.save();
					}
					else {
						// User cancelled the dialog, so just put the dropdown back to whatever the current
						// perspective is.
						dropdown.val(grid.prefs.currentPerspective.id);
					}
					return;
				}

				grid.prefs.setCurrentPerspective(dropdown.val());
				showHideBtns();
			})
			.appendTo(div)
		;

		var warnMsgText = jQuery('<span>');

		var warnMsgContent = jQuery('<div>')
			.append(fontAwesome('fa-info-circle').css('padding-right', '0.25em').addClass('wcdv_text-primary'))
			.append(warnMsgText);

		var warnMsg = fontAwesome('fa-info-circle', 'wcdv_info_icon')
			.attr({'title': 'Info'})
			.hide()
			.tooltip({
				classes: {
					'ui-tooltip': 'ui-corner-all ui-widget-shadow wcdv_info_tooltip wcdv_border-primary'
				},
				show: { delay: 1000 },
				content: warnMsgContent,
			})
			.appendTo(div)
		;

		if (grid.prefs.backend instanceof PrefsBackendTemporary) {
			warnMsgText.text('The preferences system is not configured to permanently save perspectives.');
			warnMsg.show();
		}

		var saveAsBtnTooltipContent = jQuery('<div>')
			.append(fontAwesome('fa-info-circle').css('padding-right', '0.25em').addClass('wcdv_text-primary'))
			.append('This pre-defined perspective cannot be saved with this name.  Click to save with a new name.  After that, any changes will be saved under the new name.');

		var saveAsBtn = jQuery('<button>', {'type': 'button', 'title': 'Save As...'})
			.append(fontAwesome('fa-save'))
			.addClass('wcdv_icon_button wcdv_text-primary')
			.tooltip({
				classes: {
					'ui-tooltip': 'ui-corner-all ui-widget-shadow wcdv_info_tooltip wcdv_border-primary'
				},
				show: { delay: 1000 },
				content: saveAsBtnTooltipContent
			})
			.on('click', function () {
				var name = prompt('Enter new perspective name', grid.prefs.currentPerspective.name);
				if (name != null) {
					grid.prefs.addPerspective(name);
					grid.prefs.save();
				}
			})
			.appendTo(div)
		;

		var saveBtnTooltipContent = jQuery('<div>')
			.append(fontAwesome('fa-info-circle').css('padding-right', '0.25em').addClass('wcdv_text-primary'))
			.append('Click to save the current configuration.  The next time this grid is visited, the previously saved configuration will automatically be used.');

		var saveBtn = jQuery('<button>', {'type': 'button', 'title': 'Save'})
			.append(fontAwesome('fa-save'))
			.addClass('wcdv_icon_button wcdv_text-primary')
			.hide()
			.tooltip({
				classes: {
					'ui-tooltip': 'ui-corner-all ui-widget-shadow wcdv_info_tooltip wcdv_border-primary'
				},
				show: { delay: 1000 },
				content: saveBtnTooltipContent
			})
			.on('click', function () {
				grid.prefs.reallySave();
			})
			.appendTo(div)
		;

		// Clicking this button will show a prompt to rename the currently selected perspective.  If you
		// cancel the prompt, nothing will happen.  This button is only shown when the currently selected
		// perspective is not "Main Perspective" as it cannot be renamed.
		//
		// XXX: What if the user types in the name of an existing perspective?
		// XXX: What if the user types in "Main Perspective" ?
		// XXX: What if the user types in "NEW" ?

		var renameBtn = jQuery('<button>', {'type': 'button', 'title': 'Rename'})
			.addClass('wcdv_icon_button wcdv_text-primary')
			.append(fontAwesome('fa-pencil'))
			.on('click', function () {
				var id = dropdown.val();
				var p = grid.prefs.getPerspective(id);

				if (p.opts.isEssential) {
					alert('Cannot rename essential perspective!');
				}
				else {
					var newName = prompt('Rename view "' + p.name + '" to what?');
					if (newName) {
						grid.prefs.renamePerspective(id, newName);
					}
				}
			})
			.appendTo(div)
		;

		// Clicking this button will delete the currently selected perspective and switch back to "Main
		// Perspective".  It is only shown when the currently selected perspective is not "Main
		// Perspective" as it cannot be deleted.

		var deleteBtn = jQuery('<button>', {'type': 'button', 'title': 'Delete'})
			.addClass('wcdv_icon_button wcdv_text-primary')
			.append(fontAwesome('fa-trash'))
			.on('click', function () {
				grid.prefs.deletePerspective(dropdown.val());
			})
			.appendTo(div)
		;

		// Get the list of available perspectives from the Prefs instance and put them into the dropdown.
		// The initial perspective will be selected by default.  This DOES NOT actually load that
		// perspective, it's just for the UI.
		//
		// XXX: Is it possible for perspectives to change by some other route so that we need to know
		// about it to update the UI?

		setTimeout(function () {
			grid.prefs.prime(function () {
				grid.prefs.getPerspectives(function (ids) {
					underscore.each(underscore.sortBy(underscore.map(ids, function (id) {
						return grid.prefs.getPerspective(id);
					}), 'name'), function (o) {
						if (options[o.id] == null) {
							options[o.id] = jQuery('<option>', { 'value': o.id })
								.text(o.name)
								.appendTo(dropdown);
						}
					});

					dropdown.val(grid.prefs.currentPerspective.id);
					showHideBtns();
				});

				grid.prefs.on('perspectiveAdded', function (id) {
					if (options[id] == null) {
						var p = grid.prefs.getPerspective(id);
						options[id] = jQuery('<option>', { value: id })
							.text(p.name)
							.appendTo(dropdown);
					}
				}, {
					info: 'Adding new perspective to dropdown'
				});

				grid.prefs.on('perspectiveDeleted', function (id) {
					if (options[id] == null) {
						throw new Error(sprintf.sprintf('Received `perspectiveDeleted` event that references unknown perspective: id = "%s"', id));
					}
					options[id].remove();
					delete options[id];
				}, {
					info: 'Removing perspective from dropdown'
				});

				grid.prefs.on('perspectiveRenamed', function (id, newName) {
					if (options[id] == null) {
						throw new Error(sprintf.sprintf('Received `perspectiveRenamed` event that references unknown perspective: id = "%s"', id));
					}
					options[id].text(newName);
				}, {
					info: 'Changing perspective name in dropdown'
				});

				grid.prefs.on('perspectiveChanged', function (id) {
					if (options[id] == null) {
						throw new Error(sprintf.sprintf('Received `perspectiveChanged` event that references unknown perspective: id = "%s"', id));
					}
					if (grid.prefs.currentPerspective.isUnsaved) {
						saveBtn.show();
					}
					else {
						saveBtn.hide();
					}
					dropdown.val(id);
					showHideBtns();
					grid.redraw();
				}, {
					info: 'Changing dropdown to reflect new current perspective'
				});

				grid.prefs.on('prefsReset', function () {
					underscore.each(options, function (elt) {
						elt.remove();
					});
					options = {};
				}, {
					info: 'Deleting all perspectives from the dropdown'
				});

				grid.prefs.on('prefsChanged', function () {
					var cp = grid.prefs.currentPerspective;
					var o = options[cp.id];
					o.text('[*] ' + cp.name);
					saveBtn.show();
				});

				grid.prefs.on('prefsSaved', function () {
					var cp = grid.prefs.currentPerspective;
					var o = options[cp.id];
					o.text(cp.name);
					saveBtn.hide();
				});

				grid.prefs.on('prefsHistoryStatus', function (back, forward) {
					backBtn.attr('disabled', !back);
					forwardBtn.attr('disabled', !forward);
				});
			});
		});
	});

	var transTbl = {
		'en-US': {
			'SHOWHIDE': 'Show/Hide',
			'SHOWHIDEOPTS': 'Show/Hide Options'
		}
	};

	var trans = function (k) {
		var lang = navigator.language
			, tbl = transTbl[lang] || transTbl['en-US'];

		return tbl[k] || k;
	};

	// Imports {{{1

	// Grid {{{1
	// JSDoc Types {{{2

	/**
	 * @typedef {object} Grid~Defn
	 *
	 * @property {Object} table
	 *
	 * @property {string} table.id
	 *
	 * @property {Array.<Grid~ColConfig>} [table.columns]
	 * Specifies the order that fields are rendered in plain output.  If not provided, all fields are
	 * rendered in the order received from the source; fields with names starting with an underscore are
	 * not shown.  If provided, only those fields specified are rendered, and in the order indicated.
	 *
	 * @property {Grid~Features} [table.features]
	 * The features that are enabled for this grid.
	 *
	 * @property {object} [table.floatingHeader]
	 * Configuration for the "floating header" feature.
	 *
	 * @property {string} [table.floatingHeader.method]
	 * What library to use to create the floating table header.  Must be one of the following:
	 *
	 *   - `floatThead`
	 *   - `fixedHeaderTable`
	 *   - `tabletool`
	 *
	 * If this is not specified, the default is based on what library is available in the page, in the
	 * order listed above.
	 *
	 * @property {string} [table.groupMode]
	 * The starting mode for group output.  Must be one of the following:
	 *
	 *   - `summary`
	 *   - `detail`
	 *
	 * The perspective will override this.
	 *
	 * @property {object} [table.incremental]
	 * Configuration for the "incremental" feature.
	 *
	 * @property {boolean} [table.incremental.appendBodyLast=false]
	 *
	 * @property {string} [table.incremental.method="setTimeout"]
	 * Must be one of the following:
	 *
	 *   - `setTimeout`
	 *   - `requestAnimationFrame`
	 *
	 * @property {number} [table.incremental.delay=10]
	 *
	 * @property {number} [table.incremental.chunkSize=100]
	 *
	 * @property {object} [table.limit]
	 * Configuration for the "limit" feature.
	 *
	 * @property {string} [table.limit.method="more"]
	 * How to limit the output.  Must be one of the following:
	 *
	 *   - `more` — Show a row at the bottom, which when clicked, loads more rows.
	 *
	 * @property {number} [table.limit.threshold=100]
	 * The total number of rows must exceed this in order to trigger using the limit method.  If
	 * omitted, then the "limit" feature is effectively disabled.
	 *
	 * @property {number} [table.limit.chunkSize=50]
	 * When using the "more" limit method, how many additional rows to load each time.
	 *
	 * @property {object} [table.whenPlain]
	 * When the data has not been grouped, this is passed as the `opts` parameter to the GridRenderer
	 * constructor.
	 *
	 * @property {object} [table.whenGroup]
	 * When the data has been grouped, but not pivotted, this is passed as the `opts` parameter to the
	 * GridRenderer constructor.
	 *
	 * @property {object} [table.whenPivot]
	 * When the data has been pivotted, this is passed as the `opts` parameter to the GridRenderer
	 * constructor.
	 */

	/**
	 * @typedef {object} Grid~FieldColConfig
	 * Represents the column configuration for a single field.
	 *
	 * @property {string} field
	 * We're configuring the output of this field.
	 *
	 * @property {string} [displayText]
	 * What to show as the name of the column; the default is to show the field name.
	 *
	 * @property {string} [format]
	 * If the value is a number or currency: a Numeral format string used to render the value.  If the
	 * value is a date, datetime, or time: a Moment format string used to render the value.  Otherwise,
	 * this option is not used.  The default format strings are:
	 *
	 *   - number: [none]
	 *   - currency: `$0,0.00` (e.g. "$1,000.23")
	 *   - date: `LL` (e.g. "September 4, 1986")
	 *   - datetime: `LLL` (e.g. "September 4, 1986 8:30 PM")
	 *
	 * @property {string} [format_dateOnly="LL"]
	 * When `hideMidnight = true` this is the Moment format string used to display just the date
	 * component of the datetime.  Note that the time component is still present in the value when it is
	 * formatted, so don't reference the hours/minutes/seconds from the format string.
	 *
	 * @property {boolean} [hideMidnight=false]
	 * If the value is a datetime, and this value is true, then the time component is not rendered when
	 * it's midnight (00:00:00).  If the value is not a datetime, this option is not used.
	 *
	 * @property {string} [cellAlignment]
	 * How to align the value within the cell horizontally.  Possible values:
	 *
	 *   - `left`
	 *   - `center`
	 *   - `right`
	 *
	 * The default depends on the type of the field.  Strings, dates, datetimes, and times are
	 * left-aligned by default.  Numbers and currencies are right-aligned by default.
	 *
	 * @property {boolean} [allowHtml=false]
	 * If true and the type of the field is a string, the value is interpreted as HTML and the resulting
	 * nodes are inserted into the table result.  When exporting to CSV, the value emitted will be the
	 * text nodes only.
	 *
	 * @property {string} [maxHeight]
	 * If present, sets the maximum height allowed for the cell, and puts a "fullscreen" icon button in
	 * the top-right which will pop open a window showing the full value.  Useful for extremely long
	 * pieces of data that would otherwise blow up the table.  Only works in plain output.
	 */

	/**
	 * @typedef {OrdMap.<string, Grid~FieldColConfig>} Grid~ColConfig
	 * A collection of configurations across all the available fields in the grid.  If a field isn't in
	 * this object, then it might as well not exist.
	 */

	/**
	 * @typedef {object} Grid~Features
	 *
	 * @property {boolean} [footer=false] If true, then a footer is shown at the bottom of the table.
	 * This is automatically enabled if `defn.table.footer` is provided.
	 *
	 * @property {boolean} [sort=false] If true, the user is allowed to sort the data by clicking the
	 * column header.
	 *
	 * @property {boolean} [filter=false] If true, the user is allowed to filter the data by clicking
	 * the "add filter" button in the column header.
	 *
	 * @property {boolean} [group=false] If true, the user is allowed to group the data.
	 *
	 * @property {boolean} [pivot=false] If true, the user is allowed to pivot the data.
	 *
	 * @property {boolean} [rowSelect=false] If true, the user is allowed to select rows by using the
	 * checkbox in the first column.
	 *
	 * @property {boolean} [rowReorder=false] If true, the user is allowed to manually reorder the rows
	 * using the handle in the last column.
	 *
	 * @property {boolean} [add=false] Unused
	 *
	 * @property {boolean} [edit=false] Unused
	 *
	 * @property {boolean} [delete=false] Unused
	 *
	 * @property {boolean} [limit=false] If true, then limit the amount of rows output by some method.
	 *
	 * @property {boolean} [tabletool=false] If true, then use TableTool to create a floating header for
	 * the table.
	 *
	 * @property {boolean} [blockUI=false] If true, use BlockUI to prevent interaction with the table
	 * while the View is doing something.
	 *
	 * @property {boolean} [nprogress=false] If true, use nprogress to show the progress of sort/filter
	 * operations that the View is performing.
	 *
	 * @property {boolean} [incremental=false] If true, render rows in the table incrementally, which
	 * prevents UI freezes while doing so.  However, the overall time required to finish rendering the
	 * table goes way up.
	 */

	// Constructor {{{2

	/**
	 * Create a new Grid and place it somewhere in the page.  A Grid consists of two major parts: the
	 * decoration (e.g. titlebar and toolbar), and the underlying grid (e.g. jQWidgets or Tablesaw).
	 *
	 * @param {string} id The ID of a DIV (which must already exist in the page) where we will put the
	 * grid and its decoration.  This DIV is also known as the "tag container" because it's typically
	 * created by the <WCGRID> layout tag.
	 *
	 * @param {Grid~Defn} defn The definition of the grid itself.
	 *
	 * @param {object} tagOpts Configuration of the decoration of the grid.
	 *
	 * @param {boolean} [tagOpts.runImmediately=true] If true, then show the grid immediately.
	 *
	 * @param {number} [tagOpts.height] If present, sets the height of the grid.
	 *
	 * @param {string} [tagOpts.title] If present, create a title bar for the grid.
	 *
	 * @param {string} [tagOpts.helpText] If present, create a help bubble with this text.
	 *
	 * @param {function} cb A function that will be called after the grid has finished rendering, with
	 * the underlying output method grid object (e.g. the jqxGrid instance) being passed.
	 *
	 * @class
	 *
	 * @property {string} id The ID of the div that contains the whole tag output.
	 * @property {Grid~Defn} defn The definition object used to create the grid.
	 * @property {wcgrid_tagOpts} tagOpts Options for the grid's container.
	 * @property {object} grid The underlying grid object (e.g. a jqxGrid instance).
	 * @property {object} ui Contains various user interface components which are tracked for convenience.
	 * @property {Grid~Features} features
	 * @property {Timing} timing
	 *
	 * @property {boolean} rootHasFixedHeight
	 * If true, then the root DIV element has a fixed height (e.g. "600px") and the grid must fit within
	 * that size.  Basically, this controls the "overflow" CSS property of the grid table, and also the
	 * scroll handler for when a grid table automatically shows more rows.
	 *
	 * @property {boolean} _isIdle
	 * If true, then the grid currently has no pending operations that would require the UI to change.
	 *
	 * @property {Grid~ColConfig} colConfig
	 *
	 * @property {string} colConfigSource
	 * Where the column configuration came from, recognized values are: `defn`, `typeinfo`.
	 *
	 * @property {boolean} colConfigRestricted
	 * If true, then the available columns in column configuration are restricted and cannot be added to
	 * via the source or user preferences.  In other words, the set of available columns is restricted
	 * to the subset specified via the grid definition.
	 *
	 * @borrows GridTable#getSelection
	 * @borrows GridTable#setSelection
	 * @borrows GridTable#select
	 * @borrows GridTable#unselect
	 * @borrows GridTable#isSelected
	 */

	var Grid = makeSubclass('Grid', Object, function (id, view, defn, tagOpts, cb) {
		var self = this;
		var doingServerFilter = getProp(defn, 'server', 'filter') && getProp(defn, 'server', 'limit') !== -1;

		self._isIdle = false;

		self.view = view;

		self.generateCsv = false;
		self.csvReady = false;
		self.exportLock = new Lock('Export');
		self.colConfigLock = new Lock('colConfig');

		self.rootHasFixedHeight = false;
		self.timing = new Timing();

		// Clean up the inputs that we received.

		defn = defn || {};
		self._normalize(defn);

		self.debug(null, 'Definition: %O', defn);

		if (!(view instanceof View)) {
			throw new Error('Call Error: `view` must be an instance of MIE.WC_DataVis.View');
		}

		deepDefaults(true, tagOpts, {
			runImmediately: true,
			showToolbar: true,
			showControls: false,
		});

		self.defn = defn; // Definition used to retrieve data and output grid.
		self.tagOpts = tagOpts; // Other tag options, not related to the grid.
		self.grid = null; // List of all grids generated as a result.
		self.ui = {}; // User interface elements.
		self.selected = {}; // Information about what rows are selected.

		self.view.addClient(self, 'grid');

		self.defn.grid = self;

		self._validateFeatures();
		self._validateId(id);

		if (defn.prefs != null && !(defn.prefs instanceof Prefs)) {
			throw new Error('Call Error: `defn.prefs` must be null or an instance of MIE.WC_DataVis.Prefs');
		}

		if (defn.prefs != null) {
			self.prefs = defn.prefs;
		}
		else if (self.view.prefs != null) {
			self.debug('PREFS', 'Using prefs from connected view');
			self.prefs = self.view.prefs;
		}
		else {
			self.debug('PREFS', 'Creating new prefs');
			self.prefs = new Prefs(self.id);
		}

		self.colConfigWin = new ColConfigWin(self, self.colConfig);
		self.handlebarsEditor = new HandlebarsEditor(self, function () {
			self.redraw();
		});

		/*
		 * Set up other container elements.
		 */

		self.ui.root = jQuery(document.getElementById(id))
			.addClass('wcdv_grid')
			.attr('data-title', id + '_title');

		self.ui.root.children().remove();

		if (self.ui.root.height() !== 0) {
			self.rootHasFixedHeight = true;
			self.rootHeight = self.ui.root.height();
			// When using TableTool, we can't just set the height of the whole grid and use flex to control
			// the height of the table automatically.  See DV-196.
			// Remove the height CSS property here, so the renderer can use it for data-ttheight instead.
			if (self.features.floatingHeader && self.defn.table.floatingHeader.method === 'tabletool' && window.TableTool != null) {
				self.ui.root.css('height', '');
			}
		}

		if (self.view.source.origin instanceof FileSource) {
			self.ui.root._onFileDrop(function (files) {
				self.view.source.origin.setFiles(files);
			});
		}

		self.ui.titlebar = jQuery('<div class="wcdv_grid_titlebar">')
			.attr('title', trans('SHOWHIDE'))
			.on('click', function (evt) {
				evt.stopPropagation();
				self.toggle();
			})
			.droppable({
				accept: '.wcdv_drag_handle',
				over: function (evt, ui) {
					self.showControls();

					// Need to recalculate the position of the droppable targets, because they are now
					// guaranteed to be visible (they may have been hidden within the grid control before).

					ui.draggable.draggable('option', 'refreshPositions', true);
				}
			})
			.appendTo(self.ui.root);

		self._addTitleWidgets(self.ui.titlebar, doingServerFilter, !!self.tagOpts.runImmediately, id);

		self.ui.content = jQuery('<div>', {
			'class': 'wcdv_grid_content'
		}).appendTo(self.ui.root);

		self.ui.toolbar = jQuery('<div>')
			.addClass('wcdv_grid_toolbar')
			.droppable({
				accept: '.wcdv_drag_handle',
				over: function (evt, ui) {
					self.showControls();

					// Need to recalculate the position of the droppable targets, because they are now
					// guaranteed to be visible (they may have been hidden within the grid control before).

					ui.draggable.draggable('option', 'refreshPositions', true);
				}
			})
			.appendTo(self.ui.content)
		;

		self.ui.toolbar_prefs = new PrefsToolbar(self);
		self.ui.toolbar_prefs.attach(self.ui.toolbar);

		self.prefs.bind('grid', self, {
			toolbar: self.ui.toolbar_prefs.ui.root
		});

		self.ui.toolbar_plain = new PlainToolbar(self);
		self.ui.toolbar_plain.attach(self.ui.toolbar);
		self.ui.toolbar_plain.hide();

		self.ui.toolbar_group = new GroupToolbar(self);
		self.ui.toolbar_group.attach(self.ui.toolbar);
		self.ui.toolbar_group.hide();

		self.ui.toolbar_pivot = new PivotToolbar(self);
		self.ui.toolbar_pivot.attach(self.ui.toolbar);
		self.ui.toolbar_pivot.hide();

		self.ui.controls = jQuery('<div>', { 'class': 'wcdv_grid_control' });
		self.ui.filterControl = jQuery('<div>', { 'class': 'wcdv_control_pane wcdv_filter_control' });
		self.ui.groupControl = jQuery('<div>', { 'class': 'wcdv_control_pane wcdv_group_control' });
		self.ui.pivotControl = jQuery('<div>', { 'class': 'wcdv_control_pane wcdv_pivot_control' });
		self.ui.aggregateControl = jQuery('<div>', { 'class': 'wcdv_control_pane wcdv_aggregate_control' });
		self.ui.grid = jQuery('<div>', { 'id': defn.table.id, 'class': 'wcdv_grid_table' });

		if (self.rootHasFixedHeight) {
			// When using TableTool, we can't just set the height of the whole grid and use flex to control
			// the height of the table automatically.  See DV-196.
			// Don't use the height: 0px trick in this situation and let TableTool manage the table height.
			if (!self.features.floatingHeader || self.defn.table.floatingHeader.method !== 'tabletool') {
				// This is a trick to make 'flex: 1 1 auto' work right in Firefox, IE, Edge.
				// Otherwise, the table takes up as much space as it needs and doesn't scroll.
				self.ui.grid.css('height', '0px');
			}
		}

		if (!self.tagOpts.showToolbar) {
			self.ui.toolbar.hide();
		}

		if (!self.tagOpts.showControls) {
			self.ui.controls.hide();
		}

		// Filter Control

		self.filterControl = new FilterControl(self, self.colConfig, self.view, self.features, self.timing);
		self.ui.filterControl.children().remove();
		self.filterControl.draw(self.ui.filterControl);
		self.ui.filterControl.show();

		// Group Control

		self.groupControl = new GroupControl(self, self.colConfig, self.view, self.features, self.timing);
		self.groupControl.draw(self.ui.groupControl);

		self.groupControl.on('fieldAdded', function (fieldAdded, fields) {
			self.ui.pivotControl.show();
			self.ui.aggregateControl.show();
		});
		self.groupControl.on('fieldRemoved', function (fieldRemoved, fields) {
			if (fields.length === 0) {
				self.ui.pivotControl.hide();
				self.ui.aggregateControl.hide();
			}
		});
		self.groupControl.on('cleared', function () {
			self.ui.pivotControl.hide();
			self.ui.aggregateControl.hide();
		});

		// Pivot Control

		self.pivotControl = new PivotControl(self, self.colConfig, self.view, self.features, self.timing);
		self.pivotControl.draw(self.ui.pivotControl);

		// Group <-> Pivot (Drag & Drop)

		self.groupControl.getListElement().sortable({
			connectWith: '#' + self.pivotControl.getListElement().attr('id')
		})
			.on('sortupdate', function () {
				self.groupControl.sortableSync();
			});
		self.pivotControl.getListElement().sortable({
			connectWith: '#' + self.groupControl.getListElement().attr('id')
		})
			.on('sortupdate', function () {
				self.pivotControl.sortableSync();
			});

		// Aggregate Control

		self.aggregateControl = new AggregateControl(self, self.colConfig, self.view, self.features, self.timing);
		self.aggregateControl.draw(self.ui.aggregateControl);

		// The user has fixed the height of the containing grid, so we will need to have the browser put
		// in some scrollbars for the overflow.

		if (self.rootHasFixedHeight) {
			self.ui.grid.css({ 'overflow': 'auto' });
		}

		if (document.getElementById(id + '_footer')) {
			// There was a footer which was printed out by dashboard.c which we are now going to move
			// inside the structure that we've been creating.

			self.ui.footer = jQuery(document.getElementById(id + '_footer'));
		}

		self.ui.root
			.append(self.ui.titlebar)
			.append(self.ui.content
				.append(self.ui.toolbar)
				.append(self.ui.controls
					.append(self.ui.filterControl)
					.append(self.ui.groupControl)
					.append(self.ui.pivotControl)
					.append(self.ui.aggregateControl))
				.append(self.ui.grid)
				.append(self.ui.footer))
		;

		var initialRender = true;

		self.tableDoneCont = function (grid, srcIndex) {
			self.debug(null, 'Finished drawing grid table!');

			// This just makes sure that we populate the "views" dropdown.  It's only needed the very
			// first time that we show the grid.  Subsequent refreshes may call this code again, but
			// there's no need to change the view dropdown when that happens.

			if (initialRender) {
				initialRender = false;
			}

			// Invoke the callback for the Grid constructor, after the grid has been created.  Sometimes
			// people want to start manipulating the grid from JS right away.

			if (typeof cb === 'function') {
				cb();
			}
		};

		self.view.on('fetchDataBegin', function () {
			self._setSpinner('loading');
			self._showSpinner();
			if (self.tagOpts.title) {
				self.ui.title._addTrailing(',');
				self.ui.statusSpan.show().text('Loading...');
				self.ui.rowCount.hide();
			}
			if (self.view.source.isCancellable()) {
				self.ui.cancelFetchBtn.show();
			}
		});
		self.view.on('fetchDataEnd', function () {
			self._hideSpinner();
			self.ui.cancelFetchBtn.hide();
			self.ui.statusSpan.show().text('Loaded');
		});
		self.view.source.on('fetchDataCancel', function () {
			self.ui.cancelFetchBtn.hide();
			if (initialRender) {
				if (self.tagOpts.title) {
					self.ui.title._addTrailing(',');
					self.ui.statusSpan.show().text('Not Loaded');
					self.ui.rowCount.hide();
				}
				self._setSpinner('not-loaded');
				self.hasRun = false;
				self.hide();
			}
			else {
				if (self.tagOpts.title) {
					self.ui.title._addTrailing(',');
					self.ui.statusSpan.hide();
					self.ui.rowCount.show();
				}
				self._hideSpinner();
			}
		});

		self.view.on('workBegin', function () {
			self._isIdle = false;
			self._setSpinner('working');
			self._showSpinner();
			if (self.tagOpts.title) {
				self.ui.title._addTrailing(',');
				self.ui.statusSpan.show().text('Processing...');
				self.ui.rowCount.hide();
			}
		});
		self.view.on('workEnd', function (info, ops) {
			self._isIdle = true;
			self._hideSpinner();
			self.ui.title._stripTrailing(',');
			self.ui.statusSpan.hide();
			self.ui.rowCount.show();
			self._updateRowCount(info, ops);
		});

		self.view.on('dataUpdated', function () {
			if (self.tagOpts.showOnDataChange && !self.isVisible()) {
				self.show({ redraw: false });
			}
			self.redraw();
		});

		self.view.on('getTypeInfo', function (typeInfo) {
			self.colConfigFromTypeInfo(typeInfo);
		});

		if (self.tagOpts.runImmediately) {
			self.show();
		}
		else {
			self.hasRun = false;
			self.hide();
		}

		/*
		 * Store self object so it can be accessed from other JavaScript in the page.
		 */

		setProp(self, window, 'MIE', 'WC_DataVis', 'grids', id);
	});

	// Mixins {{{2

	mixinEventHandling(Grid, [
			'showControls'
		, 'hideControls'
		, 'renderBegin'
		, 'renderEnd'
		, 'colConfigUpdate'
		, 'selectionChange'
	]);

	delegate(Grid, 'renderer', ['setSelection', 'getSelection', 'select', 'unselect', 'isSelected']);

	mixinDebugging(Grid);

	// Events JSDoc {{{3

	/**
	 * Fired when controls are shown in the grid.
	 *
	 * @event Grid#showControls
	 */

	/**
	 * Fired when controls are hidden in the grid.
	 *
	 * @event Grid#hideControls
	 */

	/**
	 * Fired when rendering has started.
	 *
	 * @event Grid#renderBegin
	 */

	/**
	 * Fired when rendering has finished.
	 *
	 * @event Grid#renderEnd
	 */

	/**
	 * Fired when column configuration has changed.
	 *
	 * @event Grid#colConfigUpdate
	 */

	/**
	 * Fired when selection is changed.
	 *
	 * @event Grid#selectionChange
	 *
	 * @param {Array.<View~Data_Row>} selected
	 * Data from rows that are selected.
	 */

	// #toString {{{2

	Grid.prototype.toString = function () {
		var self = this;
		return 'Grid (' + self.id + ')';
	};

	// #getDebugTag {{{2

	Grid.prototype.getDebugTag = function () {
		var self = this;
		return 'GRID {id="' + self.id + '"}';
	};

	// #_validateFeatures {{{2

	Grid.prototype._validateFeatures = function () {
		var self = this;

		self.features = {};

		var availableFeatures = [
			'footer',
			'sort',
			'filter',
			'group',
			'pivot',
			'rowSelect',
			'rowReorder',
			'add',
			'edit',
			'delete',
			'limit',
			'floatingHeader',
			'block',
			'progress',
			'incremental'
		];

		// When the user has specified the `footer` option, enable the footer feature (if it hasn't
		// already been set by the user - in other words, the user can override this automatic behavior).

		if (getProp(self.defn, 'table', 'footer') !== undefined) {
			setPropDef(true, self.defn, 'table', 'features', 'footer');
		}

		underscore.each(availableFeatures, function (feat) {
			self.features[feat] = getPropDef(false, self.defn, 'table', 'features', feat);
		});

		self.debug(null, 'Features =', self.features);
	};

	// #_validateId {{{2

	Grid.prototype._validateId = function (id) {
		var self = this;

		// If the ID was specified as a jQuery object, extract the ID from the element.

		if (underscore.isArray(id) && id[0] instanceof jQuery) {
			id = id[0];
		}

		if (id instanceof jQuery) {
			id = id.attr('id');
		}

		if (typeof id !== 'string') {
			throw '<grid> "id" is not a string';
		}

		if (document.getElementById(id) === null) {
			throw 'No element exists with given ID: ' + id;
		}

		self.id = id;
		setProp(id + '_gridContainer', self.defn, 'table', 'id');
	};

	// #_addTitleWidgets {{{2

	/**
	 * Add widgets to the header of the grid.
	 *
	 * @method
	 * @memberof Grid
	 * @private
	 *
	 * @param {object} header
	 * @param {boolean} doingServerFilter If true, then we are filtering and sorting on the server.
	 * @param {boolean} runImmediately If true, then the grid will be refreshed right away.
	 * @param {string} id
	 */

	Grid.prototype._addTitleWidgets = function (titlebar, doingServerFilter, runImmediately, id) {
		var self = this;

		self.ui.spinner = jQuery('<span>', {
			'style': 'font-size: 18px',
			'class': 'wcdv_icon_button wcdv_spinner'
		})
			.appendTo(titlebar)
		;

		self._setSpinner(self.tagOpts.runImmediately ? 'loading' : 'not-loaded');

		self.ui.title = jQuery('<strong>', {'id': id + '_title', 'data-parent': id})
			.addClass('wcdv_title')
			.text(self.tagOpts.title)
			.appendTo(titlebar);

		var notHeader = jQuery('<span>', {'class': 'headingInfo'})
			.on('click', function (evt) {
				evt.stopPropagation();
			})
			.appendTo(titlebar);

		notHeader.append(' ');

		self.ui.statusSpan = jQuery('<span>').appendTo(notHeader);
		self.ui.rowCount = jQuery('<span>').appendTo(notHeader);
		self.ui.selectionInfo = jQuery('<span>').appendTo(notHeader);

		self.ui.clearFilter = jQuery('<span>')
			.hide()
			.append(' (')
			.append(jQuery('<span>', {'class': 'link'})
				.text('clear filter')
				.on('click', function (evt) {
					evt.stopPropagation();
					self.ui.clearFilter.hide();
					self.view.clearFilter({ notify: true });
				}))
			.append(')')
			.appendTo(notHeader);

		self.ui.cancelFetchBtn = jQuery('<button>', {'type': 'button'})
			.css({'margin-left': '0.5em'})
			.text('Cancel')
			.on('click', function (evt) {
				evt.stopPropagation();
				self.view.source.cancel();
			})
			.hide()
			.appendTo(notHeader);

		if (typeof self.tagOpts.helpText === 'string' && self.tagOpts.helpText !== '') {
			notHeader.append(' ');
			fontAwesome('F059')
				.tooltip({
					classes: {
						'ui-tooltip': 'ui-corner-all ui-widget-shadow wcdv_info_tooltip wcdv_border-primary'
					},
					show: { delay: 1000 },
					content: self.tagOpts.helpText
				})
				.appendTo(notHeader);
		}

		// Create container to hold all the controls in the titlebar

		self.ui.titlebar_controls = jQuery('<div>')
			.addClass('wcdv_titlebar_controls pull-right')
			.appendTo(titlebar);

		// Create the Export button

		self.ui.exportBtn = jQuery('<button>', {
			'type': 'button',
			'style': 'font-size: 18px',
			'class': 'wcdv_icon_button wcdv_text-primary'
		})
			.on('click', function (evt) {
				evt.stopPropagation();
				self.export();
			})
			.appendTo(self.ui.titlebar_controls)
		;

		self._setExportStatus('notReady');

		// Create the Refresh button

		self.ui.refreshBtn = jQuery('<button>', {
			'type': 'button',
			'style': 'font-size: 18px',
			'class': 'wcdv_icon_button wcdv_text-primary'
		})
			.attr('title', 'Refresh')
			.on('click', function (evt) {
				evt.stopPropagation();
				self.refresh();
			})
			.append(fontAwesome('f021'))
			.appendTo(self.ui.titlebar_controls)
		;

		var pWinEffect = {
			effect: 'fade',
			duration: 100
		};

		var pWin = jQuery('<div>', { title: 'Perspective' }).dialog({
			autoOpen: false,
			modal: true,
			width: 500,
			position: {
				my: 'top',
				at: 'bottom',
				of: titlebar
			},
			show: pWinEffect,
			hide: pWinEffect,
		});

		var pWinWarning = jQuery('<div>')
			.addClass('wcdv_warning_banner')
			.appendTo(pWin);

		var pWinTextArea = jQuery('<textarea>', {'style': 'font-family: monospace; font-size: 10pt; width: 100%', 'rows': '20', 'readonly': true})
			.appendTo(pWin);

		// This is the "gear" icon that shows/hides the controls below the toolbar.  The controls are used
		// to set the group, pivot, aggregate, and filters.  Ideally the user only has to utilize these
		// once, and then switches between perspectives to get the same effect.

		jQuery('<button>', {
			'type': 'button',
			'style': 'font-size: 18px',
			'class': 'wcdv_icon_button wcdv_text-primary'
		})
			.attr('title', trans('SHOWHIDEOPTS'))
			.click(function (evt) {
				evt.stopPropagation();
				if (evt.shiftKey) {
					if (self.prefs.currentPerspective.opts.isTemporary) {
						pWinWarning.text('This perspective is temporary; the configuration below does not reflect the current state of any bound prefs modules.');
						pWinWarning.show();
					}
					else {
						pWinWarning.hide();
					}
					pWinTextArea.val(JSON.stringify(self.prefs.currentPerspective.config, null, 2));
					pWin.dialog('open');
				}
				else {
					self.toggleControls();
				}
			})
			.append(jQuery(fontAwesome('fa-cog')))
			.appendTo(self.ui.titlebar_controls)
		;

		// Create the down-chevron button that shows/hides everything under the titlebar.

		self.ui.showHideButton = jQuery('<button>', {
			'type': 'button',
			'style': 'font-size: 18px',
			'class': 'wcdv_icon_button wcdv_text-primary showhide'
		})
			.attr('title', trans('SHOWHIDE'))
			.click(function (evt) {
				evt.stopPropagation();
				self.toggle();
			})
			.append(jQuery(fontAwesome('f078')))
			.appendTo(self.ui.titlebar_controls)
		;
	};

	// #clear {{{2

	Grid.prototype.clear = function () {
		var self = this;

		self.ui.root.children().remove();
	};
	// #redraw {{{2

	/**
	 * Redraw the data shown in a grid.  If the grid is not visible, this function does nothing (i.e.
	 * you cannot use it to retrieve data for an invisible grid).
	 *
	 * @method
	 * @memberof Grid
	 */

	Grid.prototype.redraw = function () {
		var self = this;

		var makeGridTable = function () {
			var rendererCtor
				, rendererCtorOpts
				, ops = self.view.getLastOps();

			if (ops) {
				self.debug(null, 'Creating grid table with view opertions: %O', ops);
			}

			if (self.defn.renderer != null) {
				self.rendererName = self.defn.renderer;

				rendererCtor = GridRenderer.registry.get(self.defn.renderer);
				rendererCtorOpts = deepCopy(self.defn.rendererOpts);
			}
			else {
				self.rendererName = 'table';

				if (ops && ops.pivot) {
					rendererCtor = GridRenderer.registry.get(getPropDef('table_pivot', self.defn, 'whenPivot', 'renderer'));
					rendererCtorOpts = deepCopy(self.defn.table.whenPivot);

					self.debug(null, 'Creating pivot grid table');
				}
				else if (ops && ops.group) {
					switch (self.defn.table.groupMode) {
					case 'summary':
						rendererCtor = GridRenderer.registry.get(getPropDef('table_group_summary', self.defn, 'whenGroup', 'renderer'));
						break;
					case 'detail':
						rendererCtor = GridRenderer.registry.get(getPropDef('table_group_detail', self.defn, 'whenGroup', 'renderer'));
						break;
					}

					rendererCtorOpts = deepCopy(self.defn.table.whenGroup);

					if (self.ui.footer) {
						rendererCtorOpts.footer = self.ui.footer;
					}

					self.debug(null, 'Creating group grid table');
				}
				else {
					rendererCtor = GridRenderer.registry.get(getPropDef('table_plain', self.defn, 'whenPlain', 'renderer'));
					rendererCtorOpts = deepCopy(self.defn.table.whenPlain);

					if (self.ui.footer) {
						rendererCtorOpts.footer = self.ui.footer;
					}

					self.debug(null, 'Creating plain grid table');
				}
			}

			if (self.renderer) {
				self.renderer.destroy();
			}

			rendererCtorOpts.generateCsv = self.generateCsv;
			rendererCtorOpts.fixedHeight = self.rootHasFixedHeight;

			self.ui.exportBtn.attr('disabled', true);
			self.renderer = new rendererCtor(self, self.defn, self.view, self.features, rendererCtorOpts, self.timing, self.id, self.colConfig);

			// Update the toolbar sections.  This needs to be done after creating the renderer because the
			// renderer validates (and possibly changes) the supported features, and that changes what parts
			// of the toolbar we show.  Obviously, we shouldn't show buttons for features that the current
			// renderer doesn't implement.

			if (ops && ops.pivot) {
				self.ui.toolbar_plain.hide();
				self.ui.toolbar_group.hide();
				self.ui.toolbar_pivot.show();
			}
			else if (ops && ops.group) {
				self.ui.toolbar_plain.hide();
				self.ui.toolbar_group.show();
				self.ui.toolbar_pivot.hide();
			}
			else {
				self.ui.toolbar_plain.show();
				self.ui.toolbar_group.hide();
				self.ui.toolbar_pivot.hide();
			}

			self.renderer.on('renderBegin', function () {
				self._isIdle = false;
				self.fire('renderBegin');
			});
			self.renderer.on('renderEnd', function () {
				self.fire('renderEnd');
				self._isIdle = true;
			});

			self.renderer.on('unableToRender', function () {
				self._setExportStatus('notReady');
				makeGridTable();
			});

			self.renderer.on('csvReady', function () {
				if (self.exportLock.isLocked()) {
					self.exportLock.unlock();
				}
				self._setExportStatus('ready');
			});
			self.renderer.on('generateCsvProgress', function (progress) {
				if (progress === 0) {
					self.ui.exportBtn.children('span.fa').remove();
					self.ui.exportBtn.append(fontAwesome('fa-spinner', 'fa-spin'));
				}
			});

			if (self.features.limit) {
				self.renderer.on('limited', function () {
					self.ui.limit_div.show();
				});
				self.renderer.on('unlimited', function () {
					self.ui.limit_div.hide();
				});
			}

			if (self.features.rowSelect) {
				self.renderer.on('selectionChange', function (selection) {
					if (selection.length === 0) {
						self.ui.selectionInfo.text('');
					}
					else {
						var addComma = self.ui.rowCount.text().length > 0;
						var str = addComma ? ', ' : '';
						str += selection.length + ' ' + (selection.length === 1 ? 'record' : 'records') + ' selected';
						self.ui.selectionInfo.text(str);
					}
					self.fire('selectionChange', null, selection);
				});
			}

			self.renderer.draw(self.ui.grid, null, function () {
				self.ui.exportBtn.attr('disabled', false);
				self.tableDoneCont();
			});
		};

		self.prefs.prime(function () {
			self.view.prime(function () {
				self.debug(null, 'Redrawing...');
				makeGridTable();
			});
		});
	};

	// #refresh {{{2

	/**
	 * Refreshes the data from the data view in the grid.
	 *
	 * @method
	 * @memberof Grid
	 */

	Grid.prototype.refresh = function () {
		var self = this;

		if (!self.isVisible()) {
			return;
		}

		self.debug(null, 'Refreshing...');

		self._isIdle = false;
		self.view.refresh();
	};

	// #_updateRowCount {{{2

	/**
	 * Set the number of rows shown in the titlebar.  You can provider the number yourself!
	 *
	 * @method
	 * @memberof Grid
	 */

	Grid.prototype._updateRowCount = function (info, ops) {
		var self = this;
		var doingServerFilter = getProp(self.defn, 'server', 'filter') && getProp(self.defn, 'server', 'limit') !== -1;
		var text = [];

		self.debug(null, 'Updating row count');

		// When there's no titlebar, there's nothing for us to do here.

		if (!self.tagOpts.title) {
			return;
		}

		self._hideSpinner();

		if (info.numRows != null) {
			if (info.totalRows != null) {
				text.push(info.numRows + ' / ' + info.totalRows + ' record' + (info.numRows === 1 ? '' : 's'));
			}
			else {
				text.push(info.numRows + ' record' + (info.numRows === 1 ? '' : 's'));
			}
		}

		if (info.isGroup || info.isPivot) {
			text.push(info.numGroups + ' group' + (info.numGroups === 1 ? '' : 's'));
		}

		self.ui.rowCount.text(text.join(', '));

		if (self.ui.clearFilter) {
			if (info.totalRows) {
				self.ui.clearFilter.show();
			}
			else {
				self.ui.clearFilter.hide();
			}
		}

		self.ui.title._addTrailing(',');
	};

	// #hide {{{2

	/**
	 * Hide the grid.
	 *
	 * @method
	 * @memberof Grid
	 */

	Grid.prototype.hide = function () {
		var self = this;

		self.debug(null, 'Hiding...');

		self.ui.content.hide({
			duration: 0,
			done: function () {
				if (self.tagOpts.title) {
					self.ui.showHideButton.removeClass('open fa-rotate-180');
				}
			}
		});
	};

	// #show {{{2

	/**
	 * Make the grid visible.  If the grid has not been "run" yet, it will be done now.
	 *
	 * @param {object} [opts]
	 *
	 * @param {boolean} [opts.redraw=true]
	 * If true, automatically redraw the grid after it has been shown.  This is almost always what you
	 * want, unless you intend to manually call `redraw()` or `refresh()` immediately after showing it.
	 */

	Grid.prototype.show = function (opts) {
		var self = this;

		opts = deepDefaults(opts, {
			redraw: true
		});

		self.debug(null, 'Showing...');

		self.ui.content.show({
			duration: 0,
			done: function () {
				if (self.tagOpts.title) {
					self.ui.showHideButton.addClass('open fa-rotate-180');
				}
				if (!self.hasRun && opts.redraw) {
					self.hasRun = true;
					self.redraw();
				}
			}
		});
	};

	// #toggle {{{2

	/**
	 * Toggle grid visibility.
	 */

	Grid.prototype.toggle = function () {
		var self = this;

		if (self.ui.content.css('display') === 'none') {
			self.show();
		}
		else {
			self.hide();
		}
	};

	// #isVisible {{{2

	/**
	 * Determine if the grid is currently visible.
	 *
	 * @returns {boolean}
	 * True if the grid is currently visible, false if it is not.
	 */

	Grid.prototype.isVisible = function () {
		var self = this;

		return self.ui.content.css('display') !== 'none';
	};

	// hideControls {{{2

	Grid.prototype.hideControls = function () {
		var self = this;

		if (self.ui.controls._isHidden()) {
			return;
		}

		self.ui.controls.hide({
			duration: 0,
			complete: function () {
				self.fire(Grid.events.hideControls);
			}
		});

		//Hide the toolbar
		self.ui.toolbar.hide({
			duration: 0,
			complete: function () {
				//self.fire(Grid.events.hideToolbar);
			}
		});
	};

	// showControls {{{2

	Grid.prototype.showControls = function () {
		var self = this;

		if (!self.ui.controls._isHidden()) {
			return;
		}

		self.ui.controls.show({
			duration: 0,
			complete: function () {
				self.fire(Grid.events.showControls);
			}
		});

		//Show the toolbar
		self.ui.toolbar.show({
			duration: 0,
			complete: function () {
				//self.fire(Grid.events.showToolbar);
			}
		});
	};

	// toggleControls {{{2

	Grid.prototype.toggleControls = function () {
		var self = this;

		if (self.ui.controls._isHidden()) {
			self.showControls();
		}
		else {
			self.hideControls();
		}
	};

	// #_setSpinner {{{2

	/**
	 * Set the type of the spinner icon.
	 *
	 * @param {string} what
	 * The kind of spinner icon to show.  Must be one of: loading, not-loaded, working.
	 */

	Grid.prototype._setSpinner = function (what) {
		var self = this;

		switch (what) {
		case 'loading':
			self.ui.spinner.html(fontAwesome('F021', 'fa-spin', 'Loading...'));
			break;
		case 'not-loaded':
			self.ui.spinner.html(fontAwesome('F05E', null, 'Not Loaded'));
			break;
		case 'working':
			self.ui.spinner.html(fontAwesome('F1CE', 'fa-spin', 'Working...'));
			break;
		}
	};

	// #_showSpinner {{{2

	/**
	 * Show the spinner icon.
	 */

	Grid.prototype._showSpinner = function () {
		var self = this;

		if (self.tagOpts.title) {
			self.ui.spinner.show();
		}
	};

	// #_hideSpinner {{{2

	/**
	 * Hide the spinner icon.
	 */

	Grid.prototype._hideSpinner = function () {
		var self = this;

		if (self.tagOpts.title) {
			self.ui.spinner.hide();
		}
	};

	// #_normalize {{{2

	/**
	 * The point of "normalizing" a definition is to expand shortcut configurations.  For example, lots
	 * of properties can be a string (the shortcut) or an object which contains the same info plus some
	 * additional configuration.  This function would convert the string into the object.  This way,
	 * later code only has to check for the object version.  It also adds a layer of backwards
	 * compatibility.
	 *
	 * You only need to normalize a definition once; after doing so, we flag it so we won't mess with it
	 * again, even though it should be possible to normalize something that's already been done.
	 */

	Grid.prototype._normalize = function (defn) {
		var self = this;

		if (defn.normalized) {
			return;
		}

		defn.normalized = true;

		deepDefaults(true, defn, {
			prefs: null,
			table: {
				groupMode: 'detail',
				features: {
					sort: true,
					filter: true,
					group: true,
					pivot: true,
					rowSelect: false,
					rowReorder: false,
					add: false,
					edit: false,
					delete: false,
					limit: true,
					floatingHeader: true,
					block: false,
					progress: false
				},
				limit: {
					appendBodyLast: false,
					method: 'more',
					threshold: 100,
					chunkSize: 50
				},
				floatingHeader: {
					method: 'tabletool'
				},
				incremental: {
					method: 'setTimeout',
					delay: 10,
					chunkSize: 100
				}
			}
		});

		self._normalizeColumns(defn);
	};

	// #_normalizeColumns {{{2

	Grid.prototype._normalizeColumns = function (defn) {
		var self = this;

		// When the developer did not provider column configuration, take it from the View via typeInfo.
		// Potentially the source could change what fields it contains (e.g. add/remove a field to/from a
		// report) and this would all still work OK, we would stay up-to-date because every time the View
		// got new typeInfo we would update our colConfig.

		if (getProp(defn, 'table', 'columns') == null) {
			self.initColConfig = null;
			self.colConfig = null;
			return;
		}

		var colConfig = new OrdMap();

		for (var i = 0; i < defn.table.columns.length; i += 1) {
			var cc = defn.table.columns[i];

			if (underscore.isString(cc)) {
				cc = { field: cc };
			}

			if (typeof cc.field !== 'string') {
				log.warn('Column Configuration: `field` must be a string');
				continue;
			}

			cc = deepDefaults(cc, {
				hideMidnight: false,
				format_dateOnly: 'LL',
				allowHtml: false,
				canHide: true
			});

			colConfig.set(cc.field, cc);
		}

		self.initColConfig = colConfig.clone();

		underscore.each(getPropDef([], defn, 'table', 'columnConfig'), function (cc, colName) {

			// When you want to show a checkbox to represent the value, it only makes sense to have a
			// checkbox for the filter widget.

			if (cc.widget === 'checkbox') {
				if (cc.filter !== undefined && cc.filter !== 'checkbox') {
					log.warn('Overriding configuration to use filter type "' + cc.filter + '" for checkbox widgets.');
				}
				cc.filter = 'checkbox';
			}
		});

		self.setColConfig(colConfig, {
			from: 'defn',
			savePrefs: false
		});
	};

	// #export {{{2

	/**
	 * Export whatever this grid is currently showing as a CSV file for the user to download.
	 */

	Grid.prototype.export = function () {
		var self = this;

		if (self.exportLock.isLocked()) {
			return;
		}

		if (self.csvReady) {
			var fileName = (self.tagOpts.title || self.id) + '.csv';
			var csv = self.renderer.getCsv();
			var contentType = 'text/csv';
			var blob = new Blob([csv], {'type': contentType});

			presentDownload(blob, fileName);
		}
		else {
			self.exportLock.lock(); // Unlocked in `csvReady` event handler.
			self.generateCsv = true;
			self.redraw();
		}
	};

	// #_setExportStatus {{{2

	Grid.prototype._setExportStatus = function (status) {
		var self = this;

		switch (status) {
		case 'notReady':
			self.csvReady = false;
			self.ui.exportBtn.attr('title', 'Generate CSV');
			self.ui.exportBtn.children('span.fa').remove();
			self.ui.exportBtn.append(fontAwesome('fa-file-o'));
			break;
		case 'ready':
			self.csvReady = true;
			self.ui.exportBtn.attr('title', 'Download CSV');
			self.ui.exportBtn.children('span.fa').remove();
			self.ui.exportBtn.append(fontAwesome('fa-download'));
			break;
		default:
			throw new Error('Call Error: invalid status "' + status + '"');
		}
	};

	// #setColConfig {{{2

	/**
	 * Set the column configuration.
	 *
	 * @param {OrdMap} colConfig
	 * @param {Object} opts
	 * @param {string} opts.from
	 * @param {boolean} [opts.sendEvent=true]
	 * @param {Array.<Object>} [opts.dontSendEventTo]
	 * @param {boolean} [opts.redraw=true]
	 * @param {boolean} [opts.savePrefs=true]
	 */

	Grid.prototype.setColConfig = function (colConfig, opts) {
		var self = this;
		var updated = false;

		if (['defn', 'prefs', 'typeInfo', 'ui', 'reset'].indexOf(opts.from) < 0) {
			throw new Error('Call Error: `opts.from` must be one of: [defn, prefs, typeInfo, ui, reset]');
		}

		opts = deepDefaults(opts, {
			sendEvent: true,
			dontSendEventTo: [],
			redraw: true,
			savePrefs: true
		});

		var setCurrent = function () {
			self.debug('COLCONFIG', 'Setting from %s: %O', opts.from || '[unknown]', colConfig);
			self.colConfig = colConfig;
			self.colConfigSource = opts.from;

			if (self.renderer != null) {
				self.renderer.colConfig = self.colConfig;
			}

			self.debug('COLCONFIG', 'Setting shadow from %s: %O', opts.from || '[unknown]', colConfig);
			self.shadowColConfig = colConfig.clone();
			updated = true;
		};

		var setInitial = function () {
			self.debug('COLCONFIG', 'Setting initial from %s: %O', opts.from || '[unknown]', colConfig);
			self.initColConfig = colConfig.clone();
		};

		/**
		 * Add elements (that are absent in `dst`) from `src` to `dst`.
		 *
		 * @param {OrdMap} src
		 * @param {string} srcMsg
		 * @param {OrdMap} dst
		 * @param {string} dstMsg
		 */

		var addMissing = function (src, srcMsg, dst, dstMsg) {
			var count = dst.mergeWith(src);
			self.debug('COLCONFIG', 'Merged %d fields from %s into %s', count, srcMsg, dstMsg);
			return count;
		};

		/**
		 * Remove elements from `dst` that are absent from `src`.
		 *
		 * @param {OrdMap} src
		 * @param {string} srcMsg
		 * @param {OrdMap} dst
		 * @param {string} dstMsg
		 */

		var removeMissing = function (src, srcMsg, dst, dstMsg) {
			var absent = [];

			dst.each(function (fcc, fieldName) {
				if (!src.isSet(fieldName)) {
					absent.push(fieldName);
				}
			});

			if (absent.length > 0) {
				self.debug('COLCONFIG', 'Removing %d fields from %s which are absent from %s: %O',
					absent.length, dstMsg, srcMsg, absent);
				underscore.each(absent, function (fieldName) {
					dst.unset(fieldName);
				});
				return true;
			}

			return false;
		};

		if (typeof getProp(self.defn, 'advice', 'setColConfig', 'before') === 'function') {
			self.defn.advice.setColConfig.before(colConfig, opts.from, self);
		}

		switch (opts.from) {
		case 'defn':
			setCurrent();
			setInitial();
			self.colConfigRestricted = true;
			break;
		case 'prefs':
			if (self.colConfigRestricted) {
				self.colConfig.each(function (v, k) {
					if (colConfig.isSet(k)) {
						underscore.defaults(colConfig.get(k), v);
					}
				});

				// The column configuration is restricted by defn, so remove anything from prefs that's
				// missing from defn.

				removeMissing(self.colConfig, 'defn', colConfig, 'prefs');

				// Add anything that's in defn but not in prefs.

				addMissing(self.colConfig, 'defn', colConfig, 'prefs');
			}

			setCurrent();
			break;
		case 'reset':
		case 'ui':
			setCurrent();
			break;
		case 'typeInfo':
			// Column configuration derived from typeInfo merges with existing config (by removing config on
			// columns that don't exist in the source, and by adding defaults for columns that exist in the
			// source but aren't specified in the current config).  It can also set the initial, filling in
			// when no defn is specified.

			if (self.colConfig == null) {
				setCurrent();
			}
			else {
				self.colConfig = self.shadowColConfig.clone();
				if (self.renderer != null) {
					self.renderer.colConfig = self.colConfig;
				}

				// Delete fields from existing colConfig which aren't in the source.

				if (removeMissing(colConfig, 'source', self.colConfig, 'existing')) {
					updated = true;
				}

				// Add fields from source that are missing from existing colConfig.  Columns set explicitly in
				// the grid's definition are there to limit what we see, so don't try to add to them.

				if (!self.colConfigRestricted) {
					if (addMissing(colConfig, 'source', self.colConfig, 'existing')) {
						updated = true;
					}
				}
			}
			if (self.initColConfig == null) {
				setInitial();
			}
			break;
		}

		if (!updated) {
			return;
		}

		if (opts.savePrefs) {
			self.prefs.save();
		}

		self.view.setColConfig(self.colConfig); // TODO Convert to event model.

		if (opts.sendEvent) {
			self.fire('colConfigUpdate', {
				notTo: opts.dontSendEventTo
			}, self.colConfig);
		}

		if (opts.redraw) ;
	};

	// #getColConfig {{{2

	Grid.prototype.getColConfig = function (colConfig) {
		var self = this;

		return self.colConfig;
	};

	// #resetColConfig {{{2

	Grid.prototype.resetColConfig = function (opts) {
		var self = this;

		self.debug('COLCONFIG', 'Resetting to: %O', self.initColConfig);

		opts = deepDefaults(opts, {
			from: 'reset',
			savePrefs: false
		});

		self.setColConfig(self.initColConfig.clone(), opts);
	};

	// #isIdle {{{2

	/**
	 * Ask the grid whether there are currently any pending operations that would change the UI.
	 *
	 * Caveats:
	 *
	 *   - If you yield after checking this, then it's no longer guaranteed to be true; some other
	 *     asynchronous event could cause the grid to become active.
	 *
	 *   - If you have `renderEnd` event handlers that yield, it is possible that those event handlers
	 *     will continue executing after the grid has been marked idle.
	 *
	 * @returns {boolean} True if the grid is currently idle, false if there are changes pending which
	 * might cause the grid to be redrawn.
	 */

	Grid.prototype.isIdle = function () {
		var self = this;

		return self._isIdle;
	};

	// #colConfigFromTypeInfo {{{2

	Grid.prototype.colConfigFromTypeInfo = function (typeInfo, opts) {
		var self = this;

		opts = deepDefaults(opts, {
			from: 'typeInfo'
		});

		if (!(typeInfo instanceof OrdMap)) {
			throw new Error('Call Error: `typeInfo` must be an OrdMap');
		}

		var typeInfoColConfig = new OrdMap();

		typeInfo.each(function (fti, fieldName) {
			typeInfoColConfig.set(fieldName, {
				field: fieldName
			});
		});

		self.debug(null, 'Creating colConfig from typeInfo: %O -> %O', typeInfo.asMap(), typeInfoColConfig.asMap());

		//self.setColConfig(self.colConfig == null
		//	? typeInfoColConfig
		//	: OrdMap.fromMerge([self.colConfig, typeInfoColConfig]), opts);
		self.setColConfig(typeInfoColConfig, opts);
	};

	// GraphRenderer {{{1

	var GraphRenderer = makeSubclass('GraphRenderer', Object, function (graph, elt, view, opts) {
		var self = this;

		self.graph = graph;
		self.elt = elt;
		self.view = view;
		self.opts = opts;
	});

	// #toString {{{2

	GraphRenderer.prototype.toString = function () {
		var self = this;

		return '#<GraphRenderer "' + self.graph.id + '">';
	};

	// #_validateConfig {{{2

	GraphRenderer.prototype._validateConfig = function () {

		underscore.each(['Plain', 'Group', 'Pivot'], function (kind) {
			var propName = 'when' + kind;

			if (config[propName] == null) {
				return; // It's OK to be undefined.
			}

			var config = config[propName];

			if (typeof config !== 'function' && typeof config !== 'object') {
				//self.error(kind + ' configuration must be a function or an object');
				config[propName] = null;
				return;
			}
		});
	};

	// #addRedrawHandlers {{{2

	GraphRenderer.prototype.addRedrawHandlers = function (f) {
		var self = this;

		debug.info('GRAPH // RENDER (GOOGLE)', 'Adding redraw handlers');

		self.view.off('workEnd', self);
		self.view.on('workEnd', function () {
			debug.info('GRAPH RENDERER // HANDLER (View.dataUpdated)',
				'Redrawing graph because the view has finished doing work');
			f();
		}, { who: self });
	};

	// #draw {{{2

	GraphRenderer.prototype.draw = function (devConfig, userConfig) {
		var self = this;

		var reallyDraw = function () {
			self._draw(devConfig, userConfig);
		};

		self.addRedrawHandlers(reallyDraw);
		reallyDraw();
	};

	// GraphRendererGoogle {{{1

	var GraphRendererGoogle = makeSubclass('GraphRendererGoogle', GraphRenderer);

	// #draw_plain {{{2

	GraphRendererGoogle.prototype.draw_plain = function (data, typeInfo, dt, config) {
		var self = this;

		if (config == null) {
			return null;
		}

		var convertType = function (t) {
			switch (t) {
			case 'currency':
				return 'number';
			default:
				return t;
			}
		};

		var getRealValue = function (f, x) {
			if (typeInfo.get(f).type === 'date' && moment.isMoment(x.value)) {
				return {v: x.value.toDate(), f: x.orig};
			}
			else if (['number', 'currency'].indexOf(typeInfo.get(f).type) >= 0 && numeral.isNumeral(x.value)) {
				return {v: x.value._value, f: x.orig};
			}
			else {
				return x.value;
			}
		};

		switch (config.graphType) {
		case 'gantt':
			if (config.nameField == null) {
				throw new Error('Configuration option `nameField` must exist');
			}

			var timeConfigStr = '' + (+config.startField) + (+config.endField) + (+config.durationField);
			if (timeConfigStr === '100' || timeConfigStr === '010' || timeConfigStr === '000') {
				throw new Error('Time configuration is insufficient to determine offsets');
			}

			dt.addColumn('string', 'ID');
			dt.addColumn('string', 'Name');
			dt.addColumn('string', 'Resource');
			dt.addColumn('date', 'Start');
			dt.addColumn('date', 'End');
			dt.addColumn('number', 'Duration');
			dt.addColumn('number', 'Completion');
			dt.addColumn('string', 'Dependencies');

			var configOpts = [
				{ name: 'id', default: (function () { var x = 0; return function () { return x++; }; }) },
				{ name: 'name' },
				{ name: 'resource', default: null },
				{ name: 'start', default: null },
				{ name: 'end', default: null },
				{ name: 'duration', default: null },
				{ name: 'completion', default: 0 },
				{ name: 'dependencies', default: null }
			];

			underscore.each(configOpts, function (opt) {
				if (config[opt.name + 'Field'] != null) {
					self.view.source.convertAll(data.dataByRowId, config[opt.name + 'Field']);
				}
			});

			underscore.each(data.data, function (row) {
				var newRow = [];
				underscore.each(configOpts, function (opt) {
					if (config[opt.name + 'Field'] != null) {
						newRow.push(getRealValue(config[opt.name + 'Field'], row.rowData[config[opt.name + 'Field']]));
					}
					else if (opt.default === undefined) {
						throw new Error();
					}
					else if (typeof opt.default === 'function') {
						newRow.push(opt.default());
					}
					else {
						newRow.push(opt.default);
					}
				});
				dt.addRow(newRow);
			});

			break;
		default:
			dt.addColumn(convertType(typeInfo.get(config.categoryField).type), config.categoryField);

			underscore.each(config.valueFields, function (field) {
				dt.addColumn(convertType(typeInfo.get(field).type), field);
			});

			underscore.each(config.valueFields, function (field) {
				self.view.source.convertAll(data.dataByRowId, field);
			});

			underscore.each(data.data, function (row) {
				var newRow;

				newRow = underscore.map([config.categoryField].concat(config.valueFields), function (f) {
					return getRealValue(f, row.rowData[f]);
				});

				dt.addRow(newRow);
			});
		}

		return config;
	};

	// #draw_group {{{2

	GraphRendererGoogle.prototype.draw_group = function (data, typeInfo, dt, config) {
		var self = this;

		if (typeof config === 'function') {
			config = config(data.groupFields);
		}

		config = deepDefaults(config, {
			graphType: 'column',
			categoryField: data.groupFields[0],
			valueFields: [{
				name: 'Count',
				fun: 'count'
			}]
		});

		var valueAxis = config.graphType === 'bar' ? 'hAxis' : 'vAxis';

		// dt.addColumn(typeInfo.get(config.categoryField).type, config.categoryField);
		dt.addColumn('string', config.categoryField);

		if (config.aggType != null && config.aggNum != null) {
			var aggInfo = getProp(data, 'agg', 'info', config.aggType, config.aggNum);
			if (aggInfo == null) {
				log.error('The specified aggregate does not exist: ' + config.aggType + '[' + config.aggNum + ']');
				return null;
			}
			if (data.agg.results[config.aggType][config.aggNum] == null) {
				log.error('No results exist for the specified aggregate: ' + config.aggType + '[' + config.aggNum + ']');
				return null;
			}
			var name = aggInfo.name || aggInfo.instance.getFullName();
			var aggResultType = aggInfo.instance.getType();

			if (aggResultType === 'currency') {
				aggResultType = 'number';
				setProp('currency', config, 'options', valueAxis, 'format');
			}

			dt.addColumn(aggResultType, name);
			setProp(name, config, 'options', valueAxis, 'title');

			underscore.each(data.rowVals, function (rowVal, rowValIdx) {
				var newRow = [rowVal.join(', ')];

				var aggResult = data.agg.results[config.aggType][config.aggNum][rowValIdx];
				if (aggResultType === 'number') {
					aggResult = +aggResult;
				}
				newRow.push(aggResult);
				dt.addRow(newRow);
			});
		}
		else {
			var ai = [];

			// For each value field, create the AggregateInfo instance that will manage it.  Also create a
			// column for the result in the data table.

			underscore.each(config.valueFields, function (v) {
				var aggInfo = new AggregateInfo('group', v, 0, null /* colConfig */, self.typeInfo, null /* convert */);
				dt.addColumn(aggInfo.instance.getType(), v.name || aggInfo.instance.getFullName());
				ai.push(aggInfo);
			});

			// Go through each rowval and create a row for it in the data table.  Every value field gets its
			// own column, which is the result of the corresponding aggregate function specified above.

			underscore.each(data.rowVals, function (rowVal, rowValIdx) {
				var newRow = [rowVal.join(', ')];

				underscore.each(ai, function (aggInfo) {
					var aggResult = aggInfo.instance.calculate(underscore.flatten(data.data[rowValIdx]));
					newRow.push(aggResult);
					if (aggInfo.debug) {
						debug.info('GRAPH // GROUP // AGGREGATE', 'Group aggregate (%s) : Group [%s] = %s',
							aggInfo.instance.name + (aggInfo.name ? ' -> ' + aggInfo.name : ''),
							rowVal.join(', '),
							JSON.stringify(aggResult));
					}
				});

				dt.addRow(newRow);
			});
		}

		return config;
	};

	// #draw_pivot {{{2

	GraphRendererGoogle.prototype.draw_pivot = function (data, typeInfo, dt, config) {
		var self = this;

		if (typeof config === 'function') {
			config = config(data.groupFields, data.pivotFields);
		}

		config = deepDefaults(config, {
			graphType: 'column',
			categoryField: data.groupFields[0],
			valueFields: [{
				fun: 'count'
			}],
			options: {
				isStacked: true
			}
		});

		var valueAxis = config.graphType === 'bar' ? 'hAxis' : 'vAxis';

		dt.addColumn('string', config.categoryField);

		if (config.aggType != null && config.aggNum != null) {
			var aggInfo = getProp(data, 'agg', 'info', config.aggType, config.aggNum);
			if (aggInfo == null) {
				log.error('The specified aggregate does not exist: ' + config.aggType + '[' + config.aggNum + ']');
				return null;
			}
			if (data.agg.results[config.aggType][config.aggNum] == null) {
				log.error('No results exist for the specified aggregate: ' + config.aggType + '[' + config.aggNum + ']');
				return null;
			}
			var name = aggInfo.name || aggInfo.instance.getFullName();
			var aggResultType = aggInfo.instance.getType();

			if (aggResultType === 'currency') {
				aggResultType = 'number';
				setProp('currency', config, 'options', valueAxis, 'format');
			}

			switch (config.aggType) {
			case 'cell':
				underscore.each(data.colVals, function (colVal) {
					dt.addColumn(aggResultType, colVal.join(', '));
				});

				setProp(name, config, 'options', valueAxis, 'title');

				underscore.each(data.rowVals, function (rowVal, rowValIdx) {
					var newRow = [rowVal.join(', ')];

					underscore.each(data.colVals, function (colVal, colValIdx) {
						var aggResult = data.agg.results[config.aggType][config.aggNum][rowValIdx][colValIdx];
						if (aggResultType === 'number') {
							aggResult = +aggResult;
						}
						newRow.push(aggResult);
					});

					dt.addRow(newRow);
				});
				break;
			case 'group':
				dt.addColumn(aggResultType, name);
				setProp(name, config, 'options', valueAxis, 'title');

				underscore.each(data.rowVals, function (rowVal, rowValIdx) {
					var newRow = [rowVal.join(', ')];

					var aggResult = data.agg.results[config.aggType][config.aggNum][rowValIdx];
					if (aggResultType === 'number') {
						aggResult = +aggResult;
					}
					newRow.push(aggResult);
					dt.addRow(newRow);
				});
				break;
			case 'pivot':
				dt.addColumn(aggResultType, name);
				setProp(name, config, 'options', valueAxis, 'title');

				underscore.each(data.colVals, function (colVal, colValIdx) {
					var newRow = [colVal.join(', ')];

					var aggResult = data.agg.results[config.aggType][config.aggNum][colValIdx];
					if (aggResultType === 'number') {
						aggResult = +aggResult;
					}
					newRow.push(aggResult);
					dt.addRow(newRow);
				});
				break;
			}
		}
		else {
			var ai = [];

			// For each value field, create the AggregateInfo instance that will manage it.  Also create
			// columns for the results (one for each colval) in the data table.

			underscore.each(config.valueFields, function (v) {
				var aggInfo = new AggregateInfo('cell', v, 0, null /* colConfig */, self.typeInfo, null /* convert */);

				underscore.each(data.colVals, function (colVal) {
					dt.addColumn(aggInfo.instance.getType(), colVal.join(', '));
				});

				ai.push(aggInfo);
			});

			underscore.each(data.rowVals, function (rowVal, rowValIndex) {
				var newRow = [rowVal.join(', ')];

				underscore.each(data.colVals, function (colVal, colValIndex) {
					underscore.each(ai, function (aggInfo) {
						var aggResult = aggInfo.instance.calculate(data.data[rowValIndex][colValIndex]);
						newRow.push(aggResult);
						if (aggInfo.debug) {
							debug.info('GRAPH // GROUP // AGGREGATE', 'Group aggregate (%s) : RowVal [%s] x ColVal [%s] = %s',
								aggInfo.instance.name + (aggInfo.name ? ' -> ' + aggInfo.name : ''),
								rowVal.join(', '),
								colVal.join(', '),
								JSON.stringify(aggResult));
						}
					});
				});

				dt.addRow(newRow);
			});
		}

		return config;
	};

	// #_ensureGoogleChartsLoaded {{{2

	GraphRendererGoogle.prototype._ensureGoogleChartsLoaded = function (cont) {
		return loadScript('https://www.gstatic.com/charts/loader.js', function (wasAlreadyLoaded, k) {
			var cb = function () {
				k();
				cont();
			};
			if (!wasAlreadyLoaded) {
				debug.info('GRAPH // GOOGLE // DRAW', 'Loading support for Google Charts');
				window.google.charts.load('current', {'packages': ['corechart', 'gantt']});
				window.google.charts.setOnLoadCallback(cb);
			}
			else {
				cb();
			}
		}, {
			needAsyncSetup: true
		});
	};

	// #draw {{{2

	GraphRendererGoogle.prototype._draw = function (devConfig, userConfig) {
		var self = this;

		devConfig = devConfig || {};
		userConfig = userConfig || {};

		self._ensureGoogleChartsLoaded(function () {
			self.view.getData(function (ok, data) {
				self.view.getTypeInfo(function (ok, typeInfo) {
					self.elt.children().remove();

					var makeMessage = function (msg) {
						jQuery('<div>')
							.addClass('wcdv_graph_message_container')
							.css({ 'height': self.opts.height + 'px' })
							.append(
								jQuery('<div>')
									.addClass('wcdv_graph_message')
									.text(msg)
							)
							.appendTo(self.elt);
					};

					if (data.data.length === 0) {
						makeMessage('No Data');
						return;
					}

					var config = null;
					var dt = new google.visualization.DataTable();

					if (data.isPlain) {
						config = self.draw_plain(data, typeInfo, dt, getProp(userConfig, 'plain', 'graphs', getProp(userConfig, 'plain', 'current')) || devConfig.whenPlain);
					}
					else if (data.isGroup) {
						config = self.draw_group(data, typeInfo, dt, getProp(userConfig, 'group', 'graphs', getProp(userConfig, 'group', 'current')) || devConfig.whenGroup);
					}
					else if (data.isPivot) {
						config = self.draw_pivot(data, typeInfo, dt, getProp(userConfig, 'pivot', 'graphs', getProp(userConfig, 'pivot', 'current')) || devConfig.whenPivot);
					}

					if (config == null) {
						makeMessage('Nothing to Graph');
						return;
					}

					var ctor = {
						area: 'AreaChart',
						bar: 'BarChart',
						column: 'ColumnChart',
						pie: 'PieChart',
						gantt: 'Gantt'
					};

					// This is the object that's actually passed to the chart's draw() method.  All the options
					// in the Google documentation should go into this object.

					var options = {
						title: self.opts.title,
						width: self.opts.width,
						height: self.opts.height,
						isStacked: config.stacked,
					};

					var categoryAxis = config.graphType === 'bar' ? 'vAxis' : 'hAxis';

					if (config.graphType === 'pie') {
						options.chartArea = {
							top: '5%',
							left: '5%',
							width: '90%',
							height: '90%'
						};
					}

					setProp(config.categoryField, options, categoryAxis, 'title');

					jQuery.extend(true, options, config.options);

					var chart = new google.visualization[ctor[config.graphType]](self.elt.get(0));

					google.visualization.events.addListener(chart, 'ready', function () {
						var blob = null;
						if (typeof chart.getImageURI === 'function') {
							blob = dataURItoBlob(chart.getImageURI());
						}
						self.graph._setExportBlob(blob);
					});

					google.visualization.events.addListener(chart, 'select', function () {
						var sel = chart.getSelection();
						underscore.each(sel, function (o) {
							debug.info('GRAPH // DRILL DOWN', 'User selected element in graph: row = %s, column = %s, value = %s, formattedValue = %s', o.row, o.column, dt.getValue(o.row, o.column), dt.getFormattedValue(o.row, o.column));

							var filter = deepCopy(self.view.getFilter());

							underscore.each(data.rowVals[o.row], function (x, i) {
								var gs = data.groupSpec[i];
								filter[data.groupFields[i]] = gs.fun != null
									? GROUP_FUNCTION_REGISTRY.get(gs.fun).valueToFilter(x)
									: { '$eq': x };
							});

							if (data.isPivot) {
								// Offset column by one because the category is stored in the first column of the Google
								// DataTable, but that obviously doesn't exist in the View.

								underscore.each(data.colVals[o.column - 1], function (x, i) {
									var ps = data.pivotSpec[i];
									filter[data.pivotFields[i]] = ps.fun != null
										? GROUP_FUNCTION_REGISTRY.get(ps.fun).valueToFilter(x)
										: { '$eq': x };
								});
							}

							debug.info('GRAPH // DRILL DOWN',
								'Creating new perspective: filter = %O', filter);

							window.setTimeout(function () {
								self.view.prefs.addPerspective(null, 'Drill Down', { view: { filter: filter } }, { isTemporary: true }, null, { onDuplicate: 'replace' });
							});
						});
					});

					debug.info('GRAPH // GOOGLE // DRAW', 'Starting draw: [config = %O ; options = %O]', config, options);

					chart.draw(dt, options);
				});
			}, 'Drawing Google graph');
		});
	};

	// GraphRendererJit {{{1

	var GraphRendererJit = makeSubclass('GraphRendererJit', GraphRenderer);

	// #draw {{{2

	GraphRendererJit.prototype.draw = function () {
		var self = this;

		elt.children().remove();

		self.view.getData(function (ok, data) {
			self.view.getTypeInfo(function () {
				var ctor = {
					area: 'AreaChart',
					bar: 'BarChart'
				};

				var json = {
					label: [],
					values: []
				};

				underscore.each(self.opts.valueFields, function (f) {
					json.label.push(f);
				});

				underscore.each(data.data, function (row) {
					var newRow = {};
					newRow.label = row.rowData[self.opts.categoryField].value;
					newRow.values = underscore.map(self.opts.valueFields, function (f) {
						return row.rowData[f].value;
					});
					json.values.push(newRow);
				});

				var options = {
					injectInto: elt.attr('id')
				};

				jQuery.extend(true, options, self.opts.options);

				var chart = new $jit[ctor[self.opts.type]](options);
				chart.loadJSON(json);
			});
		}, 'Drawing JIT graph');
	};

	// Graph {{{1

	// JSDoc Types {{{2

	/**
	 * @typedef {object} Graph~Config
	 *
	 * @property {Graph~Config_When} whenPlain
	 * Tells how to configure the graph when the data is plain (has not been grouped or pivotted).
	 *
	 * @property {Graph~Config_When} whenGroup
	 * Tells how to configure the graph when the data is grouped.
	 *
	 * @property {Graph~Config_When} whenPivot
	 * Tells how to configure the graph when the data is pivotted.
	 */

	/**
	 * @typedef {object} Graph~Config_When
	 * Can either be a function that returns an object, or just an object.  If it's a function, it
	 * receives the group fields and pivot fields as arguments.
	 *
	 * @mixes View~AggregateSpec
	 */

	// Constructor {{{2

	/**
	 * Creates a new graph.
	 *
	 * @param {string} id
	 *
	 * @param {View} view
	 *
	 * @param {Graph~Config} opts
	 *
	 * @class
	 *
	 * Represents a graph.
	 *
	 * @property {string} id
	 * @property {View} view
	 * @property {object} devConfig
	 * @property {object} userConfig
	 * @property {object} opts
	 * @property {GraphRenderer} renderer
	 */

	var Graph = makeSubclass('Graph', Object, function (id, view, devConfig, opts) {
		var self = this;

		self.id = id;
		self.view = view;
		self.devConfig = devConfig || {};
		self.userConfig = {
			plain: {},
			group: {},
			pivot: {}
		};
		self.opts = deepDefaults(opts, {
			title: 'Graph',
			runImmediately: true,
			showToolbar: true,
			showOnDataChange: false,
		});
		self.hasRun = false;

		if (typeof id !== 'string') {
			throw new Error('Call Error: `id` must be a string');
		}

		if (!(view instanceof View)) {
			throw new Error('Call Error: `view` must be an instance of MIE.WC_DataVis.View');
		}

		if (self.opts.prefs != null && !(self.opts.prefs instanceof Prefs)) {
			throw new Error('Call Error: `opts.prefs` must be an instance of MIE.WC_DataVis.Prefs');
		}

		if (self.opts.prefs != null) {
			self.prefs = self.opts.prefs;
		}
		else if (self.view.prefs != null) {
			self.prefs = self.view.prefs;
		}
		else {
			self.prefs = new Prefs(self.id);
		}

		self.prefs.bind('graph', self);

		self._makeUserInterface();

		self.view.addClient(self, 'graph');

		// Event handlers for keeping the spinner icon updated.

		self.view.on('fetchDataBegin', function () {
			self._setSpinner('loading');
			self._showSpinner();
		});
		self.view.on('fetchDataEnd', function () {
			self._hideSpinner();
		});

		self.view.on('workBegin', function () {
			self._setSpinner('working');
			self._showSpinner();
		});
		self.view.on('workEnd', function () {
			self._hideSpinner();
		});

		// Event handler for keeping the UI in sync with the data.

		self.view.on('workEnd', function (info, ops) {
			var config;

			if (ops.pivot) {
				config = getProp(self.userConfig, 'pivot', 'graphs', getProp(self.userConfig, 'pivot', 'current'))
					|| self.devConfig.whenPivot;
			}
			else if (ops.group) {
				config = getProp(self.userConfig, 'group', 'graphs', getProp(self.userConfig, 'group', 'current'))
					|| self.devConfig.whenGroup;
			}
			else {
				config = getProp(self.userConfig, 'plain', 'graphs', getProp(self.userConfig, 'plain', 'current'))
					|| self.devConfig.whenPlain;
			}

			if (config != null) {
				debug.info('GRAPH // HANDLER (View.workEnd)',
					'Matching configuration: %O', config);

				var graphType = config.graphType;
				var axis = graphType === 'bar' ? 'hAxis' : 'vAxis';
				self.ui.graphTypeDropdown.val(config.graphType);
			}

			if (ops.group) {
				self.ui.toolbar_aggregates.show();
				if (config != null) {
					self.ui.aggDropdown.val(config.aggNum);
					self.ui.zeroAxisCheckbox.prop('checked', getProp(config, 'options', axis, 'minValue') == 0);
				}
			}
			else {
				self.ui.toolbar_aggregates.hide();
			}

			if (ops.pivot) {
				self.ui.toolbar_pivot.show();
				if (config != null) {
					self.ui.stackCheckbox.prop('checked', !!getProp(config, 'options', 'isStacked'));
				}
			}
			else {
				self.ui.toolbar_pivot.hide();
			}
		}, {
			who: self
		});

		self.view.on('dataUpdated', function () {
			if (self.opts.showOnDataChange && !self.isVisible()) {
				self.show({ redraw: false });
			}
			self.redraw();
			/*
			switch (self.lastDrawnFrom) {
			case 'config':
				self.drawFromConfig();
				break;
			case 'interactive':
			default:
				self.drawInteractive();
				break;
			}
			*/
		});

		if (self.opts.runImmediately) {
			self.show();
		}
		else {
			self.hasRun = false;
			self.hide();
		}

	});

	// #toString {{{2

	Graph.prototype.toString = function () {
		return 'Graph(id="' + this.id + '")';
	};

	// #_makeUserInterface {{{2

	Graph.prototype._makeUserInterface = function () {
		var self = this;

		// div.wcdv_graph (ui.root)
		// |
		// +-- div.wcdv_grid_titlebar (ui.titlebar)
		// |   |
		// |   +-- strong (ui.spinner)
		// |   +-- strong [[ the title ]]
		// |   `-- button [[ show/hide button ]]
		// |
		// `-- div.wcdv_grid_content (ui.content)
		//     |
		//     +-- div.wcdv_grid_toolbar (ui.toolbar)
		//     +-- div.wcdv_toolbar_section (ui.toolbar_source)
		//     +-- div.wcdv_toolbar_section (ui.toolbar_common)
		//     +-- div.wcdv_toolbar_section (ui.toolbar_aggregate)
		//     `-- div.wcdv_graph_render (ui.graph)

		self.ui = {};
		self.ui.root = jQuery(document.getElementById(self.id));

		self.ui.root.addClass('wcdv_graph');
		self.ui.root.children().remove();

		self.ui.titlebar = jQuery('<div>')
			.addClass('wcdv_grid_titlebar')
			.on('click', function (evt) {
				evt.stopPropagation();
				self.toggle();
			})
			.appendTo(self.ui.root);

		self._addTitleWidgets(self.ui.titlebar);

		self.ui.content = jQuery('<div>', {
			'class': 'wcdv_grid_content'
		}).appendTo(self.ui.root);

		self.ui.toolbar = jQuery('<div>')
			.addClass('wcdv_grid_toolbar')
			.appendTo(self.ui.content)
		;

		if (!self.opts.showToolbar) {
			self.ui.toolbar.hide();
		}

		// The "pivot" toolbar section lets the user decide if colvals should show up stacked or as
		// separate bars (for bar & column charts).

		self.ui.toolbar_pivot = jQuery('<div>')
			.addClass('wcdv_toolbar_section')
			.hide()
			.appendTo(self.ui.toolbar);
		self._addPivotButtons(self.ui.toolbar_pivot);

		// The "aggregates" toolbar section lets the user control what is drawn based on the aggregate
		// functions calculated by the view.

		self.ui.toolbar_aggregates = jQuery('<div>')
			.addClass('wcdv_toolbar_section pull-right')
			.hide()
			.appendTo(self.ui.toolbar);
		self._addAggregateButtons(self.ui.toolbar_aggregates);

		self.ui.graph = jQuery('<div>', { 'id': self.id, 'class': 'wcdv_graph_render' });

		self.ui.root
			.append(self.ui.titlebar)
			.append(self.ui.content
				.append(self.ui.toolbar)
				.append(self.ui.graph))
		;
	};

	// #_addTitleWidgets {{{2

	/**
	 * Add widgets to the header of the graph.
	 *
	 * @private
	 *
	 * @param {jQuery} titlebar
	 */

	Graph.prototype._addTitleWidgets = function (titlebar) {
		var self = this;

		self.ui.spinner = jQuery('<span>', {
			'style': 'font-size: 18px',
			'class': 'wcdv_icon_button wcdv_spinner'
		})
			.appendTo(titlebar)
		;

		self._setSpinner(self.opts.runImmediately ? 'loading' : 'not-loaded');

		jQuery('<strong>')
			.text(self.opts.title)
			.appendTo(titlebar);


		// Create container to hold all the controls in the titlebar

		self.ui.titlebar_controls = jQuery('<div>')
			.addClass('wcdv_titlebar_controls pull-right')
			.appendTo(titlebar);

		// Create the Export button

		self.ui.exportBtn = jQuery('<button>', {
			'type': 'button',
			'style': 'font-size: 18px',
			'class': 'wcdv_icon_button wcdv_text-primary'
		})
			.on('click', function (evt) {
				evt.stopPropagation();
				self.export();
			})
			.append(fontAwesome('f019'))
			.appendTo(self.ui.titlebar_controls)
		;

		// Create the Refresh button

		self.ui.refreshBtn = jQuery('<button>', {
			'type': 'button',
			'style': 'font-size: 18px',
			'class': 'wcdv_icon_button wcdv_text-primary'
		})
			.attr('title', 'Refresh')
			.on('click', function (evt) {
				evt.stopPropagation();
				self.refresh();
			})
			.append(fontAwesome('f021'))
			.appendTo(self.ui.titlebar_controls)
		;

		// This is the "gear" icon that shows/hides the controls below the toolbar.  The controls are used
		// to set the group, pivot, aggregate, and filters.  Ideally the user only has to utilize these
		// once, and then switches between perspectives to get the same effect.

		jQuery('<button>', {
			'type': 'button',
			'style': 'font-size: 18px',
			'class': 'wcdv_icon_button wcdv_text-primary'
		})
			.attr('title', trans('SHOWHIDEOPTS'))
			.click(function (evt) {
				evt.stopPropagation();
				self.ui.toolbar.toggle();
			})
			.append(jQuery(fontAwesome('fa-cog')))
			.appendTo(self.ui.titlebar_controls)
		;

		// Create the down-chevron button that shows/hides everything under the titlebar.

		self.ui.showHideButton = jQuery('<button>', {
			'type': 'button',
			'style': 'font-size: 18px',
			'class': 'wcdv_icon_button wcdv_text-primary showhide'
		})
			.attr('title', trans('SHOWHIDE'))
			.click(function (evt) {
				evt.stopPropagation();
				self.toggle();
			})
			.append(jQuery(fontAwesome('f078')))
			.appendTo(self.ui.titlebar_controls)
		;
	};

	// #_addAggregateButtons {{{2

	Graph.prototype._addAggregateButtons = function (toolbar) {
		var self = this;

		var graphTypeDropdownId = gensym();
		jQuery('<label>', { 'for': graphTypeDropdownId }).text('Graph Type: ').appendTo(toolbar);
		self.ui.graphTypeDropdown = jQuery('<select>', { 'id': graphTypeDropdownId })
			.on('change', function () {
				self.drawInteractive();
			})
			.appendTo(toolbar);

		GRAPH_TYPES.each(function (gt) {
			self.ui.graphTypeDropdown.append(jQuery('<option>', { 'value': gt.value }).text(gt.name));
		});

		var aggDropdownId = gensym();
		jQuery('<label>', { 'for': aggDropdownId }).text('Aggregate: ').appendTo(toolbar);
		self.ui.aggDropdown = jQuery('<select>', { 'id': aggDropdownId })
			.on('change', function () {
				self.drawInteractive();
			})
			.appendTo(toolbar);

		self.ui.zeroAxisCheckbox = makeToggleCheckbox(
			null,
			null,
			false,
			'Y-Axis Starts at Zero',
			toolbar,
			function () {
				self.drawInteractive();
			}
		);

		self.view.on('workEnd', function () {
			self._updateAggDropdown();
		});
	};

	// #_addPivotButtons {{{2

	Graph.prototype._addPivotButtons = function (toolbar) {
		var self = this;

		self.ui.stackCheckbox = makeToggleCheckbox(
			null,
			null,
			true,
			'Stack',
			toolbar,
			function () {
				self.drawInteractive();
			}
		);
	};

	// #_udpateAggDropdown {{{2

	Graph.prototype._updateAggDropdown = function () {
		var self = this;

		// options : [obj]
		// obj : {
		//   name : string
		//   type : string ('group', 'pivot', 'cell')
		//   num : int
		// }

		var options = [];

		// addOption : AggregateInfo, string -> ()

		var addOption = function (aggInfo, appendToName) {
			var name = aggInfo.name || aggInfo.instance.getFullName();
			if (appendToName != null) {
				name += appendToName;
			}
			options.push({
				name: name,
				type: aggInfo.aggType,
				num: aggInfo.aggNum
			});
		};

		self.view.getData(function (ok, data) {
			self.ui.aggDropdown.children().remove();

			if (data.isGroup) {
				underscore.each(getPropDef([], data, 'agg', 'info', 'group'), function (ai) {
					addOption(ai);
				});
			}
			else if (data.isPivot) {
				underscore.each(getPropDef([], data, 'agg', 'info', 'group'), function (ai) {
					addOption(ai, ' by ' + data.groupFields.join(', '));
				});
				underscore.each(getPropDef([], data, 'agg', 'info', 'pivot'), function (ai) {
					addOption(ai, ' by ' + data.pivotFields.join(', '));
				});
				underscore.each(getPropDef([], data, 'agg', 'info', 'cell'), function (ai) {
					addOption(ai);
				});
			}

			// For pivotted data, there are three different aggregates we could graph.  We list them
			// separately in the dropdown, and we want them in the order: cell, group, pivot.  It just so
			// happens that this is also alphabetical order, so we just sort by the aggType first before
			// sorting by the aggNum so the dropdown will be in the right order.

			underscore.each(underscore.sortBy(underscore.sortBy(options, 'type'), 'num'), function (opt) {
				var option = jQuery('<option>', {
					'value': opt.name,
					'data-wcdv-agg-type': opt.type,
					'data-wcdv-agg-num': opt.num,
				}).text(opt.name);
				self.ui.aggDropdown.append(option);
			});
		}, 'Updating graph aggregate dropdown');
	};

	// #export {{{2

	Graph.prototype.export = function () {
		var self = this;

		if (self.exportBlob == null) {
			return;
		}

		var fileName = (self.opts.title || self.id) + '.png';
		presentDownload(self.exportBlob, fileName);
	};

	// #_setExportBlob {{{2

	Graph.prototype._setExportBlob = function (blob) {
		var self = this;

		self.exportBlob = blob;
		self.ui.exportBtn.prop('disabled', blob == null);
	};

	// #_clearExportBlob {{{2

	Graph.prototype._clearExportBlob = function () {
		var self = this;

		self.exportBlob = null;
		self.ui.exportBtn.prop('disabled', true);
	};

	// #drawFromConfig {{{2

	Graph.prototype.drawFromConfig = function () {
		var self = this;

		self.lastDrawnFrom = 'config';
		self.renderer.draw(self.devConfig, self.userConfig);
	};

	// #drawInteractive {{{2

	Graph.prototype.drawInteractive = function () {
		var self = this;

		var graphType = self.ui.graphTypeDropdown.val();
		var minValue = self.ui.zeroAxisCheckbox.prop('checked') ? 0 : null;

		var config = {
			group: {
				graphs: {},
				current: graphType
			},
			pivot: {
				graphs: {},
				current: graphType
			}
		};

		// NOTE The `graphType` field here is useless except that it makes the rendering function (e.g.
		// GraphRendererGoogle#draw_plain) more convenient to implement.

		var selOptIdx = self.ui.aggDropdown.get(0).selectedIndex;
		var selOpt = self.ui.aggDropdown.get(0).options[selOptIdx];

		config.group.graphs[graphType] = {
			graphType: graphType,
			aggType: selOpt.getAttribute('data-wcdv-agg-type'),
			aggNum: toInt(selOpt.getAttribute('data-wcdv-agg-num')),
			options: {}
		};

		// At least with Google Charts, you have to swap the horizontal and vertical axis configuration
		// for bar charts (since they're on their side).

		switch (graphType) {
		case 'bar':
			config.group.graphs[graphType].options = {
				vAxis: {
					minValue: minValue
				}
			};
			break;
		default:
			config.group.graphs[graphType].options = {
				vAxis: {
					minValue: minValue
				}
			};
		}

		// Copy everything... not strictly necessary AFAIK, but it's safe.
		config.pivot = deepCopy(config.group);

		// Make sure to add the stack setting for pivot mode.
		config.pivot.graphs[graphType].options.isStacked = self.ui.stackCheckbox.prop('checked');

		// Store this configuration in the userConfig so that it can be saved with prefs.
		underscore.extend(self.userConfig, config);

		if (self.prefs != null) {
			self.prefs.save();
		}

		debug.info('GRAPH', 'Drawing graph based on interactive config [userConfig = %O]', self.userConfig);

		self.lastDrawnFrom = 'interactive';
		self.renderer.draw(self.devConfig, self.userConfig);
	};

	// #checkGraphConfig {{{2

	Graph.prototype.checkGraphConfig = function () {
		if (self.devConfig == null) {
			return;
		}

		underscore.each(['whenPlain', 'whenGroup', 'whenPivot'], function (dataFormat) {
			if (self.devConfig[dataFormat] === undefined) {
				return;
			}

			var config = self.devConfig[dataFormat];

			// Check the "graphType" property.

			if (config.graphType != null) {
				if (!underscore.isString(config.graphType)) {
					throw new Error('Graph config error: data format "' + dataFormat + '": `graphType` must be a string');
				}

				if (['area', 'bar', 'column', 'pie'].indexOf(config.graphType) === -1) {
					throw new Error('Graph config error: data format "' + dataFormat + '": invalid `graphType`: ' + config.graphType);
				}
			}

			switch (config.graphType) {
			case 'area':
			case 'bar':
			case 'column':
			case 'pie':
				if (config.valueField != null && config.valueFields != null) {
					throw new Error('Graph config error: data format "' + dataFormat + '": can\'t define both `valueField` and `valueFields`');
				}

				// Turn the singular "valueField" into the plural "valueFields."

				if (config.valueField != null) {
					if (!underscore.isString(config.valueField)) {
						throw new Error('Graph config error: data format "' + dataFormat + '": `valueField` must be a string');
					}
					config.valueFields = [config.valueField];
					delete config.valueField;
				}

				// Check the "valueFields" property, if it exists.

				if (config.valueFields != null) {
					if (!underscore.isArray(config.valueFields)) {
						throw new Error('Graph config error: data format "' + dataFormat + '": `valueFields` must be an array');
					}

					underscore.each(config.valueFields, function (f, i) {
						if (!underscore.isString(f)) {
							throw new Error('Graph config error: data format "' + dataFormat + '": `valueFields[' + i + ']` must be a string');
						}
					});
				}
			}
		});
	};

	// #refresh {{{2

	/**
	 * Refreshes the data from the data view in the grid.
	 *
	 * @method
	 * @memberof Grid
	 */

	Graph.prototype.refresh = function () {
		var self = this;

		self.view.clearSourceData();
	};

	// #redraw {{{2

	Graph.prototype.redraw = function () {
		var self = this;

		self.prefs.prime(function () {
			self.view.prime(function () {
				self.checkGraphConfig();
				self.renderer = new GraphRendererGoogle(self, self.ui.graph, self.view, self.opts);
				self.drawFromConfig();
			}, {
				who: self
			});
		}, {
			who: self
		});
	};

	// #hide {{{2

	/**
	 * Hide the grid.
	 *
	 * @method
	 * @memberof Grid
	 */

	Graph.prototype.hide = function () {
		var self = this;

		debug.info('GRAPH', 'Hiding...');

		self.ui.content.hide({
			duration: 0,
			done: function () {
				if (self.opts.title) {
					self.ui.showHideButton.removeClass('open fa-rotate-180');
				}
			}
		});
	};

	// #show {{{2

	/**
	 * Make the grid visible.  If the grid has not been "run" yet, it will be done now.
	 *
	 * @param {object} [opts]
	 *
	 * @param {boolean} [opts.redraw=true]
	 * If true, automatically redraw the grid after it has been shown.  This is almost always what you
	 * want, unless you intend to manually call `redraw()` or `refresh()` immediately after showing it.
	 */

	Graph.prototype.show = function (opts) {
		var self = this;

		opts = deepDefaults(opts, {
			redraw: true
		});

		debug.info('GRAPH', 'Showing...');

		self.ui.content.show({
			duration: 0,
			done: function () {
				if (self.opts.title) {
					self.ui.showHideButton.addClass('open fa-rotate-180');
				}
				if (!self.hasRun && opts.redraw) {
					self.hasRun = true;
					self.redraw();
				}
			}
		});
	};

	// #toggle {{{2

	/**
	 * Toggle graph visibility.
	 */

	Graph.prototype.toggle = function () {
		var self = this;

		if (self.ui.content.css('display') === 'none') {
			self.show();
		}
		else {
			self.hide();
		}
	};

	// #isVisible {{{2

	/**
	 * Determine if the graph is currently visible.
	 *
	 * @returns {boolean}
	 * True if the graph is currently visible, false if it is not.
	 */

	Graph.prototype.isVisible = function () {
		var self = this;

		return self.ui.content.css('display') !== 'none';
	};

	// #_setSpinner {{{2

	/**
	 * Set the type of the spinner icon.
	 *
	 * @param {string} what
	 * The kind of spinner icon to show.  Must be one of: loading, not-loaded, working.
	 */

	Graph.prototype._setSpinner = function (what) {
		var self = this;

		switch (what) {
		case 'loading':
			self.ui.spinner.html(fontAwesome('F021', 'fa-spin', 'Loading...'));
			break;
		case 'not-loaded':
			self.ui.spinner.html(fontAwesome('F05E', null, 'Not Loaded'));
			break;
		case 'working':
			self.ui.spinner.html(fontAwesome('F1CE', 'fa-spin', 'Working...'));
			break;
		}
	};

	// #_showSpinner {{{2

	/**
	 * Show the spinner icon.
	 */

	Graph.prototype._showSpinner = function () {
		var self = this;

		self.ui.spinner.show();
	};

	// #_hideSpinner {{{2

	/**
	 * Hide the spinner icon.
	 */

	Graph.prototype._hideSpinner = function () {
		var self = this;

		self.ui.spinner.hide();
	};

	// #setUserConfig {{{2

	Graph.prototype.setUserConfig = function (config) {
		var self = this;

		self.userConfig = config;

		// When the constructor binds to prefs, this method can be called before the renderer is created.
		// That's not a big deal, just don't do anything here if that's the case.

		if (self.renderer != null) {
			self.renderer.draw(self.devConfig, self.userConfig);
		}
	};

	// GraphControl {{{1

	var GraphControl = makeSubclass('GraphControl', Object, function () {
		var self = this;

		self.ui = {};
	});

	// #draw {{{2

	GraphControl.prototype.draw = function () {
		var self = this;

		self.view.on('getTypeInfo', function (typeInfo) {
			var fields = [];

			underscore.each(determineColumns(null, null, typeInfo), function (fieldName) {
				var text = getProp(self.colConfig, fieldName, 'displayText') || fieldName;
				fields.push({ fieldName: fieldName, displayText: text });
			});

			// Graph Type Dropdown

			self.ui.graphType = jQuery('<select>');

			GRAPH_TYPES.each(function (gt) {
				self.ui.graphType.append(jQuery('<option>', { 'value': gt.value }).text(gt.name));
			});

			self.ui.root.append(jQuery('<div>').append(self.ui.graphType));

			// Plain Data Configuration

			self.ui.plainCheckbox = jQuery('<input>', { 'type': 'checkbox', 'checked': 'checked' })
				.on('change', function () {
					if (self.ui.plainCheckbox.prop('checked')) {
						self.ui.plainConfig.show();
					}
					else {
						self.ui.plainConfig.hide();
					}
				});

			self.ui.root.append(
				jQuery('<span>', { 'class': 'wcdv_title' })
				.append(self.ui.plainCheckbox)
				.append('Plain Data')
			);

			self.ui.plainCategoryField = jQuery('<select>')
				.on('change', function () {
					self.defn.whenPlain.categoryField = self.ui.plainCategoryField.val();
				});
			self.ui.plainValueField = jQuery('<select>')
				.on('change', function () {
					self.defn.whenPlain.valueField = self.ui.plainValueField.val();
				});

			underscore.each(fields, function (f) {
				self.ui.plainCategoryField.append(
					jQuery('<option>', { 'value': f.fieldName }).text(f.displayText)
				);
				self.ui.plainValueField.append(
					jQuery('<option>', { 'value': f.fieldName }).text(f.displayText)
				);
			});

			self.ui.plainConfig = jQuery('<div>')
				.append(
					jQuery('<div>')
					.append('Category Field: ')
					.append(self.ui.plainCategoryField)
				)
				.append(
					jQuery('<div>')
					.append('Value Field: ')
					.append(self.ui.plainValueField)
				)
				.appendTo(self.ui.root);

			// Group Data Configuration



			// Pivot Data Configuration
		}, { limit: 1 });
	};


	// GRAPH_TYPES {{{1

	var GRAPH_TYPES = OrdMap.fromArray([{
		value: 'area',
		name: 'Area Chart',
		modes: ['plain'],
		renderers: [GraphRendererGoogle],
	}, {
		value: 'bar',
		name: 'Bar Chart',
		modes: ['plain', 'group', 'pivot'],
		renderers: [GraphRendererGoogle],
	}, {
		value: 'column',
		name: 'Column Chart',
		modes: ['plain', 'group', 'pivot'],
		renderers: [GraphRendererGoogle],
	}, {
		value: 'pie',
		name: 'Pie Chart',
		modes: ['plain', 'group', 'pivot'],
		renderers: [GraphRendererGoogle],
	}, {
		value: 'gantt',
		name: 'Gantt Chart',
		modes: ['plain'],
		renderers: [GraphRendererGoogle],
	}], 'value');

	/**
	 * @file
	 * This file contains the implementation of the prefs system.
	 *
	 * ## Terminology
	 *
	 * - **Perspective**:
	 *
	 * - **Prefs Module**:
	 *
	 * - **Prefs Backend**:
	 *
	 * - **Prime**: Prepare the prefs system for interactive use.  See {@link Prefs#prime}.
	 *
	 * - **Reset**:
	 *
	 * ## Responsibilities
	 *
	 * - Take configuration from bound components and store it in a backend.
	 * - Retrieve configuration from a backend and load it into bound components.
	 * - Allow management of perspectives, e.g. create new, rename, and delete.
	 * - Facilitate switching between perspectives, including via history stack.
	 *
	 * ## Classes
	 *
	 * - {@link Prefs}
	 * - {@link PrefsBackend}
	 *   - {@link PrefsBackendLocalStorage}
	 *   - {@link PrefsBackendTemporary}
	 * - {@link PrefsModule}
	 *   - {@link PrefsModuleView}
	 *   - {@link PrefsModuleGrid}
	 *   - {@link PrefsModuleGraph}
	 */

	// Prefs {{{1

	// Constructor {{{2

	/**
	 * Creates a new Prefs instance.
	 *
	 * @param {string} id
	 *
	 * @param {object} moduleBindings
	 * Maps module names to the target instances those modules control.
	 *
	 * @param {object} [opts]
	 *
	 * @param {boolean} [opts.autoSave=true]
	 *
	 * If true, save preferences automatically any time they change.
	 *
	 * @param {object} [opts.backend]
	 *
	 * @param {string} [opts.backend.type="localStorage"]
	 * The type of the backend to use when saving prefs.  Must be a key in the `PREFS_BACKEND_REGISTRY`
	 * object, which maps the type to a constructor.
	 *
	 * @class
	 *
	 * Represents the single entry point to the preferences system.  Preferences consist of:
	 *
	 *   - One backend, which stores preference data for retrieval in another session.
	 *   - Multiple perspectives, which represent different ways of looking at the same data.
	 *
	 * @property {string} id
	 * Unique identifier for this Prefs instance; used as the primary key by the backend.
	 *
	 * @property {boolean} isInitialized
	 * If true, this Prefs instance has already been initialized.
	 *
	 * @property {boolean} isPrimed
	 * If true, this Prefs instance has already been primed.
	 *
	 * @property {PrefsBackend} backend
	 *
	 * @property {object} moduleBindings
	 * How perspectives know how to load/save their configurations to/from real things.  Keys are module
	 * names, values are targets that are bound to the module.  The actual load/save functionality is
	 * contained within PrefsModule subclasses.
	 *
	 * @property {string[]} availablePerspectives
	 * List of all the perspective names that we know about.
	 *
	 * @property {Object.<string,Perspective>} perspectives
	 *
	 * @property {Perspective} currentPerspective
	 * The current perspective.
	 *
	 * @property {Perspective[]} bardo
	 * List of perspectives to be preserved when resetting prefs.  Any perspectives which are both
	 * temporary and essential are saved here, and restored automatically after removing all other
	 * perspectives.
	 *
	 * @property {Array.<Perspective>} history
	 * List of perspectives in the history.
	 *
	 * @property {number} historyIndex
	 * Pointer to where we currently are in the history list.
	 */

	var Prefs = makeSubclass('Prefs', Object, function (id, moduleBindings, opts) {
		var self = this;

		if (typeof id !== 'string') {
			throw new Error('Call Error: `id` must be a string');
		}
		if (moduleBindings != null && typeof moduleBindings !== 'object') {
			throw new Error('Call Error: `moduleBindings` must be null or an object');
		}
		if (opts != null && typeof opts !== 'object') {
			throw new Error('Call Error: `opts` must be null or an object');
		}

		self.id = id;
		self.modules = {};
		self.bardo = {};
		self.primeLock = new Lock('Prefs Prime');

		self.opts = deepDefaults(opts, {
			autoSave: true,
			saveCurrent: true,
			savePerspectives: true,
			backend: {
				type: Prefs.DEFAULT_BACKEND_TYPE
			}
		});

		self.init();

		// Create the backend for saving preferences.

		if (!PREFS_BACKEND_REGISTRY.isSet(self.opts.backend.type)) {
			throw new Error('PREFS BACKEND IS NOT REGISTERED'); // XXX
		}

		var backendCtor = PREFS_BACKEND_REGISTRY.get(self.opts.backend.type);
		var backendCtorOpts = self.opts.backend[self.opts.backend.type];

		self.debug(null, 'Creating new preferences backend: id = "%s" ; type = %s ; opts = %O',
			self.id, self.opts.backend.type, backendCtorOpts);

		// If creating the backend fails for any reason (e.g. unable to access localStorage) then fall
		// back to a "temporary" prefs backend that doesn't actually save or load anything.

		//try {
			self.backend = new backendCtor(self.id, self, backendCtorOpts);
		//}
		//catch (e) {
		//	self.bakend = new PrefsBackendTemporary();
		//}

		if (moduleBindings != null) {
			underscore.each(moduleBindings, function (target, moduleName) {
				self.bind(moduleName, target);
			});
		}
	});

	/**
	 * Default name of the "main perspective" which is used when no other perspectives exist.  It's a
	 * fallback, to ensure that there's always something present.
	 */

	Prefs.MAIN_PERSPECTIVE_NAME = 'Main Perspective';

	/**
	 * Default backend type, for when none is specified.  Must be a valid key of something in {@link
	 * PREFS_BACKEND_REGISTRY}.
	 */

	Prefs.DEFAULT_BACKEND_TYPE = 'localStorage';

	// Mixins {{{2

	mixinEventHandling(Prefs, [
		'perspectiveAdded'   // Fired when a perspective is added.
	, 'perspectiveDeleted' // Fired when a perspective is deleted.
	, 'perspectiveRenamed' // Fired when a perspective is renamed.
	, 'perspectiveChanged' // Fired when the current perspective has changed.
	, 'prefsHistoryStatus'
	, 'prefsReset'
	, 'prefsChanged'
	, 'prefsSaved'
	, 'moduleBound'
	, 'primed'
	]);

	mixinDebugging(Prefs);
	mixinLogging(Prefs);

	// Event JSDoc {{{3

	/**
	 * Fired when a new perspective is added.
	 *
	 * @event Prefs#perspectiveAdded
	 *
	 * @param {string} id
	 * ID of the new perspective.
	 */

	/**
	 * Fired when a perspective is deleted.
	 *
	 * @event Prefs#perspectiveDeleted
	 *
	 * @param {string} deletedId
	 * ID of the perspective being deleted.
	 *
	 * @param {string} newCurrentId
	 * ID of the new current perspective.
	 */

	/**
	 * Fired when a perspective is renamed.
	 *
	 * @event Prefs#perspectiveRenamed
	 *
	 * @param {string} id
	 * ID of the perspective being renamed.
	 *
	 * @param {string} newName
	 * New name of the perspective.
	 */

	/**
	 * Fired when the current perspective is changed.
	 *
	 * @event Prefs#perspectiveChanged
	 *
	 * @param {string} newCurrentId
	 * ID of the new current perspective.
	 */

	/**
	 * Fired when the perspective history stack changes.
	 *
	 * @event Prefs#prefsHistoryStatus
	 *
	 * @param {boolean} canGoFoward
	 * If true, there are history stack elements "after" this one.
	 *
	 * @param {boolean} canGoBack
	 * If true, there are history stack elements "before" this one.
	 */

	/**
	 * Fired when prefs are completely reset.
	 *
	 * @event Prefs#prefsReset
	 */

	/**
	 * Fired when the prefs system binds a module.
	 *
	 * @event Prefs#moduleBound
	 *
	 * @param {string} moduleName
	 * Name of the module being bound, e.g. "grid" or "view."
	 *
	 * @param {PrefsModule} module
	 * The instance configuring the target.
	 *
	 * @param {object} target
	 * The target object, what is configured via the module.
	 *
	 * @param {object} opts
	 * Any additional options passed by the target when it bound itself to a module in the prefs system.
	 */

	// #toString {{{2

	Prefs.prototype.toString = function () {
		var self = this;
		return 'Prefs (' + self.id + ', ' + self.opts.backend.type + ')';
	};

	// #getDebugTag {{{2

	Prefs.prototype.getDebugTag = function () {
		var self = this;
		return 'PREFS {id="' + self.id + '", backend=' + self.opts.backend.type + '}';
	};

	// #init {{{2

	/**
	 * Initialize internal data structures.
	 */

	Prefs.prototype.init = function () {
		var self = this;

		if (self.isInitialized) {
			return;
		}

		self.debug(null, 'Initializing prefs system');

		self.isInitialized = true;
		self.perspectives = {};
		self.availablePerspectives = [];
		self.currentPerspective = null;
		self.history = [];
		self.historyIndex = 0;
	};

	// #prime {{{2

	/**
	 * Prime the prefs system for first use.  This involves:
	 *
	 *   1. Retrieving the list of available perspectives from the backend.
	 *   2. Determine the current perspective name, possibly from the backend.
	 *   3. Load the current perspective from the backend.
	 *   4. Switch to the current perspective (which loads it into bound modules).
	 *
	 * The prefs system is now ready for interactive use.
	 *
	 * TODO This should lock the prefs system so it can't be interacted with.
	 *
	 * @param {function} cont
	 * What to do after the prefs system is primed.  Receives `false` if the prefs system was already
	 * primed before this call.  Receives `true` if this was the first time the prefs system was primed.
	 */

	Prefs.prototype.prime = function (cont) {
		var self = this
			, args = Array.prototype.slice.call(arguments);

		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		if (self.isPrimed) {
			return cont(false);
		}

		if (self.primeLock.isLocked()) {
			return self.primeLock.onUnlock(function () {
				self.prime.apply(self, args);
			});
		}

		self.primeLock.lock();

		var makeFinishCont = function (status) {
			return function () {
				self.debug('PRIMING', 'End');
				self.isPrimed = true;
				self.primeLock.unlock();
				return cont(status);
			};
		};

		self.init();

		self.debug('PRIMING', 'Begin');

		return self.backend.getPerspectives(function (ids) {
			self.availablePerspectives = underscore.union(self.availablePerspectives, ids);
			self.backend.loadAll(function (perspectives) {
				asyncEach(underscore.values(perspectives), function (x, i, next) {
					self.addPerspective(x.id, x.name, x.config, null, next, {
						switch: false
					});
				}, function () {
					// When there's already a current perspective (as would be the case when prefs have been
					// pre-configured), we don't have to do anything else.

					self.debug('PRIMING', 'Finished adding all perspectives');

					// Fire the 'primed' event, which potentially gives a receiver the chance to set the current
					// perspective before we try to do it ourselves.

					self.fire('primed');

					if (self.currentPerspective != null) {
						return makeFinishCont(true)();
					}
					else if (self.availablePerspectives.length === 0) {
						// There are no perspectives available, so we need to make a basic one.

						self.debug('PRIMING', 'No perspectives exist, creating one');

						return self.addMainPerspective(makeFinishCont(true));
					}
					else {
						// Otherwise, we need to figure out what the last current perspective was and load it.

						return self.backend.getCurrent(function (currentId) {
							if (currentId == null) {
								// There's no current perspective, somehow, so again just create one.

								self.debug('PRIMING', 'No current perspective set, creating one');

								return self.addMainPerspective(makeFinishCont(true));
							}
							else {
								self.setCurrentPerspective(currentId, makeFinishCont(true));
							}
						}); // self.backend.getCurrent()
					}
				}); // asyncEach()
			}); // self.backend.loadAll()
		}); // self.backend.getPerspectives()
	};

	// #_firePrefsHistoryStatus {{{2

	Prefs.prototype._firePrefsHistoryStatus = function () {
		var self = this;

		self.fire('prefsHistoryStatus', null, self.historyIndex < self.history.length - 1, self.historyIndex > 0);
	};

	// #back {{{2

	/**
	 * Navigate back in the perspective history stack.
	 *
	 * @fires Prefs#prefsHistoryStatus
	 */

	Prefs.prototype.back = function () {
		var self = this;

		if (self.historyIndex === self.history.length - 1) {
			// Already at beginning of history, can't go back anymore.
			return;
		}

		self.historyIndex += 1;
		//self._historyDebug();
		self._firePrefsHistoryStatus();
		self.setCurrentPerspective(self.history[self.historyIndex].id, null, {
			resetHistory: false
		});
	};

	// #forward {{{2

	/**
	 * Navigate forward in the perspective history stack.
	 *
	 * @fires Prefs#prefsHistoryStatus
	 */

	Prefs.prototype.forward = function () {
		var self = this;

		if (self.historyIndex === 0) {
			// Already at end of history, can't go back anymore.
			return;
		}

		self.historyIndex -= 1;
		//self._historyDebug();
		self._firePrefsHistoryStatus();
		self.setCurrentPerspective(self.history[self.historyIndex].id, null, {
			resetHistory: false
		});
	};

	// #_resetHistory {{{2

	Prefs.prototype._resetHistory = function (p) {
		var self = this;

		// Example: self._resetHistory(x)
		//
		// BEFORE ----------------------------
		//   [ A B C D E ]
		//         ^ (history index)
		//
		// AFTER -----------------------------
		//   [ X C D E ]
		//     ^ (history index)

		self.history.splice(0, self.historyIndex);
		if (p != null) {
			self.history.unshift(p);
		}
		self.historyIndex = 0;
		//self._historyDebug();
		self._firePrefsHistoryStatus();
	};

	// #_historyDebug {{{2

	Prefs.prototype._historyDebug = function () {
		var self = this;

		console.log('### HISTORY ### [%d] %O', self.historyIndex, self.history.map(function (x) { return x.name; }));
	};

	// #bind {{{2

	/**
	 * Binds a module and target to the prefs system.
	 *
	 * @param {string} moduleName
	 * Name of the module to bind.  Corresponds to a key in {@link PREFS_MODULE_REGISTRY}.
	 *
	 * @param {object} target
	 * The object that will be controlled by the module.
	 *
	 * @param {object} moduleBoundUserData
	 * Userdata forwarded to the `moduleBound` event handler.
	 *
	 * @fires Prefs#moduleBound
	 */

	Prefs.prototype.bind = function (moduleName, target, moduleBoundUserData) {
		var self = this;

		if (typeof moduleName !== 'string') {
			throw new Error('Call Error: `moduleName` must be a string');
		}
		if (target == null) {
			throw new Error('Call Error: `target` is required');
		}

		// Make sure that the module is registered with a class, otherwise we obviously have no idea what
		// to do with it.

		if (!PREFS_MODULE_REGISTRY.isSet(moduleName)) {
			throw new Error('Module is not registered: ' + moduleName);
		}

		var moduleCtor = PREFS_MODULE_REGISTRY.get(moduleName);
		self.modules[moduleName] = new moduleCtor(target);

		self.fire('moduleBound', null, moduleName, self.modules[moduleName], target, moduleBoundUserData);

		// When we're adding a binding with a perspective already loaded, reload it for the new binding.

		if (self.currentPerspective != null) {
			self.currentPerspective.load([moduleName]);
		}
	};

	// #getPerspectives {{{2

	Prefs.prototype.getPerspectives = function (cont) {
		var self = this;

		if (typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be a function');
		}

		return cont(self.availablePerspectives);
	};

	// #getPerspective {{{2

	/**
	 * Gets the perspective by ID.
	 *
	 * @param {string} id
	 * ID of the perspective to get.
	 *
	 * @returns {Perspective}
	 * The perspective with the requested ID.
	 */

	Prefs.prototype.getPerspective = function (id) {
		var self = this;

		return self.perspectives[id];
	};

	// #addPerspective {{{2

	/**
	 * Add a new perspective.
	 *
	 * @param {string} [id]
	 *
	 * @param {string} [name=id]
	 *
	 * @param {object} [config]
	 * If missing, the configuration of the current perspective is used.
	 *
	 * @param {object} [perspectiveOpts]
	 * Additional options to pass to the {@link Perspective} constructor.
	 *
	 * @param {function} [cont]
	 *
	 * @param {object} [opts]
	 *
	 * @param {boolean} [opts.switch=true]
	 * If true, automatically switch to the new perspective after creating it.
	 *
	 * @param {boolean} [opts.sendEvent=true]
	 *
	 * @param {boolean} [opts.dontSendEventTo]
	 *
	 * @fires Prefs#perspectiveAdded
	 */

	Prefs.prototype.addPerspective = function (id, name, config, perspectiveOpts, cont, opts) {
		var self = this;
		var needToLoad = true; // Will need to load perspective after we add it.

		if (id != null && typeof id !== 'string') {
			throw new Error('Call Error: `id` must be null or a string');
		}
		if (name != null && typeof name !== 'string') {
			throw new Error('Call Error: `name` must be null or a string');
		}
		if (config != null && typeof config !== 'object') {
			throw new Error('Call Error: `config` must be null or an object');
		}
		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}
		if (opts != null && typeof opts !== 'object') {
			throw new Error('Call Error: `opts` must be null or an object');
		}

		if (name == null) {
			name = id;
		}

		cont = cont || I;

		opts = deepDefaults(opts, {
			switch: true,
			sendEvent: true,
			onDuplicate: 'nothing'
		});

		if (['error', 'nothing', 'replace'].indexOf(opts.onDuplicate) < 0) {
			throw new Error('Call Error: `opts.onDuplicate` must be one of: error, nothing, replace');
		}

		var maybeSwitch = function () {
			if (opts.switch) {
				return self.setCurrentPerspective(id, cont, {
					loadPerspective: needToLoad
				});
			}

			return cont(true);
		};

		if (self.perspectives[id] != null) {
			switch (opts.onDuplicate) {
			case 'error':
				throw new Error('Perspective already exists: ' + id);
			case 'nothing':
				return maybeSwitch();
			}
		}

		var addPerspective = function () {
			var p = new Perspective(id, name, config, self.modules, perspectiveOpts);

			if (id == null) {
				id = p.id;
			}

			self.debug(null, 'Adding new perspective: id = "%s" ; name = "%s" ; config = %O', id, name, config);

			if (self.availablePerspectives.indexOf(id) < 0) {
				self.availablePerspectives.push(id);
			}

			self.perspectives[id] = p;

			if (opts.sendEvent) {
				self.fire('perspectiveAdded', {
					notTo: opts.dontSendEventTo
				}, id);
			}

			return maybeSwitch();
		};

		if (self.currentPerspective) {
			self.save();
			if (config == null) {
				config = deepCopy(self.currentPerspective.config);
				needToLoad = false; // Don't need to load, because this is the current config.
			}
			return addPerspective();
		}
		else if (config == null) {
			config = {};
		}

		return addPerspective();
	};

	// #addMainPerspective {{{2

	Prefs.prototype.addMainPerspective = function (cont) {
		var self = this;

		self.addPerspective(null, Prefs.MAIN_PERSPECTIVE_NAME, null, null, cont);
	};

	// #deletePerspective {{{2

	/**
	 * Delete a perspective.  Perspectives flagged "essential" cannot be deleted.
	 *
	 * @param {string} [id]
	 * The ID of the perspective to delete.  If missing, the current perspective is deleted.
	 *
	 * @param {function} [cont]
	 * Continuation callback.
	 *
	 * @param {object} [opts]
	 * @param {boolean} [opts.sendEvent=true]
	 * @param {boolean} [opts.dontSendEventTo]
	 *
	 * @fires Prefs#perspectiveDeleted
	 * @fires Prefs#prefsHistoryStatus
	 */

	Prefs.prototype.deletePerspective = function (id, cont, opts) {
		var self = this;

		if (id != null && typeof id !== 'string') {
			throw new Error('Call Error: `id` must be null or a string');
		}
		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		opts = deepDefaults(opts, {
			sendEvent: true
		});

		// When the ID wasn't provided, use the current perspective.

		if (id == null) {
			id = self.currentPerspective.id;
		}

		// Make sure that we're not trying to delete an essential perspective.

		if (self.perspectives[id].opts.isEssential) {
			self.logError('DELETE PERSPECTIVE', 'Not allowed to delete essential perspective: id = "%s" ; name = "%s"',
				id, self.perspectives[id].name);
			return cont(false);
		}

		// Delete the perspective in the backend.

		self.backend.deletePerspective(id, function (ok) {
			var newCurrent;

			if (!ok) {
				return cont(false);
			}

			// Delete it from our internal data structures.

			delete self.perspectives[id];
			self.availablePerspectives = underscore.without(self.availablePerspectives, id);

			// Let everybody else know that it's been deleted.

			if (opts.sendEvent) {
				self.fire('perspectiveDeleted', {
					notTo: opts.dontSendEventTo
				}, id, newCurrent);
			}

			// When we've deleted all the perspectives, we need to make a new one.

			if (self.availablePerspectives.length === 0) {
				self.currentPerspective = null;
				return self.addMainPerspective(cont);
			}

			if (self.currentPerspective.id === id) {
				// Go back in history until we've found a different perspective.

				while (self.historyIndex < self.history.length && self.history[self.historyIndex].id === id) {
					self.historyIndex += 1;
				}

				// Reset history until that point, erasing everything after it.

				self._resetHistory();

				if (self.history.length > 0) {

					// We've stripped the future and all matching perspectives from history, so use the first
					// element of the new history stack as the current perspective.  Don't reset history because
					// we've already done that manually above.
					//
					// BEFORE -------------------------
					//   [ A B B B C D ]
					//       ^ (history index)
					//
					// AFTER --------------------------
					//   [ C D ]
					//     ^ (history index)

					self.setCurrentPerspective(self.history[0].id, null, {
						resetHistory: false
					});
				}
				else {

					// We've removed all items from history, so put something else back on the stack.  In this
					// example, even though there are different things in the future, everything in the past is
					// the same as what we're deleting, so you end up with empty history.
					//
					// BEFORE -------------------------
					//   [ A B B B ]
					//       ^ (history index)
					//
					// AFTER --------------------------
					//   [ Something ]
					//     ^ (history index)

					self.setCurrentPerspective(self.availablePerspectives[0]);
				}

				//var currentIndex;
				//var historyOffset = 0;
				//for (i = 0; i < self.history.length; i += 1) {
				//	if (self.history[i].getName() === name) {
				//		if (i < self.historyIndex) {
				//			historyOffset += 1;
				//		}
				//	}
				//	else {
				//		// Update the old current index if:
				//		//   #1. There is no old one.
				//		//   #2. The new index is closer than the old one.
				//		//   #3. The new index is "back" and the old is "forward."
				//		if (currentIndex == null
				//				|| (self.historyIndex - i < self.historyIndex - currentIndex)
				//				|| (currentIndex < self.historyIndex && i >= self.historyIndex)) {
				//			currentIndex = i;
				//		}
				//	}
				//}
				//newCurrent = self.history[currentIndex].getName();
				//self.history = _.reject(self.history, function (p) {
				//	return p.getName() === name;
				//});
				//self.historyIndex -= historyOffset;
				//self._historyDebug();
				//self.setCurrentPerspective(newCurrent, null, {
				//	resetHistory: false
				//});
			}
		});
	};

	// #renamePerspective {{{2

	/**
	 * Rename a perspective.
	 *
	 * @param {string} [id]
	 * When null or undefined, uses the current perspective.
	 *
	 * @param {string} newName
	 *
	 * @param {function} [cont]
	 *
	 * @param {object} [opts]
	 * @param {boolean} [opts.sendEvent=true]
	 * @param {boolean} [opts.dontSendEventTo]
	 *
	 * @fires Prefs#perspectiveRenamed
	 */

	Prefs.prototype.renamePerspective = function (id, newName, cont, opts) {
		var self = this;

		opts = deepDefaults(opts, {
			sendEvent: true
		});

		if (id != null && typeof id !== 'string') {
			throw new Error('Call Error: `id` must be null or a string');
		}
		if (typeof newName !== 'string') {
			throw new Error('Call Error: `newName` must be a string');
		}
		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		// When the `id` is missing, use the current perspective's name.

		if (id == null) {
			id = self.currentPerspective.id;
		}

		cont = cont || I;

		if (id === self.currentPerspective.id) ;

		// Make sure a perspective with the old name exists.

		if (self.perspectives[id] == null) {
			throw new Error(sprintf$1.sprintf('Perspective does not exist: id = "%s"', id));
		}

		// Check to see if there are any other perspectives with the same name.

		underscore.each(self.perspectives, function (p) {
			if (p.name === newName) {
				log.warn(sprintf$1.sprintf('Renaming perspective (id = "%s") now shares the name "%s" with a different perspective (id = "%s")',
					id, newName, p.id));
			}
		});

		self.perspectives[id].name = newName;
		self.perspectives[id].save(function () {
			self.backend.save(self.currentPerspective, function () {
				if (opts.sendEvent) {
					self.fire('perspectiveRenamed', {
						notTo: opts.dontSendEventTo
					}, id, newName);
				}

				return cont(true);
			});
		});

		/*
		// Rename the perspective in the backend.

		self.backend.rename(oldName, newName, function (ok) {
			if (!ok) {
				// Error renaming the perspective in the backend.
				return typeof cont === 'function' ? cont(false) : false;
			}

			// Change the name in the perspective itself.
			self.perspectives[oldName].setName(newName);

			// Rename the perspective in our lookup table.
			self.perspectives[newName] = self.perspectives[oldName];
			delete self.perspectives[oldName];

			// Remove the old name from the list of available perspectives.
			self.availablePerspectives = _.without(self.availablePerspectives, oldName);

			if (opts.sendEvent) {
				self.fire('perspectiveRenamed', {
					notTo: opts.dontSendEventTo
				}, oldName, newName);
			}

			return isCurrent
				? self.setCurrentPerspective(newName, cont)
				: typeof cont === 'function'
					? cont(true)
					: true;
		});
		*/
	};

	// #setCurrentPerspective {{{2

	/**
	 * Switch to a different perspective.
	 *
	 * @param {string} id
	 * ID of the perspective to switch to.
	 *
	 * @param {function} [cont]
	 * Continuation callback.
	 *
	 * @param {object} [opts]
	 * @param {boolean} [opts.loadPerspective=true]
	 * If true, automatically load the perspective after we've switched to it.
	 *
	 * @param {boolean} [opts.sendEvent=true]
	 * @param {boolean} [opts.dontSendEventTo]
	 *
	 * @fires Prefs#perspectiveChanged
	 */

	Prefs.prototype.setCurrentPerspective = function (id, cont, opts) {
		var self = this
			, args = Array.prototype.slice.call(arguments);

		if (typeof id !== 'string') {
			throw new Error('Call Error: `id` must be a string');
		}
		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		opts = deepDefaults(opts, {
			loadPerspective: true,
			sendEvent: true,
			resetHistory: true
		});

		if (self.perspectives[id] == null) {
			if (self.availablePerspectives.indexOf(id) < 0) {
				self.logError('SET CURRENT PERSPECTIVE', 'Perspective does not exist: id = "%s"', id);
				if (self.availablePerspectives.length === 0) {
					return self.addMainPerspective(cont);
				}
				else {
					id = self.availablePerspectives[0];
				}
			}

			// Try to load the perspective config from the backend, and create a new Perspective from it.
			// Adding in this way will cause it to be switched to immediately, so there's no need for us to
			// do it again here.

			return self.backend.load(id, function (config) {
				return self.addPerspective(id, null, config, null, cont);
			});
		}

		self.debug(null, 'Switching to perspective: id = "%s"', id);

		self.currentPerspective = self.perspectives[id];

		if (opts.resetHistory) {
			self._resetHistory(self.currentPerspective);
		}

		// FIXME: Firing `perspectiveChanged` causes the grid to be redrawn, which isn't necessary when
		// we're not loading the perspective (e.g. because we've just created a new one).

		var afterLoad = function () {
			if (opts.sendEvent) {
				self.fire('perspectiveChanged', {
					notTo: opts.dontSendEventTo
				}, id);
			}
			self.backend.setCurrent(id, function (ok) {
				return cont(ok);
			});
		};

		if (opts.loadPerspective) {
			return self.currentPerspective.load(null, afterLoad);
		}
		else {
			return afterLoad();
		}
	};

	// #setCurrentPerspectiveByName {{{2

	Prefs.prototype.setCurrentPerspectiveByName = function (name, cont, opts) {
		var self = this;
		var p = underscore.findWhere(self.perspectives, {name: name});

		if (p != null) {
			return self.setCurrentPerspective(p.id, cont, opts);
		}

		throw new Error('No such perspective: "' + name + '"');
	};

	// #save {{{2

	/**
	 * Saves the current perspective using the backend.
	 *
	 * @param {PrefsBackend~save_cont} [cont]
	 * Called when the backend has finished saving preferences.
	 */

	Prefs.prototype.save = function (cont) {
		var self = this;

		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		if (self.currentPerspective.opts.isTemporary) {
			return cont(false);
		}

		if (self.opts.autoSave) {
			self.reallySave(cont);
		}
		else {
			self.currentPerspective.isUnsaved = true;
			self.fire('prefsChanged');
		}
	};

	// #reallySave {{{2

	/**
	 * Saves the current perspective using the backend.
	 *
	 * @param {PrefsBackend~save_cont} [cont]
	 * Called when the backend has finished saving preferences.
	 */

	Prefs.prototype.reallySave = function (cont) {
		var self = this;

		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		if (self.currentPerspective.opts.isTemporary) {
			return cont(false);
		}

		self.currentPerspective.save(function () {
			self.backend.save(self.currentPerspective, function (ok) {
				if (ok) {
					self.currentPerspective.isUnsaved = false;
					self.fire('prefsSaved');
				}
				return cont(ok);
			});
		});
	};

	// #reset {{{2

	/**
	 * Reset the prefs system.  This involves:
	 *
	 *   1. Reset the backend.
	 *   2. Flush internal data structures.
	 *   3. Prime the prefs system.
	 *
	 * TODO This should lock the prefs system so it can't be interacted with.
	 *
	 * @param {function} cont
	 * What to do when the prefs system is ready for use again.
	 *
	 * @fires Prefs#prefsReset
	 */

	Prefs.prototype.reset = function (cont) {
		var self = this;

		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		// Save some info for all perspectives that are both temporary and essential, so we can restore
		// them after everything else has been cleared.  The main use case for this is for pre-configured
		// perspectives to survive when destroying stuff the user created.

		underscore.each(self.perspectives, function (p) {
			if (p.opts.isTemporary && p.opts.isEssential) {
				self.debug(null, 'Saving temporary essential perspective: %s', p.id);
				self.bardo[p.id] = {
					id: p.id,
					name: p.name,
					config: p.config,
					opts: p.opts
				};
			}
		});

		var current = self.currentPerspective.id;

		self.backend.reset(function () {
			self.isInitialized = false;
			self.init();

			self.fire('prefsReset');

			underscore.each(self.modules, function (module, moduleName) {
				if (typeof module.reset === 'function') {
					self.debug(null, 'Resetting module: moduleName = %s', moduleName);
					module.reset();
				}
			});

			self.debug(null, 'Restoring temporary essential perspectives: %s', JSON.stringify(underscore.keys(self.bardo)));

			underscore.each(self.bardo, function (p) {
				self.addPerspective(p.id, p.name, p.config, p.opts, null, { switch: false });
			});

			if (self.perspectives[current]) {
				self.setCurrentPerspective(current);
			}

			self.isPrimed = false;
			self.prime(function () {
				return cont(true);
			});
		});
	};

	// PrefsBackend {{{1

	// Constructor {{{2

	/**
	 * Base class for all preference backends.  Almost all methods of this class are abstract, so you
	 * will need to instantiate a subclass like PrefsBackendLocalStorage.
	 *
	 * Generally speaking, methods that gets data is asynchronous and therefore require a callback;
	 * methods that set data support callbacks but don't require them.  In that case, omitting the
	 * callback means you don't want to know if the operation succeeded or not.
	 *
	 * @class
	 *
	 * @param {string} id
	 * @param {Prefs} prefs
	 * @param {object} [opts]
	 */

	var PrefsBackend = makeSubclass('PrefsBackend', Object, function (id, prefs, opts) {
		var self = this;

		self.id = id;
		self.prefs = prefs;
		self.opts = opts;
	});

	// #load {{{2

	/**
	 * Loads the configuration for the specified perspective.  A subclass implementation need not
	 * support loading perspectives individually, but that's how this function is called.  (For example,
	 * an implementation could retrieve all available perspectives from somewhere and just give `cont`
	 * the one that was requested.)
	 *
	 * @abstract
	 *
	 * @param {string} id
	 * @param {function} cont
	 */

	PrefsBackend.prototype.load = function (id, cont) {
		throw new Error('Abstract method load() not implemented by subclass ' + this.constructor.name);
	};

	// #loadAll {{{2

	/**
	 * Loads all perspectives.
	 *
	 * @abstract
	 *
	 * @param {function} cont
	 */

	PrefsBackend.prototype.loadAll = function (cont) {
		throw new Error('Abstract method loadAll() not implemented by subclass ' + this.constructor.name);
	};

	// #save {{{2

	/**
	 * Callback for when the prefs are done being saved.
	 *
	 * @callback PrefsBackend~save_cont
	 *
	 * @param {boolean} ok
	 * If true, then the operation was successful; if false, then an error occurred.
	 *
	 * @param {string} [errmsg]
	 * If `ok` is false, this is the error that occurred.
	 */

	/**
	 * Saves the configuration for the specified perspective.  A subclass implementation need not
	 * support saving perspectives individually, but that's how this function is called.  (For example,
	 * an implementation could update the `id` perspective in a big object containing all available
	 * perspectives, and store the whole thing somewhere.)
	 *
	 * @abstract
	 *
	 * @param {Perspective} perspective
	 * @param {PrefsBackend~save_cont} [cont]
	 */

	PrefsBackend.prototype.save = function (perspective, cont) {
		throw new Error('Abstract method save() not implemented by subclass ' + this.constructor.name);
	};

	// #getPerspectives {{{2

	/**
	 * @callback PrefsBackend~getPerspectives_cont
	 * @param {string[]} ids
	 * List of the IDs of all currently available perspectives.
	 */

	/**
	 * Get the IDs of all the available perspectives.
	 *
	 * @abstract
	 *
	 * @param {PrefsBackend~getPerspectives_cont} cont
	 * Callback function to receive the perspective IDs.
	 */

	PrefsBackend.prototype.getPerspectives = function (cont) {
		throw new Error('Abstract method getPerspectives() not implemented by subclass ' + this.constructor.name);
	};

	// #getCurrent {{{2

	/**
	 * Get the ID of the current perspective.
	 *
	 * @abstract
	 *
	 * @param {function} cont
	 */

	PrefsBackend.prototype.getCurrent = function (cont) {
		throw new Error('Abstract method getCurrent() not implemented by subclass ' + this.constructor.name);
	};

	// #setCurrent {{{2

	/**
	 * Set the ID of the current perspective.
	 *
	 * @abstract
	 *
	 * @param {string} id
	 * @param {function} [cont]
	 */

	PrefsBackend.prototype.setCurrent = function (id, cont) {
		throw new Error('Abstract method setCurrent() not implemented by subclass ' + this.constructor.name);
	};

	// #rename {{{2

	/**
	 * Rename a perspective in the backend, i.e. store that the perspective previously known as
	 * `oldName` is now called `newName`.
	 *
	 * @abstract
	 *
	 * @param {string} oldName Perspective's old name.
	 * @param {string} newName Perspective's new name.
	 * @param {function} [cont]
	 */

	PrefsBackend.prototype.rename = function (oldName, newName, cont) {
		throw new Error('Abstract method rename() not implemented by subclass ' + this.constructor.name);
	};

	// #delete {{{2

	/**
	 * Delete a perspective in the backend.
	 *
	 * @abstract
	 *
	 * @param {string} id
	 * @param {function} [cont]
	 */

	PrefsBackend.prototype.deletePerspective = function (id, cont) {
		throw new Error('Abstract method deletePerspective() not implemented by subclass ' + this.constructor.name);
	};

	// #reset {{{2

	/**
	 * Reset all preferences.
	 *
	 * @abstract
	 *
	 * @param {function} [cont]
	 */

	PrefsBackend.prototype.reset = function (cont) {
		throw new Error('Abstract method reset() not implemented by subclass ' + this.constructor.name);
	};

	// PrefsBackendLocalStorage {{{1

	// Constructor {{{2

	/**
	 * @class
	 * @extends PrefsBackend
	 *
	 *
	 * @param {string} id
	 * @param {object} [opts]
	 * @param {string} [opts.key="WC_DataVis_Prefs"]
	 */

	var PrefsBackendLocalStorage = makeSubclass('PrefsBackendLocalStorage', PrefsBackend, function () {
		var self = this
			, args = Array.prototype.slice.call(arguments);

		try {
			var storage = window.localStorage;
		}
		catch (e) {
			log.error('Access to localStorage is denied; prefs disabled');
			throw e;
		}

		self.super.ctor.apply(self, args);

		self.opts = deepDefaults(self.opts, {
			key: 'WC_DataVis_Prefs'
		});

		self.localStorageKey = self.opts.key;
	}, {
		version: 2
	});

	mixinDebugging(PrefsBackendLocalStorage, function () {
		return 'PREFS (' + this.id + ') // BACKEND - LOCAL';
	});

	// #load {{{2

	PrefsBackendLocalStorage.prototype.load = function (id, cont) {
		var self = this;
		var storedPrefStr, storedPrefObj;
		var version;

		if (typeof id !== 'string') {
			throw new Error('Call Error: `id` must be a string');
		}
		if (typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be a function');
		}

		storedPrefStr = localStorage.getItem(self.localStorageKey);

		if (storedPrefStr != null) {
			storedPrefObj = JSON.parse(storedPrefStr);
			version = getPropDef(0, storedPrefObj, self.id, 'version');

			if (version < self.version) {
				return self.migrate(version, function () {
					return self.loadAll(cont);
				});
			}
		}
		else {
			storedPrefObj = {};
		}

		var perspective = getProp(storedPrefObj, self.id, 'perspectives', id);

		if (perspective == null) {
			self.debug(null, 'Perspective does not exist: id = "%s"', id);
			return cont(null);
		}

		self.debug(null, 'Loaded perspective: id = "%s" ; name = "%s" ; config = %O',
			perspective.id, perspective.name, perspective.config);

		return cont(perspective);
	};

	// #loadAll {{{2

	PrefsBackendLocalStorage.prototype.loadAll = function (cont) {
		var self = this;
		var storedPrefStr, storedPrefObj;
		var version;

		if (typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be a function');
		}

		storedPrefStr = localStorage.getItem(self.localStorageKey);

		if (storedPrefStr != null) {
			storedPrefObj = JSON.parse(storedPrefStr);
			version = getPropDef(0, storedPrefObj, self.id, 'version');

			if (version < self.version) {
				return self.migrate(version, function () {
					return self.loadAll(cont);
				});
			}
		}
		else {
			storedPrefObj = {};
		}

		var perspectives = getPropDef({}, storedPrefObj, self.id, 'perspectives');
		self.debug(null, 'Loaded all perspectives: %O', perspectives);
		return cont(perspectives);
	};

	// #migrate {{{2

	PrefsBackendLocalStorage.prototype.migrate = function (version, cont) {
		var self = this;

		self.debug(null, 'Migrating prefs: v%d -> v%d', version, self.version);

		for (var i = version; i < self.version; i += 1) {
			switch (i) {
			case 0:
				var oldPrefs = JSON.parse(localStorage.getItem('WC_DataVis_Prefs') || '{}');
				var oldCurrent = JSON.parse(localStorage.getItem('WC_DataVis_Prefs_Current') || '{}');
				var newPrefs = JSON.parse(localStorage.getItem(self.localStorageKey) || '{}');

				newPrefs[self.id] = {
					version: i + 1,
					current: oldCurrent[self.id],
					perspectives: underscore.mapObject(oldPrefs[self.id], function (config, id) {
						return {
							view: config
						};
					})
				};

				// We can delete the "current" storage item completely if it's not being used anymore.

				delete oldCurrent[self.id];

				if (underscore.isEmpty(oldCurrent)) {
					localStorage.removeItem('WC_DataVis_Prefs_Current');
				}
				else {
					localStorage.setItem('WC_DataVis_Prefs_Current', JSON.stringify(oldCurrent));
				}

				// We can delete the "prefs" storage item completely if it's not being used anymore.
				// Only bother with this if the storage key is different from the old hard-coded key.
				// If it's the same, there's no point because we're just going to overwrite it.

				delete oldPrefs[self.id];

				if (self.localStorageKey !== 'WC_DataVis_Prefs') {
					if (underscore.isEmpty(oldPrefs)) {
						localStorage.removeItem('WC_DataVis_Prefs');
					}
					else {
						localStorage.setItem('WC_DataVis_Prefs', JSON.stringify(oldPrefs));
					}
				}

				localStorage.setItem(self.localStorageKey, JSON.stringify(newPrefs));
				break;
			case 1:
				var localStorageStr = localStorage.getItem(self.localStorageKey);

				if (localStorageStr == null) {
					throw new Error('Unable to migrate local storage prefs to version 2: '
						+ 'Found no prefs to migrate');
				}

				try {
					var localStorageObj = JSON.parse(localStorageStr);
				}
				catch (e) {
					throw new Error('Unable to migrate local storage prefs to version 2: '
						+ 'Prefs stored are not valid JSON');
				}

				if (localStorageObj[self.id] == null) {
					throw new Error('Unable to migrate local storage prefs to version 2: '
						+ 'No prefs registered for this system ("' + self.id + '")');
				}

				if (localStorageObj[self.id].perspectives == null) {
					localStorageObj[self.id].perspectives = {};
				}

				underscore.each(localStorageObj[self.id].perspectives, function (p, id) {
					var config = {};
					underscore.each(p, function (v, k) {
						config[k] = v;
						p[k] = null;
					});
					p.config = config;
					p.id = id;
					p.name = id;
				});

				localStorageObj[self.id].version = i + 1;
				localStorage.setItem(self.localStorageKey, JSON.stringify(localStorageObj));
				break;
			}
		}

		return typeof cont === 'function' ? cont(true) : true;
	};

	// #save {{{2

	PrefsBackendLocalStorage.prototype.save = function (perspective, cont) {
		var self = this;

		if (!(perspective instanceof Perspective)) {
			throw new Error('Call Error: `perspective` must be a Perspective');
		}
		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		self.debug(null, 'Saving perspective: id = "%s" ; name = "%s" ; config = %O',
			perspective.id, perspective.name, perspective.config);

		var storedPrefData = JSON.parse(localStorage.getItem(self.localStorageKey) || '{}');
		setProp(self.version, storedPrefData, self.id, 'version');
		setProp({
			id: perspective.id,
			name: perspective.name,
			config: perspective.config
		}, storedPrefData, self.id, 'perspectives', perspective.id);
		localStorage.setItem(self.localStorageKey, JSON.stringify(storedPrefData));

		return cont(true);
	};

	// #getPerspectives {{{2

	PrefsBackendLocalStorage.prototype.getPerspectives = function (cont) {
		var self = this;

		if (typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be a function');
		}

		var storedPrefData = JSON.parse(localStorage.getItem(self.localStorageKey) || '{}');
		var perspectives = underscore.keys(getPropDef({}, storedPrefData, self.id, 'perspectives'));

		self.debug(null, 'Found %d perspectives: %s', perspectives.length, JSON.stringify(perspectives));

		return cont(perspectives);
	};

	// #getCurrent {{{2

	PrefsBackendLocalStorage.prototype.getCurrent = function (cont) {
		var self = this;

		if (typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be a function');
		}

		var storedPrefData = JSON.parse(localStorage.getItem(self.localStorageKey) || '{}');
		var current = getProp(storedPrefData, self.id, 'current');

		self.debug(null, 'Current perspective is "%s"', current);

		return cont(current);
	};

	// #setCurrent {{{2

	PrefsBackendLocalStorage.prototype.setCurrent = function (id, cont) {
		var self = this;

		if (typeof id !== 'string') {
			throw new Error('Call Error: `id` must be a string');
		}
		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		self.debug(null, 'Setting current perspective to "%s"', id);

		var storedPrefData = JSON.parse(localStorage.getItem(self.localStorageKey) || '{}');
		setProp(self.version, storedPrefData, self.id, 'version');
		setProp(id, storedPrefData, self.id, 'current');
		localStorage.setItem(self.localStorageKey, JSON.stringify(storedPrefData));

		return cont(true);
	};

	// #rename {{{2

	PrefsBackendLocalStorage.prototype.rename = function (oldName, newName, cont) {
		var self = this;

		if (typeof oldName !== 'string') {
			throw new Error('Call Error: `oldName` must be a string');
		}
		if (typeof newName !== 'string') {
			throw new Error('Call Error: `newName` must be a string');
		}
		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		self.debug(null, 'Renaming perspective: "%s" -> "%s"', oldName, newName);

		var storedPrefData = JSON.parse(localStorage.getItem(self.localStorageKey) || '{}');
		storedPrefData[self.id]['perspectives'][newName] = storedPrefData[self.id]['perspectives'][oldName];
		delete storedPrefData[self.id]['perspectives'][oldName];
		localStorage.setItem(self.localStorageKey, JSON.stringify(storedPrefData));

		return cont(true);
	};

	// #delete {{{2

	PrefsBackendLocalStorage.prototype.deletePerspective = function (id, cont) {
		var self = this;

		if (typeof id !== 'string') {
			throw new Error('Call Error: `id` must be a string');
		}
		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		self.debug(null, 'Deleting perspective: "%s"', id);

		var storedPrefData = JSON.parse(localStorage.getItem(self.localStorageKey) || '{}');
		delete storedPrefData[self.id]['perspectives'][id];
		localStorage.setItem(self.localStorageKey, JSON.stringify(storedPrefData));

		return cont(true);
	};

	// #reset {{{2

	PrefsBackendLocalStorage.prototype.reset = function (cont) {
		var self = this;

		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		self.debug(null, 'Resetting perspectives');

		var storedPrefData = JSON.parse(localStorage.getItem(self.localStorageKey) || '{}');
		delete storedPrefData[self.id];
		localStorage.setItem(self.localStorageKey, JSON.stringify(storedPrefData));

		return cont(true);
	};

	// PrefsBackendTemporary {{{1

	// Constructor {{{2

	/**
	 * @class
	 * @extends PrefsBackend
	 *
	 * @param {string} id
	 */

	var PrefsBackendTemporary = makeSubclass('PrefsBackendTemporary', PrefsBackend, function () {
		var self = this
			, args = Array.prototype.slice.call(arguments);

		self.super.ctor.apply(self, args);
		self.storage = {
			perspectives: {}
		};
	});

	mixinDebugging(PrefsBackendTemporary, function () {
		return 'PREFS (' + this.id + ') // BACKEND - TEMPORARY';
	});

	// #load {{{2

	PrefsBackendTemporary.prototype.load = function (id, cont) {
		var self = this;

		if (typeof id !== 'string') {
			throw new Error('Call Error: `id` must be a string');
		}
		if (typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be a function');
		}

		var perspective = self.storage.perspectives[id];

		if (perspective == null) {
			self.debug(null, 'Perspective does not exist: id = "%s"', id);
			return cont(null);
		}

		self.debug(null, 'Loaded perspective: id = "%s" ; name = "%s" ; config = %O',
			perspective.id, perspective.name, perspective.config);

		return cont(perspective);
	};

	// #loadAll {{{2

	PrefsBackendTemporary.prototype.loadAll = function (cont) {
		var self = this;

		if (typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be a function');
		}

		var perspectives = self.storage.perspectives;
		self.debug(null, 'Loaded all perspectives: %O', perspectives);
		return cont(perspectives);
	};

	// #save {{{2

	PrefsBackendTemporary.prototype.save = function (perspective, cont) {
		var self = this;

		if (!(perspective instanceof Perspective)) {
			throw new Error('Call Error: `perspective` must be a Perspective');
		}
		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		self.debug(null, 'Saving perspective: id = "%s" ; name = "%s" ; config = %O',
			perspective.id, perspective.name, perspective.config);

		self.storage.perspectives[perspective.id] = {
			id: perspective.id,
			name: perspective.name,
			config: perspective.config
		};

		return cont(true);
	};

	// #getPerspectives {{{2

	PrefsBackendTemporary.prototype.getPerspectives = function (cont) {
		var self = this;

		if (typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be a function');
		}

		var perspectives = underscore.keys(self.storage.perspectives);

		self.debug(null, 'Found %d perspectives: %s', perspectives.length, JSON.stringify(perspectives));

		return cont(perspectives);
	};

	// #getCurrent {{{2

	PrefsBackendTemporary.prototype.getCurrent = function (cont) {
		var self = this;

		if (typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be a function');
		}

		var current = self.storage.current;

		self.debug(null, 'Current perspective is "%s"', current);

		return cont(current);
	};

	// #setCurrent {{{2

	PrefsBackendTemporary.prototype.setCurrent = function (id, cont) {
		var self = this;

		if (typeof id !== 'string') {
			throw new Error('Call Error: `id` must be a string');
		}
		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		self.debug(null, 'Setting current perspective to "%s"', id);

		self.storage.current = id;

		return cont(true);
	};

	// #rename {{{2

	PrefsBackendTemporary.prototype.rename = function (oldName, newName, cont) {
		var self = this;

		if (typeof oldName !== 'string') {
			throw new Error('Call Error: `oldName` must be a string');
		}
		if (typeof newName !== 'string') {
			throw new Error('Call Error: `newName` must be a string');
		}
		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		self.debug(null, 'Renaming perspective: "%s" -> "%s"', oldName, newName);

		self.storage.perspectives[newName] = self.storage.perspectives[oldName];
		delete self.storage.perspectives[oldName];

		return cont(true);
	};

	// #delete {{{2

	PrefsBackendTemporary.prototype.deletePerspective = function (id, cont) {
		var self = this;

		if (typeof id !== 'string') {
			throw new Error('Call Error: `id` must be a string');
		}
		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		self.debug(null, 'Deleting perspective: "%s"', id);

		delete self.storage.perspectives[id];

		return cont(true);
	};

	// #reset {{{2

	PrefsBackendTemporary.prototype.reset = function (cont) {
		var self = this;

		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		self.debug(null, 'Resetting perspectives');

		self.storage = {
			perspectives: {}
		};

		return cont(true);
	};

	// PrefsModule {{{1

	/**
	 * Superclass for prefs modules, which provide a way to:
	 *
	 *   1. Save the configuration from a bound object to a perspective.
	 *   2. Load the configuration from a perspective to a bound object.
	 *
	 * Each prefs module subclass typically works on a single class for its bound object.
	 *
	 * @param {object} target
	 * What bound object to interact with.
	 *
	 * @class
	 *
	 * @property {object} target
	 * What bound object to interact with.
	 */

	var PrefsModule = makeSubclass('PrefsModule', Object, function (target) {
		var self = this;

		self.target = target;
	});

	// #load {{{2

	/**
	 * Applies the provided configuration to the target.
	 */

	PrefsModule.prototype.load = function (config) {
		throw new Error('Abstract method load() not implemented by subclass ' + this.constructor.name);
	};

	// #save {{{2

	/**
	 * Pulls configuration from the target and returns it as an object that can be stored by the
	 * preferences backend.
	 */

	PrefsModule.prototype.save = function () {
		throw new Error('Abstract method save() not implemented by subclass ' + this.constructor.name);
	};

	// PrefsModuleView {{{1

	/**
	 * Manages configuration of a view.
	 *
	 * @param {View} target
	 * What bound object to interact with.
	 *
	 * @class
	 *
	 * @property {View} target
	 * What bound object to interact with.
	 */

	var PrefsModuleView = makeSubclass('PrefsModuleView', PrefsModule, function () {
		var self = this
			, args = Array.prototype.slice.call(arguments);

		self.super.ctor.apply(self, args);

		if (!(self.target instanceof View)) {
			throw new Error('Call Error: `target` must be an instance of View');
		}
	});

	// #load {{{2

	PrefsModuleView.prototype.load = function (config) {
		var self = this;

		if (config == null) {
			return;
		}

		if (config.filter == null) {
			self.target.clearFilter({
				updateData: false,
				savePrefs: false
			});
		}
		else {
			self.target.setFilter(config.filter, null, {
				updateData: false,
				savePrefs: false
			});
		}

		if (config.sort == null) {
			self.target.clearSort({
				updateData: false,
				savePrefs: false
			});
		}
		else {
			self.target.setSort(config.sort, {
				updateData: false,
				savePrefs: false
			});
		}

		if (config.group == null) {
			self.target.clearGroup({
				updateData: false,
				savePrefs: false
			});
		}
		else {
			self.target.setGroup(config.group, {
				updateData: false,
				savePrefs: false
			});
		}

		if (config.pivot == null) {
			self.target.clearPivot({
				updateData: false,
				savePrefs: false
			});
		}
		else {
			self.target.setPivot(config.pivot, {
				updateData: false,
				savePrefs: false
			});
		}

		if (config.aggregate == null) {
			self.target.clearAggregate({
				updateData: false,
				savePrefs: false
			});
		}
		else {
			self.target.setAggregate(config.aggregate, {
				updateData: false,
				savePrefs: false
			});
		}
	};

	// #save {{{2

	PrefsModuleView.prototype.save = function () {
		var self = this;

		var prefs = {};

		var sortSpec = self.target.getSort();
		if (sortSpec) {
			prefs.sort = sortSpec;
		}

		var filterSpec = self.target.getFilter();
		if (filterSpec) {
			prefs.filter = deepCopy(filterSpec);
			walkObj(prefs.filter, function (x) {
				if (window.numeral && numeral.isNumeral(x)) {
					return x._value;
				}
				else {
					return x;
				}
			}, {
				callOnNodes: true,
				replace: true
			});
		}

		var groupSpec = self.target.getGroup();
		if (groupSpec) {
			prefs.group = groupSpec;
		}

		var pivotSpec = self.target.getPivot();
		if (pivotSpec) {
			prefs.pivot = pivotSpec;
		}

		var aggregateSpec = self.target.getAggregate();
		if (aggregateSpec) {
			prefs.aggregate = aggregateSpec;
		}

		return prefs;
	};

	// #reset {{{2

	PrefsModuleView.prototype.reset = function () {
		var self = this;

		self.target.reset({
			updateData: false,
			savePrefs: false
		});
	};

	// PrefsModuleGrid {{{1

	/**
	 * Manages configuration of a grid.
	 *
	 * @param {Grid} target
	 * What bound object to interact with.
	 *
	 * @class
	 *
	 * @property {Grid} target
	 * What bound object to interact with.
	 */

	var PrefsModuleGrid = makeSubclass('PrefsModuleGrid', PrefsModule, function () {
		var self = this
			, args = Array.prototype.slice.call(arguments);

		self.super.ctor.apply(self, args);

		if (!(self.target instanceof Grid)) {
			throw new Error('Call Error: `target` must be an instance of Grid');
		}
	});

	// #load {{{2

	PrefsModuleGrid.prototype.load = function (config) {
		var self = this;

		if (config == null) {
			return;
		}

		if (config.colConfig != null) {
			self.target.setColConfig(OrdMap.deserialize(config.colConfig), {
				from: 'prefs',
				redraw: false,
				savePrefs: false
			});
		}
	};

	// #save {{{2

	PrefsModuleGrid.prototype.save = function () {
		var self = this;

		var prefs = {};

		var colConfig = self.target.getColConfig();
		if (colConfig != null) {
			prefs.colConfig = colConfig.serialize();
		}

		return prefs;
	};

	// #reset {{{2

	PrefsModuleGrid.prototype.reset = function () {
		var self = this;

		self.target.resetColConfig();
	};

	// PrefsModuleGraph {{{1

	/**
	 * Manages configuration of a graph.
	 *
	 * @param {Graph} target
	 * What bound object to interact with.
	 *
	 * @class
	 *
	 * @property {Graph} target
	 * What bound object to interact with.
	 */

	var PrefsModuleGraph = makeSubclass('PrefsModuleGraph', PrefsModule, function () {
		var self = this
			, args = Array.prototype.slice.call(arguments);

		self.super.ctor.apply(self, args);

		if (!(self.target instanceof Graph)) {
			throw new Error('Call Error: `target` must be an instance of Graph');
		}
	});

	// #load {{{2

	PrefsModuleGraph.prototype.load = function (config) {
		var self = this;

		if (config == null) {
			return;
		}

		self.target.setUserConfig(config);
	};

	// #save {{{2

	PrefsModuleGraph.prototype.save = function () {
		var self = this;

		var prefs = deepDefaults(self.target.userConfig, {
			plain: {},
			group: {},
			pivot: {}
		});



		return prefs;
	};

	// #reset {{{2

	PrefsModuleGraph.prototype.reset = function () {
	};

	// PrefsModuleMeta {{{1

	/**
	 * Manages configuration of a perspective.  It sounds really weird, but this is a way to store
	 * additional information on the perspective which must be serialized.
	 *
	 * @param {Perspective} target
	 * What bound object to interact with.
	 *
	 * @class
	 *
	 * @property {Perspective} target
	 * What bound object to interact with.
	 */

	var PrefsModuleMeta = makeSubclass('PrefsModuleMeta', PrefsModule, function () {
		var self = this
			, args = Array.prototype.slice.call(arguments);

		self.super.ctor.apply(self, args);

		if (!(self.target instanceof Perspective)) {
			throw new Error('Call Error: `target` must be an instance of Perspective');
		}
	});

	// #load {{{2

	PrefsModuleMeta.prototype.load = function (config) {
		var self = this;

		if (config != null) {
			self.target.meta = config;
		}
	};

	// #save {{{2

	PrefsModuleMeta.prototype.save = function () {
		var self = this;

		return self.target.meta;
	};

	// #reset {{{2

	PrefsModuleMeta.prototype.reset = function () {
	};

	// Perspective {{{1

	// Constructor {{{2

	/**
	 * Create a perspective.
	 *
	 * @param {string} [id=uuid()]
	 * The ID of the perspective.  If not provided, creates a new UUID for it.
	 *
	 * @param {string} name
	 * The name of the perspective; this is what's shown in the user interface.
	 *
	 * @param {object} config
	 *
	 * @param {Object.<string,PrefsModule>} modules
	 *
	 * @param {object} [opts]
	 *
	 * @param {boolean} [opts.isTemporary=false]
	 * If true, then the perspective will not be saved automatically, but it can be made permanent.
	 *
	 * @param {boolean} [opts.isEssential=false]
	 * If true, then the perspective cannot be renamed or deleted.  A reset will not remove it.
	 *
	 * @param {boolean} [opts.isConstant=false]
	 * If true, then the perspective will not be saved if it has been changed.
	 *
	 * @class
	 *
	 * @property {string} id See above.
	 * @property {object} config See above.
	 * @property {Object.<string,PrefsModule>} modules See above.
	 * @property {object} opts See above.
	 *
	 * @property {boolean} isUnsaved
	 * If true, then the perspective has been changed and needs to be saved.
	 */

	var Perspective = makeSubclass('Perspective', Object, function (id, name, config, modules, opts) {
		var self = this;

		if (id != null && typeof id !== 'string') {
			throw new Error('Call Error: `id` must be null or a string')
		}
		if (name != null && typeof name !== 'string') {
			throw new Error('Call Error: `name` must be null or a string');
		}

		if (id == null) {
			id = uuid();
		}

		if (name == null) {
			name = id;
		}

		self.id = id;
		self.name = name;
		self.config = config;
		self.modules = modules;
		self.isUnsaved = false;
		self.opts = deepDefaults(opts, {
			isEssential: false,
			isTemporary: false,
			isConstant: false
		});
	});

	mixinDebugging(Perspective, function () {
		return sprintf$1.sprintf('PREFS // PERSPECTIVE (%s)', this.id);
	});

	// #load {{{2

	/**
	 * Push the configuration of this perspective to all bound modules.
	 *
	 * @param {function} [cont]
	 */

	Perspective.prototype.load = function (modules, cont) {
		var self = this;

		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		if (modules == null) {
			modules = underscore.keys(self.modules);
		}

		self.debug(null, 'Loading perspective using these modules: %s', JSON.stringify(modules));

		// Go through every module that we have preferences for and load them into the bound components.

		underscore.each(modules, function (moduleName) {
			self.debug(null, 'Loading module: moduleName = %s ; config = %O', moduleName, self.config[moduleName]);
			self.modules[moduleName].load(self.config[moduleName]);
		});

		return cont(true);
	};

	// #save {{{2

	/**
	 * Receive configuration from all bound modules and update this perspective's configuration.
	 *
	 * @param {function} [cont]
	 */

	Perspective.prototype.save = function (cont) {
		var self = this;

		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		self.debug(null, 'Saving perspective');

		// Go through every module that we have preferences for and save them from the bound components.

		underscore.each(self.modules, function (module, moduleName) {
			self.config[moduleName] = module.save();
			self.debug(null, 'Saving module: moduleName = %s ; config = %O', moduleName, self.config[moduleName]);
		});

		return cont(self.config);
	};

	// Registries {{{1

	/**
	 * Associates backend names with classes implementing those modules.
	 */
	var PREFS_BACKEND_REGISTRY = new OrdMap();

	/**
	 * Associates module names with classes implementing those modules.
	 */
	var PREFS_MODULE_REGISTRY = new OrdMap();

	PREFS_BACKEND_REGISTRY.set('localStorage', PrefsBackendLocalStorage);
	PREFS_BACKEND_REGISTRY.set('temporary', PrefsBackendTemporary);

	PREFS_MODULE_REGISTRY.set('view', PrefsModuleView);
	PREFS_MODULE_REGISTRY.set('grid', PrefsModuleGrid);
	PREFS_MODULE_REGISTRY.set('graph', PrefsModuleGraph);
	PREFS_MODULE_REGISTRY.set('meta', PrefsModuleMeta);

	// Imports {{{1

	// View {{{1
	// JSDoc Types {{{2
	// View~Data {{{3

	/**
	 * @typedef View~Data
	 *
	 * @property {boolean} isPlain
	 * @property {boolean} isGroup
	 * @property {boolean} isPivot
	 * @property {Array.<View~Data_Row>} data
	 */

	// View~Data_Row {{{3

	/**
	 * @typedef View~Data_Row
	 *
	 * @property {number} rowNum A unique row number, which is used to track rows when they are moved
	 * within the GridTable instance, e.g. by reordering the rows manually, or by sorting.
	 *
	 * @property {Object.<string, View~Data_Field>} rowData Contains the data for the row; keys are
	 * field names, and values are objects representing the value of that field within the row.
	 */

	// View~Data_Field {{{3

	/**
	 * @typedef View~Data_Field
	 *
	 * @property {any} orig The original representation of the data as it came from the data source.
	 * This is mostly only useful when displaying the value, when no `render` function has been
	 * provided.
	 *
	 * @property {any} value The internal representation of the field's value, which is used for sorting
	 * and filtering.  This corresponds to the type of the field, e.g. when the field has a type of
	 * "date," this property contains a Moment instance.
	 *
	 * @property {View~Data_Field_Render} [render] If this property exists, it specifies a function
	 * that is used to turn the internal representation into a printable value that will be placed into
	 * the cell when the table is output.
	 */

	// View~Data_Field_Render {{{3

	/**
	 * A function called by the GridTable instance to produce a value that will be placed into a cell in
	 * the table output.  An example usage would be to create a link based on the value of the cell.
	 *
	 * @callback View~Data_Field_Render
	 *
	 * @returns {Element|jQuery|string} What should be put into the cell in the table output.
	 */

	// View~FilterSpec {{{3

	/**
	 * @typedef {Object<string,string>|Object<string,View~FilterSpecValue>} View~FilterSpec
	 * The specification used for filtering within a data view.  The keys are column names, and the
	 * values are either strings (implying an equality relationship) or objects indicating a more
	 * complex relationship.
	 */

	// View~FilterSpecValue {{{3

	/**
	 * @typedef {Object<string,any>} View~FilterSpecValue
	 * A value within the filter spec object.  In order for a row to "pass" the filter, all of the
	 * conditions supplied must be true.  At least one of the following must be provided.
	 *
	 * @property {string|number|Date} [$eq] Allow things equal to the value.
	 * @property {string|number|Date} [$ne] Allow things not equal to the value.
	 * @property {string|number|Date} [$gt] Allow things greater than the value.
	 * @property {string|number|Date} [$gte] Allow things greater than or equal to the value.
	 * @property {string|number|Date} [$lt] Allow things less than the value.
	 * @property {string|number|Date} [$lte] Allow things less than or equal to the value.
	 * @property {Array.<string|number>} [$in] Allow things that are elements of the set value.
	 * @property {Array.<string|number>} [$nin] Allow things that are not elements of the set value.
	 */

	// View~GroupSpec {{{3

	/**
	 * @typedef {object} View~GroupSpec
	 * Specifies how to group the data.
	 *
	 * @property {Array.<View~GroupSpecElt|string>} fieldNames
	 * List of the fields to group by.  When an element is a string, that's the same as being an object
	 * with only the `field` property, i.e. `['foo'] = [{field: 'foo'}]`.
	 *
	 * @property {Array.<Array.<string>>} addRowVals
	 * Additional rowvals to add, even if they don't exist in the data naturally.
	 */

	// View~GroupSpecElt {{{3

	/**
	 * @typedef {object} View~GroupSpecElt
	 *
	 * @property {string} field
	 * Name of the field to use for grouping.
	 *
	 * @property {function} [fun]
	 * Name of a {@link GroupFunction} from the {@link GROUP_FUNCTION_REGISTRY} to change how we group
	 * by this field.
	 */

	// View~PivotSpec {{{3

	/**
	 * @typedef {object} View~PivotSpec
	 * An object telling how to pivot the data.
	 *
	 * @property {Array.<object|string>} fieldNames
	 * List of the fields to pivot by.  When an element is a string, that's the same as being an object
	 * with only the `field` property, i.e. `['foo'] = [{field: 'foo'}]`.
	 *
	 * @property {string} fieldNames[].field
	 * Name of the field to use for pivotting.
	 *
	 * @property {function} [fieldNames[].fun]
	 * Name of a {@link GroupFunction} from the {@link GROUP_FUNCTION_REGISTRY} to change how we pivot
	 * by this field.
	 *
	 * @property {Array.<Array.<string>>} addColVals
	 * Additional colvals to add, even if they don't exist in the data naturally.
	 */

	// View~AggregateSpec {{{3

	/**
	 * @typedef {object} View~AggregateSpec
	 * An object telling what aggregate functions to calculate on the data.
	 *
	 * @property {Array.<View~AggregateTypeSpec>} cell
	 * Aggregate functions applied over the rows that match a single rowval and colval.  Only calculated
	 * for pivot output.
	 *
	 * @property {Array.<View~AggregateTypeSpec>} group
	 * Aggregate functions applied over the rows that match a single rowval.  Calculated for both group
	 * summary output and pivot output.
	 *
	 * @property {Array.<View~AggregateTypeSpec>} pivot
	 * Aggregate functions applied over the rows that match a single colval.  Only calculated for pivot
	 * output.
	 *
	 * @property {Array.<View~AggregateTypeSpec>} all
	 * Aggregate functions applied over all rows.  Calculated for both group summary output and pivot
	 * output.
	 */

	// View~AggregateTypeSpec {{{3

	/**
	 * @typedef {object} View~AggregateTypeSpec
	 * An object specifying a single aggregate function.
	 *
	 * @property {string} fun
	 * Name of the aggregate function to use, e.g. "count" or "min".
	 *
	 * @property {string} [name]
	 * What should be displayed when the value of this function is output.  When not provided, defaults
	 * to "[function] of [fields]" e.g. "Min of Date".
	 *
	 * @property {Array.<string>} [fields]
	 * A list of names referring to the fields to which the aggregate should be applied.  Should have a
	 * length equal to `AGGREGATE_REGISTRY[fun].fieldCount` or else bad things may happen.
	 *
	 * @property {boolean} [isHidden=false]
	 * If true, then this aggregate is hidden, i.e. it is calculated (so you could sort on it) but it
	 * isn't displayed in the output.
	 *
	 * @property {boolean} [debug=false]
	 * If true, then extra debugging messages are emitted for this aggregate function.
	 *
	 * @property {boolean} [shouldGraph=false]
	 * If true, then this aggregate should be used for graphing.
	 */

	// View~SortSpec {{{3

	/**
	 * @typedef {object} View~SortSpec
	 *
	 * @property {View~SortSpecVert} vertical
	 * @property {View~SortSpecHoriz} horizontal
	 */

	/**
	 * @typedef {View~SortSpecVertPlain|View~SortSpecVertGroup|View~SortSpecVertPivot} View~SortSpecVert
	 *
	 * @property {string} dir
	 * Which direction to sort, either "ASC" or "DESC".
	 */

	/**
	 * @typedef {object} View~SortSpecVertPlain
	 *
	 * @property {string} field
	 * @property {Array.<string>} [values]
	 */

	/**
	 * @typedef {object} View~SortSpecVertGroup
	 *
	 * @property {string} [field]
	 * @property {number} [groupFieldIndex]
	 * @property {Array.<string>} [values]
	 * @property {string} [aggType]
	 * @property {number} [aggNum]
	 */

	/**
	 * @typedef {object} View~SortSpecVertPivot
	 *
	 * @property {string} [field]
	 * @property {string} [groupFieldIndex]
	 * @property {Array.<string>} [values]
	 * This is sort method #1.
	 *
	 * @property {Array.<string>} [colVal]
	 * @property {number} [colValIndex]
	 * Reorders rowvals (i.e. sorting vertically) by the result of a cell aggregate function applied to
	 * data with the specified colval.  Use `aggNum` to indicate which.  This is sort method #4.
	 *
	 * @property {string} [aggType]
	 * Setting this to "group" indicates reordering rowvals (i.e. sorting vertically) by the result of a
	 * group aggregate function.  Use `aggNum` to indicate which one.  This is sort method #6.
	 *
	 * @property {number} [aggNum]
	 * The number of the aggregate to use for sorting.  Used when:
	 *   - Using `colVal` or `colValIndex`.
	 *   - Using `{aggType: 'group'}`.
	 */

	/**
	 * @typedef {View~SortSpecHorizPivot} View~SortSpecHoriz
	 *
	 * @property {string} dir
	 * Which direction to sort, either "ASC" or "DESC".
	 */

	/**
	 * @typedef {object} View~SortSpecHorizPivot
	 *
	 * @property {string} [field]
	 * @property {string} [pivotFieldIndex]
	 * @property {Array.<string>} [values]
	 * This is sort method #3.
	 *
	 * @property {Array.<string>} [rowVal]
	 * @property {number} [rowValIndex]
	 * Reorders colvals (i.e. sorting horizontally) by the result of a cell aggregate function applied
	 * to data with the specified rowval.  Use `aggNum` to indicate which.  This is sort method #2.
	 *
	 * @property {string} [aggType]
	 * Setting this to "pivot" indicates reordering colvals (i.e. sorting horizontally) by the result of
	 * a pivot aggregate function.  Use `aggNum` to indicate which one.  This is sort method #5.
	 *
	 * @property {number} [aggNum]
	 * The number of the aggregate to use for sorting.  Used when:
	 *   - Using `rowVal` or `rowValIndex`.
	 *   - Using `{aggType: 'pivot'}`.
	 */

	// View~OperationsPerformed {{{3

	/**
	 * @typedef {object} View~OperationsPerformed
	 *
	 * @property {boolean} filter
	 * True if the data was filtered.
	 *
	 * @property {boolean} group
	 * True if the data was grouped.
	 *
	 * @property {boolean} pivot
	 * True if the data was pivotted.
	 *
	 * @property {boolean} sort
	 * True if the data was sorted.
	 */

	// Constructor {{{2

	/**
	 * This represents a view of the data obtained by a data source.  While the pool of available data
	 * is the same, the way its represented to the user (filtered, sorted, grouped, or pivotted)
	 * changes.
	 *
	 * @class
	 *
	 * @property {Source} source
	 *
	 * @property {View~FilterSpec} filterSpec
	 *
	 * @property {View~SortSpec} sortSpec
	 *
	 * @property {View~GroupSpec} groupSpec
	 *
	 * @property {View~PivotSpec} pivotSpec
	 *
	 * @property {Timing} timing For keeping track of how long it takes to do things in the view.
	 */

	var View = makeSubclass('View', Object, function (source, name, opts) {
		var self = this;

		if (!(source instanceof Source) && !(source instanceof View)) {
			throw new Error('Call Error: `source` must be an instance of MIE.WC_DataVis.Source or MIE.WC_DataVis.View');
		}

		opts = deepDefaults(opts, {
			prefs: null,
			saveViewConfig: true,
			groupIsPivot: false
		});

		if (opts.prefs != null && !(opts.prefs instanceof Prefs)) {
			throw new Error('Call Error: `opts.prefs` must be null or an instance of MIE.WC_DataVis.Prefs');
		}

		self.source = source;
		self.opts = opts;

		self.source.on('dataUpdated', function () {
			self.clearCache();
			self.fire('dataUpdated');
		});

		self.source.on('fetchDataCancel', function () {
			self.lock.clear();
		});

		self.echo(self.source, ['fetchDataBegin', 'fetchDataEnd']);

		self.name = name || source.getName() || gensym();
		self.colConfig = new OrdMap();

		self.timing = new Timing();

		self.lock = new Lock(self.getDebugTag());

		// Set the default configuration for a new View.  Setting explicit defaults is a good practice to
		// maintain, but it also makes sure that when prefs are loaded later, any `null` values they set
		// compare correctly to what we already have, and not make it look like something has changed.

		self.sortSpec = null;
		self.filterSpec = null;
		self.groupSpec = null;
		self.pivotSpec = null;
		self.aggregateSpec = objFromArray(['group', 'pivot', 'cell', 'all'], [[{fun: 'count'}]]);

		if (self.opts.prefs != null) {
			self.prefs = opts.prefs;
		}
		else {
			self.debug(null, 'Creating new Prefs instance');
			self.prefs = new Prefs(self.name);
		}

		self.isBoundToPrefs = false;
	});

	// Mixins {{{2

	mixinEventHandling(View, [
		'fetchDataBegin'      // Started fetching data from the source.
	, 'fetchDataEnd'        // Done fetching data from the source.
	, 'getTypeInfo'         // Type information has been retrieved from the source.
	, 'dataUpdated'         // The data has changed in the source.
	, 'workBegin'           // The view has started operating on the data.
	, 'workEnd'             // The view has finished operating on the data.

	, 'sortSet'             // When the sort has been set.  Args: (field, direction)
	, 'filterSet'           // When the filter has been set.  Args: (spec)
	, 'groupSet'            // When the grouping has been set.  Args: (spec)
	, 'pivotSet'            // When the pivot config has been set.  Args: (spec)
	, 'aggregateSet'        // When the aggregate config has been set.  Args: (spec)

	, 'sortBegin'           // A sort operation has started.
	, 'sort'                // Sort information for a row is available.
	, 'sortEnd'             // A sort operation has finished.
	, 'filterBegin'         // A filter operation has started.
	, 'filter'              // Filter information for a row is available.
	, 'filterEnd'           // A filter operation has finished.

	, 'invalidFilterField'  // A filtered field does not exist in the source data.
	, 'invalidGroupField'   // A grouped field does not exist in the source data.
	, 'invalidPivotField'   // A pivotted field does not exist in the source data.
	, 'invalidSortField'    // A sorted field does not exist in the source data.
	, 'invalidAggregate'    // An aggregate function is invalid.
	]);

	delegate(View, 'source', ['getUniqueVals', 'convertAll', 'setToolbar']);

	mixinDebugging(View);
	mixinLogging(View);

	// Event JSDoc {{{3

	/**
	 * Fired when the view has started getting data from the source.
	 *
	 * @event View#fetchDataBegin
	 */

	/**
	 * Fired when the view has finished getting data from the source.
	 *
	 * @event View#fetchDataEnd
	 */

	/**
	 * Fired when new type information is available from the source.
	 *
	 * @event View#getTypeInfo
	 */

	/**
	 * Fired when new data is available from the source.
	 *
	 * @event View#dataUpdated
	 */

	/**
	 * Fired when the view has started doing work with data.
	 *
	 * @event View#workBegin
	 */

	/**
	 * Fired when the view has finished doing work with data.
	 *
	 * @event View#workEnd
	 *
	 * @param {View~OperationsPerformed} ops
	 * An object identifying what operations were performed.
	 */

	/**
	 * Fired when the sort configuration is set in the view.
	 *
	 * @event View#sortSet
	 */

	/**
	 * Fired when the filter configuration is set in the view.
	 *
	 * @event View#filterSet
	 */

	/**
	 * Fired when the group configuration is set in the view.
	 *
	 * @event View#groupSet
	 */

	/**
	 * Fired when the pivot configuration is set in the view.
	 *
	 * @event View#pivotSet
	 */

	/**
	 * Fired when the aggregate configuration is set in the view.
	 *
	 * @event View#aggregateSet
	 */

	/**
	 * Fired when the view starts a sort operation.
	 *
	 * @event View#sortBegin
	 */

	/**
	 * Fired when the view has determined the final sort position of a record.  One place this is used
	 * is by GridTable to update itself without having to completely redraw from scratch after sorting.
	 *
	 * @event View#sort
	 *
	 * @param {number} rowNum
	 * The unique ID of the row.
	 *
	 * @param {number} index
	 * The index of the row in the sorted output.
	 */

	/**
	 * Fired when the view finishes a sort operation.
	 *
	 * @event View#sortEnd
	 */

	/**
	 * Fired when the view starts a filter operation.
	 *
	 * @event View#filterBegin
	 */

	/**
	 * Fired when the view has determined whether a record should be shown or hidden.  One place this is
	 * used is by GridTable to update itself without having to completely redraw from scratch after
	 * filtering.
	 *
	 * @event View#filter
	 *
	 * @param {number} rowNum
	 * The unique ID of the row.
	 *
	 * @param {boolean} isHidden
	 * If true, the row should be hidden; if false, it should be shown.
	 */

	/**
	 * Fired when the view finishes a filter operation.
	 *
	 * @event View#filterEnd
	 */

	/**
	 * Fired when attempting to filter by an invalid field.
	 *
	 * @event View#invalidFilterField
	 */

	/**
	 * Fired when attempting to group by an invalid field.
	 *
	 * @event View#invalidGroupField
	 */

	/**
	 * Fired when attempting to pivot by an invalid field.
	 *
	 * @event View#invalidPivotField
	 */

	/**
	 * Fired when attempting to sort by an invalid field.
	 *
	 * @event View#invalidSortField
	 */

	/**
	 * Fired when attempting to set an invalid aggregate.
	 *
	 * @event View#invalidAggregate
	 */

	// #toString {{{2

	View.prototype.toString = function () {
		var self = this;
		return 'View (' + self.name + ')';
	};

	// #getDebugTag {{{2

	View.prototype.getDebugTag = function () {
		var self = this;
		return 'VIEW {name="' + self.name + '"}';
	};

	// #_maybeDecode {{{2

	View.prototype._maybeDecode = function (tag, fti) {
		var self = this;

		if (fti.needsDecoding) {
			self.debug(null, 'Converting data: { field = "%s", type = "%s" }',
				fti.field, fti.type);

			self.source.convertAll(self.data.dataByRowId, fti.field);
		}

		fti.deferDecoding = false;
		fti.needsDecoding = false;
	};

	// #init {{{2

	View.prototype.init = function (cont) {
		var self = this;

		if (typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be a function');
		}

		return self.prefs.prime(function () {
			if (!self.isBoundToPrefs) {
				self.prefs.bind('view', self);
				self.isBoundToPrefs = true;
			}

			return cont();
		});
	};

	// #addClient {{{2

	/**
	 * Keep track of the clients that are using this view.  The only reason we have this is so that we
	 * can tell if a graph is watching this view or not.
	 */

	View.prototype.addClient = function (client, kind) {
		var self = this;

		self.clients = self.clients || {};
		self.clients[kind] = self.clients[kind] || [];
		self.clients[kind].push(client);
	};

	// #hasClientKind {{{2

	/**
	 * Check to see if we have a client of the specified kind.
	 */

	View.prototype.hasClientKind = function (kind) {
		var self = this;

		return getPropDef(0, self.clients, kind, 'length') > 0;
	};

	// #getRowCount {{{2

	/**
	 * Get the number of rows currently being shown by the view.
	 *
	 * @return {number} The number of rows shown in the table output.
	 */

	View.prototype.getRowCount = function () {
		var self = this;

		if (self.data.isPlain) {
			return self.data.data.length;
		}
		else if (self.data.isGroup) {
			return underscore.reduce(self.data.data, function (prev1, groupedData, rowValNum) {
				return prev1 + groupedData.length;
			}, 0);
		}
		else if (self.data.isPivot) {
			return underscore.reduce(self.data.data, function (prev1, groupedData, rowValNum) {
				return prev1 + underscore.reduce(groupedData, function (prev2, pivottedData, colValNum) {
					return prev2 + pivottedData.length;
				}, 0);
			}, 0);
		}
		else {
			throw new Error('Unable to determine row count when data is not plain, but also not grouped.');
		}
	};

	// #getTotalRowCount {{{2

	/**
	 * Get the number of rows that could be shown by the view.
	 *
	 * @return {number} The total number of rows in the data, including those which aren't currently
	 * being sorted (e.g. because they have been filtered out).
	 */

	View.prototype.getTotalRowCount = function () {
		return this.source.cache.data.length;
	};

	// #setSort {{{2

	/**
	 * Set the sorting spec for the view.
	 *
	 * @param {View~SortSpec} spec
	 * @param {object} [opts]
	 */

	View.prototype.setSort = function (spec, opts) {
		var self = this
			, args = Array.prototype.slice.call(arguments)
			, isDifferent = false;

		if (self.lock.isLocked()) {
			return self.lock.onUnlock(function () {
				self.setSort.apply(self, args);
			}, 'Waiting to set sort: ' + JSON.stringify(spec));
		}

		opts = deepDefaults(opts, {
			sendEvent: true,
			dontSendEventTo: [],
			updateData: true,
			savePrefs: true
		});

		self.debug('SET SORT', 'spec = %O', spec);

		isDifferent = !underscore.isEqual(self.sortSpec, spec);

		self.sortSpec = spec;

		if (opts.sendEvent) {
			self.fire('sortSet', {
				notTo: opts.dontSendEventTo
			}, spec);
		}

		if (isDifferent && self.prefs != null && opts.savePrefs) {
			self.prefs.save();
		}

		self.clearCache();

		if (opts.updateData) {
			self.getData();
		}

		return true;
	};

	// #getSort {{{2

	View.prototype.getSort = function () {
		var self = this;

		return self.sortSpec;
	};

	// #clearSort {{{2

	/**
	 * Clear the sort spec for the view.
	 */

	View.prototype.clearSort = function (opts) {
		return this.setSort(null, opts);
	};

	// #sort {{{2

	/**
	 * Sort this view of the data by the specified column name, in the specified direction.  This is
	 * asynchronous because long running sorts need to keep the user interface responsive.
	 *
	 * @param {function} cont Continuation function to which the sorted data is passed.
	 */

	View.prototype.sort = function (cont) {
		var self = this
			, timingEvt = ['Data Source "' + self.source.name + '" : ' + self.name, 'Sorting']
			, aggInfo = getProp(self.data, 'agg', 'info');

		if (self.sortSpec == null) {
			return cont(false);
		}

		self.debug('SORT', 'Beginning sort: %s', JSON.stringify(self.sortSpec));

		/**
		 * Determine the comparison function that should be used to perform the sort operation.
		 *
		 * @param {object} spec
		 * The sort specification; only used for log messages.
		 *
		 * @param {Source~TypeInfo} fti
		 * The type information for the field to sort by.
		 *
		 * @returns {function}
		 * A function that is used to perform the sort.  The comparison function returns -1 when A < B, 0
		 * when A = B, and +1 when A > B.  Returns null when the sort cannot be performed (e.g. because no
		 * comparison function could be found).
		 */

		var determineCmp = function (spec, fti) {
			var cmp;

			if (fti == null) {
				log.error('Unable to sort: no type information {spec = %O}', spec);
				return null;
			}

			if (typeof fti === 'string' || fti instanceof String) {
				fti = {
					type: fti
				};
			}

			if (fti.type == null) {
				log.error('Unable to sort: type unknown {spec = %O, fti = %O}', spec, fti);
				return null;
			}

			// FIXME Should this be based on the internal type?

			cmp = getComparisonFn.byType(fti.type);

			if (cmp == null) {
				log.error('Unable to sort: no comparison function for type {spec = %O, type = %s}', spec, fti.type);
				return null;
			}

			// This should never happen, because that would imply that getComparisonFn.byType() is broken.

			if (typeof cmp !== 'function') {
				log.error('Unable to sort: invalid comparison function for type {spec = %O, type = %s}', spec, fti.type);
				return null;
			}

			// Make sure that all the data is decoded first before we try to sort it.  This makes things a
			// lot simpler (i.e. no need to compare a Moment object --- which has already been decoded ---
			// with a string containing a date).

			self._maybeDecode('SORT', fti);

			return cmp;
		};



		// A "bundle" is an array of the values that need to be sorted.  We store the value to sort, plus
		// the index that maps back (somehow) to the corresponding rows.  After sorting is complete, we
		// "unpack" the bundle: going through the bundle in sorted order, moving the data rows around
		// based on the `oldIndex` we store here.

		var packBundle = function (spec, orientation, sortSourceFn) {
			var bundle, len;

			if (sortSourceFn == null) {
				log.error('Unable to sort: no sort source function given {spec = %O}', spec);
				return null;
			}

			switch (orientation) {
			case 'vertical':
				len = self.data.isPlain ? self.data.data.length : self.data.rowVals.length;
				break;
			case 'horizontal':
				len = self.data.isPlain ? self.data.data.length : self.data.colVals.length;
				break;
			default:
				return null;
			}

			bundle = new Array(len);

			for (var i = 0; i < len; i += 1) {
				bundle[i] = {
					oldIndex: i,
					sortSource: sortSourceFn(i)
				};
			}

			return bundle;
		};



		// Unpack the bundle, going through each item in the bundle and using its `oldIndex` to reorder
		// the data and aggregates to match the new sort order.  For vertical orientation, we reorder
		// row-related stuff (groups, i.e. rowvals and group aggregates).  For horizontal orientation, we
		// reorder column-related stuff (pivots, i.e. colvals and pivot aggregates).

		var unpackBundle = function (orientation) {
			return function (sorted) {
				self.debug('SORT // UNPACK',
					'Unpacking bundle of %d sorted chunks in %s orientation',
					sorted.length, orientation);

				var origData = self.data.data;
				var origRowVals = getProp(self.data, 'rowVals');
				var origColVals = getProp(self.data, 'colVals');
				var origCellAgg = getProp(self.data, 'agg', 'results', 'cell');
				var origGroupAgg = getProp(self.data, 'agg', 'results', 'group');
				var origPivotAgg = getProp(self.data, 'agg', 'results', 'pivot');

				var ai // Aggregate Index
					, rvi // Row Value Index
				;

				switch (orientation) {
				case 'vertical':
					self.data.data = [];

					if (origRowVals != null) {
						self.data.rowVals = [];
					}

					if (origCellAgg != null) {
						self.data.agg.results.cell = [];
					}

					if (origGroupAgg != null) {
						self.data.agg.results.group = [];
					}

					// Reorder data and rowvals.

					var rowValIdxMap = {};

					underscore.each(sorted, function (s, newIndex) {
						// For plain output, fire the "sort" event so that the rows (if the grid table is showing
						// all of them) can just be shuffled around, and the table doesn't have to be recreated.

						if (self.data.isPlain) {
							self.fire('sort', {
								silent: true
							}, origData[s.oldIndex].rowNum, newIndex);
						}

						self.data.data[newIndex] = origData[s.oldIndex];
						if (origRowVals != null) {
							self.data.rowVals[newIndex] = origRowVals[s.oldIndex];
						}

						rowValIdxMap[s.oldIndex] = newIndex;
					});

					if (self.data.isGroup || self.data.isPivot) {
						// Update the groupMetadata tree's use of rowValIndex to correspond to the new ordering of
						// rowvals.  This means both the `rowValIndex` property of each node in the tree, and the
						// lookup object.  If this isn't done, then some parts of the UI (like the rowvals in group
						// and pivot output) will not change to reflect the new ordering.

						var postorder = function (node, depth) {
							if (node.children == null) {
								node.rowValIndex = rowValIdxMap[node.rowValIndex];
								self.data.groupMetadata.lookup.byRowValIndex[node.rowValIndex] = node;
							}
							else {
								underscore.each(node.children, function (child) {
									postorder(child, depth + 1);
								});
								if (depth > 0) {
									// FIXME Assumes that node.children.length > 0.
									node.rowValIndex = node.children[underscore.keys(node.children)[0]].rowValIndex;
								}
							}
						};

						postorder(self.data.groupMetadata, 0);
					}

					// Reorder cell aggregates.

					if (origCellAgg != null) {
						for (ai = 0; ai < origCellAgg.length; ai += 1) {
							self.data.agg.results.cell[ai] = [];
							underscore.each(sorted, function (s, newIndex) {
								self.data.agg.results.cell[ai][newIndex] = origCellAgg[ai][s.oldIndex];
							});
						}
					}

					// Reorder group aggregates.

					if (origGroupAgg != null) {
						for (ai = 0; ai < origGroupAgg.length; ai += 1) {
							self.data.agg.results.group[ai] = [];
							underscore.each(sorted, function (s, newIndex) {
								self.data.agg.results.group[ai][newIndex] = origGroupAgg[ai][s.oldIndex];
							});
						}
					}

					break;
				case 'horizontal':
					self.data.data = [];

					if (origColVals != null) {
						self.data.colVals = [];
					}

					if (origCellAgg != null) {
						self.data.agg.results.cell = [];
					}

					if (origPivotAgg != null) {
						self.data.agg.results.pivot = [];
					}

					// Reorder data and colvals.

					underscore.each(sorted, function (s, newIndex) {
						self.data.colVals[newIndex] = origColVals[s.oldIndex];
						if (origColVals != null) {
							for (var rvi = 0; rvi < self.data.rowVals.length; rvi += 1) {
								if (self.data.data[rvi] === undefined) {
									self.data.data[rvi] = [];
								}
								self.data.data[rvi][newIndex] = origData[rvi][s.oldIndex];
							}
						}
					});

					// Reorder cell aggregates.

					if (origCellAgg != null) {
						for (ai = 0; ai < origCellAgg.length; ai += 1) {
							self.data.agg.results.cell[ai] = new Array(self.data.rowVals.length);
							for (rvi = 0; rvi < self.data.rowVals.length; rvi += 1) {
								self.data.agg.results.cell[ai][rvi] = new Array(self.data.colVals.length);
								underscore.each(sorted, function (s, newIndex) {
									self.data.agg.results.cell[ai][rvi][newIndex] = origCellAgg[ai][rvi][s.oldIndex];
								});
							}
						}
					}

					// Reorder pivot aggregates.

					if (origPivotAgg != null) {
						for (ai = 0; ai < origPivotAgg.length; ai += 1) {
							self.data.agg.results.pivot[ai] = new Array(self.data.colVals.length);
							underscore.each(sorted, function (s, newIndex) {
								self.data.agg.results.pivot[ai][newIndex] = origPivotAgg[ai][s.oldIndex];
							});
						}
					}

					break;
				}
			};
		};



		var makeFinishCb = function (postProcess, next) {
			return function (sorted) {
				// Run any function that might've been specified to manipulate the data after the fact.

				if (typeof postProcess === 'function') {
					postProcess(sorted);
				}
				else {
					self.data.data = sorted;
				}

				return next(true);
			};
		};



		var performSort = function (orientation, next) {

			// sortSourceFn(index) -> value
			//
			//   The value that we're interested in sorting by, for the element specified by `index`.  It's
			//   a way of abstracting away the differences in how we're sorting (this function yields the
			//   "right thing" whether we're sorting by a cell value, a group aggregate function result, or
			//   something else altogether).

			var fti
				, sortSourceFn
				, spec = getProp(self, 'sortSpec', orientation)
				, sortAlgorithm = 'mergeSort';

			var rvi, cvi, gfi;

			if (spec == null) {
				return next(false);
			}

			spec = deepCopy(spec);

			if (self.data.isPlain) {
				if (orientation === 'horizontal') {
					log.error('Unable to sort: cannot perform horizontal sort on plain data');
					return next(false);
				}
				if (spec.field) {
					if (spec.values) {
						sortAlgorithm = 'pigeonHole';
					}
					else {
						fti = self.typeInfo.get(spec.field);
					}

					// The sort source function accesses the value of the field in the indexed row.  This is as
					// simple as it can get.

					sortSourceFn = function (i) {
						return self.data.data[i].rowData[spec.field].value;
					};
				}
			}
			else if (self.data.isGroup) {
				if (orientation === 'horizontal') {
					log.error('Unable to sort: cannot perform horizontal sort on grouped data');
					return next(false);
				}
				if (spec.field != null) {
					gfi = self.data.groupFields.indexOf(spec.field);

					if (gfi < 0) {
						log.error('Unable to sort: `field` property does not refer to a grouped field ' +
							'{field = "%s", groupFields = %s}', spec.field, self.data.groupFields);
					}
					else {
						spec.groupFieldIndex = gfi;
					}
				}

				if (spec.groupFieldIndex != null) {

					// SORT GROUPS BY GROUP FIELD VALUE
					// ================================
					//
					// SPEC
					//   { groupFieldIndex: number }
					//
					// DESCRIPTION
					//   This sorts groups by the value of one group field.

					if (spec.groupFieldIndex < 0 || spec.groupFieldIndex >= self.data.groupFields.length) {
						log.error('Unable to sort: groupFieldIndex out of range {spec = %O, range = [0,%d]}',
											spec, self.data.groupFields.length);
						return next(false);
					}

					if (spec.values) {
						sortAlgorithm = 'pigeonHole';
					}
					else if (self.data.groupSpec[spec.groupFieldIndex].fun != null) {
						// The values that we're sorting came from a function applied to the value of the group
						// field in the row, e.g. "Day of Week."  Therefore, we can't sort them based on the type
						// of the group field, e.g. date.

						fti = {
							type: GROUP_FUNCTION_REGISTRY.get(self.data.groupSpec[spec.groupFieldIndex].fun).sortType
						};
					}
					else {
						fti = self.typeInfo.get(self.data.groupFields[spec.groupFieldIndex]);
					}

					sortSourceFn = function (i) {
						return self.data.rowVals[i][spec.groupFieldIndex];
					};
				}
				else if (spec.aggType === 'group' && spec.aggNum != null) {

					// SORT GROUPS BY AGGREGATE FUNCTION RESULT
					// ========================================
					//
					// SPEC
					//   { aggType: "group", aggNum: number }
					//
					// DESCRIPTION
					//   This sorts groups by the result of an aggregate function applied to a group.

					if (spec.aggNum < 0 || spec.aggNum >= aggInfo.group.length) {
						log.error('Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}',
											spec, aggInfo.group.length);
						return next(false);
					}

					fti = aggInfo.group[spec.aggNum].instance.getType();
					sortSourceFn = function (i) {
						return self.data.agg.results.group[spec.aggNum][i];
					};
				}
			}
			else if (self.data.isPivot) {
				// See https://1drv.ms/u/s!AuF9WqjL0lB2erNc2Ld6sOCscAs for a diagram showing what all these
				// different sorting options are.
				//
				// #1 - Sort groups by the value of a group field
				// #2 - Sort pivots by the result of a cell aggregate, for a specific group
				// #3 - Sort pivots by the value of a pivot field
				// #4 - Sort groups by the result of a cell aggregate, for a specific pivot
				// #5 - Sort pivots by the result of a pivot aggregate
				// #6 - Sort groups by the result of a group aggregate

				if (spec.field != null) {
					switch (orientation) {
					case 'vertical':
						gfi = self.data.groupFields.indexOf(spec.field);

						if (gfi < 0) {
							log.error('Unable to sort: `field` property does not refer to a grouped field ' +
								'{field = "%s", groupFields = %s}', spec.field, self.data.groupFields);
						}
						else {
							spec.groupFieldIndex = gfi;
						}
						break;

					case 'horizontal':
						var pfi = self.data.pivotFields.indexOf(spec.field);

						if (pfi < 0) {
							log.error('Unable to sort: `field` property does not refer to a pivotted field ' +
								'{field = "%s", pivotFields = %s}', spec.field, self.data.pivotFields);
						}
						else {
							spec.pivotFieldIndex = pfi;
						}
						break;
					}
				}

				if (spec.groupFieldIndex != null) { // #1

					// SORT GROUPS BY GROUP FIELD VALUE
					// ================================
					//
					//   * groupFieldIndex: number

					if (spec.groupFieldIndex < 0 || spec.groupFieldIndex >= self.data.groupFields.length) {
						log.error('Unable to sort: groupFieldIndex out of range {spec = %O, range = [0,%d]}',
											spec, self.data.groupFields.length);
						return next(false);
					}

					if (spec.values) {
						sortAlgorithm = 'pigeonHole';
					}
					else if (self.data.groupSpec[spec.groupFieldIndex].fun != null) {
						// The values that we're sorting came from a function applied to the value of the group
						// field in the row, e.g. "Day of Week."  Therefore, we can't sort them based on the type
						// of the group field, e.g. date.

						fti = {
							type: GROUP_FUNCTION_REGISTRY.get(self.data.groupSpec[spec.groupFieldIndex].fun).sortType
						};
					}
					else {
						fti = self.typeInfo.get(self.data.groupFields[spec.groupFieldIndex]);
					}

					sortSourceFn = function (i) {
						return self.data.rowVals[i][spec.groupFieldIndex];
					};
				}
				else if ((spec.rowVal || spec.rowValIndex != null) && spec.aggNum != null) { // #2

					// SORT PIVOTS BY CELL AGGREGATE RESULT (FOR CERTAIN ROWVAL)
					// =========================================================
					//
					//   * rowVal: [string] -OR- rowValIndex: number
					//   * aggNum: number

					if (spec.rowVal) {
						spec.rowValIndex = -1;
						for (rvi = 0; rvi < self.data.rowVals.length; rvi += 1) {
							if (underscore.isEqual(self.data.rowVals[rvi], spec.rowVal)) {
								spec.rowValIndex = rvi;
								break;
							}
						}
						if (spec.rowValIndex === -1) {
							log.error('Unable to sort: invalid rowVal {spec = %O}', spec);
							return next(false);
						}
					}

					if (spec.rowValIndex < 0 || spec.rowValIndex >= self.data.rowVals.length) {
						log.error('Unable to sort: rowValIndex out of range {spec = %O, range = [0,%d]}',
											spec, self.data.rowVals.length);
						return next(false);
					}

					if (spec.aggNum < 0 || spec.aggNum >= aggInfo.cell.length) {
						log.error('Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}',
											spec, aggInfo.cell.length);
						return next(false);
					}

					fti = aggInfo.cell[spec.aggNum].instance.getType();
					sortSourceFn = function (i) {
						return self.data.agg.results.cell[spec.aggNum][spec.rowValIndex][i];
					};
				}
				else if (spec.pivotFieldIndex != null) { // #3

					// SORT PIVOTS BY PIVOT FIELD VALUE
					// ================================
					//
					//   * pivotFieldIndex: number

					if (spec.pivotFieldIndex < 0 || spec.pivotFieldIndex >= self.data.pivotFields.length) {
						log.error('Unable to sort: pivotFieldIndex out of range {spec = %O, range = [0,%d]}',
											spec, self.data.pivotFields.length);
						return next(false);
					}

					if (spec.values) {
						sortAlgorithm = 'pigeonHole';
					}
					else if (self.data.pivotSpec[spec.pivotFieldIndex].fun != null) {
						// The values that we're sorting came from a function applied to the value of the pivot
						// field in the row, e.g. "Day of Week."  Therefore, we can't sort them based on the type
						// of the pivot field, e.g. date.

						fti = {
							type: GROUP_FUNCTION_REGISTRY.get(self.data.pivotSpec[spec.pivotFieldIndex].fun).sortType
						};
					}
					else {
						fti = self.typeInfo.get(self.data.pivotFields[spec.pivotFieldIndex]);
					}

					sortSourceFn = function (i) {
						return self.data.colVals[i][spec.pivotFieldIndex];
					};
				}
				else if ((spec.colVal || spec.colValIndex != null) && spec.aggNum != null) { // #4

					// SORT GROUPS BY CELL AGGREGATE RESULT (FOR CERTAIN COLVAL)
					// =========================================================
					//
					//   * colVal: [string] -OR- colValIndex: number
					//   * aggNum: number

					if (spec.colVal) {
						spec.colValIndex = -1;
						for (cvi = 0; cvi < self.data.colVals.length; cvi += 1) {
							if (underscore.isEqual(self.data.colVals[cvi], spec.colVal)) {
								spec.colValIndex = cvi;
								break;
							}
						}
						if (spec.colValIndex === -1) {
							log.error('Unable to sort: invalid colVal {spec = %O}', spec);
							return next(false);
						}
					}

					if (spec.colValIndex < 0 || spec.colValIndex >= self.data.colVals.length) {
						log.error('Unable to sort: colValIndex out of range {spec = %O, range = [0,%d]}',
											spec, self.data.colVals.length);
						return next(false);
					}

					if (spec.aggNum < 0 || spec.aggNum >= aggInfo.cell.length) {
						log.error('Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}',
											spec, aggInfo.cell.length);
						return next(false);
					}

					fti = aggInfo.cell[spec.aggNum].instance.getType();
					sortSourceFn = function (i) {
						return self.data.agg.results.cell[spec.aggNum][i][spec.colValIndex];
					};
				}
				else if (spec.aggType === 'pivot' && spec.aggNum != null) { // #5

					// SORT PIVOTS BY PIVOT AGGREGATE RESULT
					// =====================================
					//
					//   * aggType: "pivot"
					//   * aggNum: number

					if (spec.aggNum < 0 || spec.aggNum >= aggInfo.pivot.length) {
						log.error('Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}',
											spec, aggInfo.pivot.length);
						return next(false);
					}

					fti = aggInfo.pivot[spec.aggNum].instance.getType();
					sortSourceFn = function (i) {
						return self.data.agg.results.pivot[spec.aggNum][i];
					};
				}
				else if (spec.aggType === 'group' && spec.aggNum != null) { // #6

					// SORT GROUPS BY GROUP AGGREGATE RESULT
					// =====================================
					//
					//   * aggType: "group"
					//   * aggNum: number

					if (spec.aggNum < 0 || spec.aggNum >= aggInfo.group.length) {
						log.error('Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}',
											spec, aggInfo.group.length);
						return next(false);
					}

					fti = aggInfo.group[spec.aggNum].instance.getType();
					sortSourceFn = function (i) {
						return self.data.agg.results.group[spec.aggNum][i];
					};
				}
				else {
					log.error('Invalid sort spec for pivotted data: ' + JSON.stringify(spec));
					return next(false);
				}
			}

			//console.log(self.typeInfo.asMap());
			//console.log(self.data.agg);

			var cmp, comparison;

			if (sortAlgorithm === 'mergeSort') {
				cmp = determineCmp(spec, fti);
				if (cmp == null) {
					return next(false);
				}

				// NOTE We're intentionally making the sort stable only when sorting ascending.
				//
				// When sorting rowvals/colvals:
				//
				// Since we're always starting from the same set of data (which is sorted asc by each element
				// of the rowval/colval in turn), no matter which direction we sort, this has the effect of
				// making the following work:
				//
				//   X,Y             X,Y            X,Y
				//  -----           -----          -----
				//   A,A             C,C            A,A
				//   A,B             C,B            A,B
				//   A,C             C,A            A,C
				//   B,A  ========>  B,C  =======>  B,A
				//   B,B   X, DESC   B,B   X, ASC   B,B
				//   B,C  ========>  B,A  =======>  B,C
				//   C,A             A,C            C,A
				//   C,B             A,B            C,B
				//   C,C             A,A            C,C
				//
				// This magickally does the expected thing, in every scenario.  Fields other than the one
				// sorted by (in the example above, Y) end up sorted in the same direction, left to right.
				//
				// FIXME This will need to be adjusted when we support multiple sorts.  Both directions should
				// be stable when we do that, or else it won't work as expected.

				comparison = function (a, b) {
					if (spec.dir.toUpperCase() === 'ASC') {
						return cmp(a.sortSource, b.sortSource) <= 0;
					}
					else if (spec.dir.toUpperCase() === 'DESC') {
						return cmp(a.sortSource, b.sortSource) > 0;
					}
					else {
						throw new Error('Invalid sort spec: `dir` must be either "ASC" or "DESC"');
					}
				};
			}

			var bundle = packBundle(spec, orientation, sortSourceFn);
			if (bundle == null) {
				return next(false);
			}

			//console.log(fti);
			//console.log(cmp);
			//console.log(bundle);

			var finish = makeFinishCb(unpackBundle(orientation), next);

			self.debug('SORT', 'Performing sort using %s algorithm', sortAlgorithm);

			switch (sortAlgorithm) {
			case 'mergeSort':
				return mergeSort4(bundle, comparison, finish, self.sortProgress && self.sortProgress.update);
			case 'pigeonHole':
				return pigeonHoleSort(bundle, spec.values, finish);
			default:
				throw new Error('Internal Error: Invalid sort algorithm: ' + sortAlgorithm);
			}
		};



		self.fire('sortBegin');
		self.timing.start(timingEvt);

		if (self.sortProgress
				&& typeof self.sortProgress.begin === 'function') {
			self.sortProgress.begin();
		}

		performSort('horizontal', function (didHorizontal) {
			performSort('vertical', function (didVertical) {
				if (self.sortProgress
						&& typeof self.sortProgress.end === 'function') {
					self.sortProgress.end();
				}

				self.timing.stop(timingEvt);
				self.fire('sortEnd');

				return cont(didHorizontal || didVertical);
			});
		});
	};

	// #setFilter {{{2

	/**
	 * Set the filtering that will be used by this view.  The object spec is the same as we support for
	 * server-side filtering using JSON.  It's based on MongoDB.  Every key is the name of a column to
	 * filter.  Every value is either a string (the column must be equal to that value), or an object
	 * --- in which every key is an operator and every value an operand.  Operators are:
	 *
	 *   - $eq, $ne, $gt, $gte, $lt, $lte, $contains, $notcontains
	 *   - $in, $nin
	 *
	 * @method
	 * @memberof View
	 *
	 * @param {View~FilterSpec} spec How to perform filtering.
	 *
	 * @param {object} progress
	 *
	 * @param {object} [opts]
	 *
	 * @param {boolean} [opts.sendEvent=true]
	 * If true, issue an event indicating the filter has been changed.
	 *
	 * @param {Array.<Object>} [opts.dontSendEventTo]
	 * Don't send events to these subscribers.
	 *
	 * @param {boolean} [opts.updateData=true]
	 * If true, automatically update data to match new filter.
	 */

	View.prototype.setFilter = function (spec, progress, opts) {
		var self = this
			, args = Array.prototype.slice.call(arguments)
			, isDifferent = false;

		opts = deepCopy(opts) || {};

		if (self.lock.isLocked()) {
			return self.lock.onUnlock(function () {
				self.setFilter.apply(self, args);
			}, 'Waiting to set filter: ' + JSON.stringify(spec));
		}

		opts = deepDefaults(opts, {
			sendEvent: true,
			dontSendEventTo: [],
			updateData: true,
			savePrefs: true
		});

		self.debug('SET FILTER', 'spec = %O ; options = %O', spec, opts);

		isDifferent = !underscore.isEqual(self.filterSpec, spec);

		if (self.filterSpec != null && spec == null) {
			self.wasPreviouslyFiltered = true;
		}

		/*
		if (spec != null) {
			if (self.typeInfo == null) {
				return self.getTypeInfo(function () {
					self.setFilter.apply(self, args);
				});
			}

			_.each(spec, function (fieldSpec, field) {
				if (self.typeInfo.get(field) == null) {
					log.error('Ignoring filter on field "' + field + '" because it doesn\'t exist in the data');
					delete spec[field];
				}
			});
		}
		*/

		self.filterSpec = spec;
		self.filterProgress = progress;

		if (opts.sendEvent) {
			self.fire('filterSet', {
				notTo: opts.dontSendEventTo
			}, spec);
		}

		if (isDifferent && self.prefs != null && opts.savePrefs) {
			self.prefs.save();
		}

		self.clearCache();

		if (opts.updateData) {
			self.getData();
		}

		return true;
	};

	// #getFilter {{{2

	View.prototype.getFilter = function () {
		var self = this;

		return self.filterSpec;
	};

	// #clearFilter {{{2

	/**
	 * Clear the spec used to filter this view.
	 *
	 * @param {object} [opts]
	 *
	 * @param {boolean} [opts.sendEvent=true]
	 * If true, issue an event indicating the filter has been changed.
	 *
	 * @param {Array.<Object>} [opts.dontSendEventTo]
	 * Don't send events to these subscribers.
	 *
	 * @param {boolean} [opts.updateData=true]
	 * If true, automatically update data to match new filter.
	 */

	View.prototype.clearFilter = function (opts) {
		this.setFilter(null, null, opts);
	};

	// #isFiltered {{{2

	/**
	 * Tell if this view has been filtered.
	 *
	 * @returns {boolean} True if the view has been filtered.
	 */

	View.prototype.isFiltered = function () {
		return this.filterSpec != null;
	};

	// #filter {{{2

	/**
	 * Apply the filter previously set.
	 *
	 * @param {function} cont Continuation function to which the filtered data is passed.
	 */

	View.prototype.filter = function (cont) {
		var self = this
			, timingEvt = ['Data Source "' + self.source.name + '" : ' + self.name, 'Filtering'];

		if (self.filterSpec == null) {
			if (!self.wasPreviouslyFiltered) {
				return cont(false, self.data.data);
			}
			else {
				self.wasPreviouslyFiltered = false;
			}
		}

		// Make sure that each column that we're filtering has been type decoded, if necessary.

		underscore.each(self.filterSpec, function (fieldSpec, field) {
			var fti = self.typeInfo.get(field);

			// Check to make sure we have enough information about the type of the field that the user wants
			// us to filter.

			if (fti === undefined) {
				log.error('Filter field "' + field + '" does not exist in the source');
				self.fire('invalidFilterField', null, field);
				delete self.filterSpec[field];
				return;
			}

			if (fti.type === undefined) {
				log.error('Unable to filter field "' + field + '", type is unknown');
				self.fire('invalidFilterField', null, field);
				delete self.filterSpec[field];
				return;
			}

			// For dates and datetimes, if the data is stored in moment objects, convert filters serialized
			// as strings into moment objects before continuing.

			if (['date', 'datetime'].indexOf(fti.type) >= 0 && fti.internalType === 'moment') {
				underscore.each(fieldSpec, function (val, op) {
					if (typeof val === 'string') {
						fieldSpec[op] = moment(val);
					}
				});
			}

			self._maybeDecode('FILTER', fti);
		});

		// Checks to see if the given filter passes for the given row.

		function passesFilter(fltr, field, row) {
			var fti = self.typeInfo.get(field);
			var datum = row[field].value;

			// When there's no such column, automatically fail.

			if (datum === undefined) {
				debug.warn('VIEW (' + self.name + ') // FILTER',
					'Attempted to filter by non-existent column: ' + field);
				return false;
			}

			var isMoment = moment.isMoment(datum);
			var isNumeral = numeral.isNumeral(datum);
			var isString = typeof datum === 'string';
			var isNumber = typeof datum === 'number';

			var pred = {};

			//var cmp = getComparisonFn.byValue(datum);
			var cmp = getComparisonFn.byType(fti.type);

			pred['$eq'] = function (operand) {
				return cmp(datum, operand) === 0;
			};

			pred['$ne'] = function (operand) {
				return !pred['$eq'](operand);
			};

			pred['$contains'] = function (operand) {
				return ( isMoment && false )
					|| ( isNumeral && false )
					|| ( isString && datum.indexOf(operand.toString().toLowerCase()) >= 0 )
					|| ( isNumber && false )
				;
			};

			pred['$notcontains'] = function (operand) {
				return !pred['$notcontains'](operand);
			};

			pred['$gt'] = function (operand) {
				return cmp(datum, operand) > 0;
			};

			pred['$gte'] = function (operand) {
				return pred['$gt'](operand) || pred['$eq'](operand);
			};

			pred['$lt'] = function (operand) {
				return cmp(datum, operand) < 0;
			};

			pred['$lte'] = function (operand) {
				return pred['$lt'](operand) || pred['$eq'](operand);
			};

			if (underscore.isArray(fltr)) {
				fltr = { '$in': fltr };
			}
			else if (!underscore.isObject(fltr)) {
				fltr = { '$eq': fltr };
			}

			for (var operator in fltr) {
				if (!fltr.hasOwnProperty(operator)) {
					continue;
				}

				var operand = fltr[operator];
				//self.debug('FILTER', 'field = ' + field + ' ; Datum = ' + datum + ' ; Operator = ' + operator + ' ; Operand = ' + operand);

				if (pred[operator] !== undefined) {
					if (underscore.isArray(operand)) {
						if (underscore.every(operand, pred[operator]) === false) {
							return false;
						}
					}
					else if (pred[operator](operand) === false) {
						return false;
					}
				}
				else {
					switch (operator) {
					case '$in':
						if (!underscore.isArray(operand)) {
							throw new Error('Invalid filter spec, operator "$in" for column "' + field + '" requires array value');
						}

						if (underscore.map(operand, function (elt) { return elt.toString().toLowerCase(); }).indexOf(datum.toString().toLowerCase()) < 0) {
							return false;
						}
						break;

					case '$nin':
						if (!underscore.isArray(operand)) {
							throw new Error('Invalid filter spec, operator "$nin" for column "' + field + '" requires array value');
						}

						if (underscore.map(operand, function (elt) { return elt.toString().toLowerCase(); }).indexOf(datum.toString().toLowerCase()) >= 0) {
							return false;
						}
						break;

					default:
						throw new Error('Invalid operator "' + operator + '" for column "' + field + '"');
					}
				}
			}

			return true;
		}

		// Checks to see if all filters from the spec pass on the given row.

		function passesAllFilters(row) {
			// Iterate over all elements in the filter spec, testing each in turn, until one fails.  Pass
			// the row along as "extra data" because that's what the predicate is actually testing.

			var passes = self.filterSpec == null ? true : eachUntilObj(self.filterSpec, passesFilter, false, row.rowData);

			self.fire('filter', {
				silent: true
			}, row.rowNum, !passes);

			return passes;
		}

		/*
		if (self.data === undefined) {
			return self.getData(function () {
				return self.filter();
			});
		}
		else if (self.typeInfo === undefined) {
			return self.getTypeInfo(function () {
				return self.filter();
			});
		}
		else {
			self.timing.start(timingEvt);
			self.data = _.filter(self.data, passesAllFilters);
			self.timing.stop(timingEvt);
		}
		*/

		var i0 = {
			val: 0
		}, i_step = self.filterProgress ? 100 : self.data.data.length;
		var newData = [];

		var doFilter = function () {
			var i;

			//self.debug('FILTER',
			//					 'Filtering rows ' + i0.val + ' through ' + (i0.val + i_step));

			for (i = i0.val; i < self.data.data.length && i < i0.val + i_step; i += 1) {
				if (passesAllFilters(self.data.data[i])) {
					newData.push(self.data.data[i]);
				}
			}

			if (i < self.data.data.length) {
				i0.val = i;

				if (self.filterProgress
						&& typeof self.filterProgress.update === 'function') {
					self.filterProgress.update(i, self.data.data.length);
				}

				logAsync('View#filter');
				return window.setTimeout(doFilter);
			}
			else {
				// If there's a progress callback, perform its done event.
				if (self.filterProgress
						&& typeof self.filterProgress.end === 'function') {
					self.filterProgress.end();
				}

				// Fire the event for finishing the filter.
				self.fire('filterEnd');

				// Stop the timer for the filter.
				self.timing.stop(timingEvt);

				// Pass the filtered data to the continuation.
				return cont(true, newData);
			}
		};

		// Start the timer for the filter operation.
		self.timing.start(timingEvt);

		// If there's a progress callback, perform its start event.
		if (self.filterProgress
				&& typeof self.filterProgress.begin === 'function') {
			self.filterProgress.begin();
		}

		// Fire the event for starting the filter.
		self.fire('filterBegin');

		return doFilter();
	};

	// #setGroup {{{2

	/**
	 * Set the specification for how the data will be grouped.
	 *
	 * @param {View~GroupSpec} spec
	 * The grouping configuration.
	 *
	 * @param {object} [opts]
	 *
	 * @param {boolean} [opts.sendEvent=true]
	 * If true, issue an event indicating the grouping has been changed.
	 *
	 * @param {Array.<Object>} [opts.dontSendEventTo]
	 * Don't send events to these subscribers.
	 *
	 * @param {boolean} [opts.updateData=true]
	 * If true, automatically update data to match new grouping.
	 */

	View.prototype.setGroup = function (spec, opts, cont) {
		var self = this
			, args = Array.prototype.slice.call(arguments)
			, isDifferent = false;

		if (self.lock.isLocked()) {
			return self.lock.onUnlock(function () {
				self.setGroup.apply(self, args);
			}, 'Waiting to set group: ' + JSON.stringify(spec));
		}

		opts = deepDefaults(opts, {
			sendEvent: true,
			dontSendEventTo: [],
			updateData: true,
			savePrefs: true
		});

		self.debug('SET GROUP', 'spec = %O', spec);

		if (spec == null && self.pivotSpec != null) {
			log.warn('VIEW (' + self.name + ') // SET GROUP', 'Having a pivot without a group is not allowed');
			self.clearPivot(opts);
		}

		if (spec != null) {
			if (!underscore.isArray(spec.fieldNames)) {
				log.warn('VIEW (' + self.name + ') // SET GROUP', '`spec.fieldNames` is not an array');
				spec.fieldNames = [];
			}

			// Convert the `fieldNames` property elements from strings to objects.

			for (var i = 0; i < spec.fieldNames.length; i += 1) {
				if (typeof spec.fieldNames[i] === 'string') {
					spec.fieldNames[i] = { field: spec.fieldNames[i] };
				}
			}
		}

		/*
		if (spec != null) {
			// Make sure we have typeInfo so we can perform the next check.

			if (self.typeInfo == null) {
				return self.getTypeInfo(function () {
					self.setGroup.apply(self, args);
				});
			}

			// Remove any fields that don't exist in the data (according to typeInfo).

			spec.fieldNames = _.filter(spec.fieldNames, function (field) {
				if (self.typeInfo.get(field) == null) {
					log.error('Ignoring group on field "' + field + '" because it doesn\'t exist in the data');
					return false;
				}
				return true;
			});

			// Don't do anything if we're not grouping by any fields.

			if (spec.fieldNames.length === 0) {
				return false;
			}
		}
		*/

		isDifferent = !underscore.isEqual(self.groupSpec, spec);

		self.groupSpec = spec;

		if (opts.sendEvent) {
			self.fire('groupSet', {
				notTo: opts.dontSendEventTo
			}, spec);
		}

		if (isDifferent && self.prefs != null && opts.savePrefs) {
			self.prefs.save();
		}

		self.clearCache();

		if (!opts.updateData) {
			return true;
		}

		self.getData();

		return true;
	};

	// #getGroup {{{2

	/**
	 * Get the grouping configuration.
	 *
	 * @returns {View~GroupSpec}
	 * The grouping config currently being used by this view.
	 */

	View.prototype.getGroup = function () {
		var self = this;

		return self.groupSpec;
	};

	// #clearGroup {{{2

	/**
	 * Reset the grouping config so the data is not grouped.
	 *
	 * @param {object} [opts]
	 *
	 * @param {boolean} [opts.sendEvent=true]
	 * If true, issue an event indicating the grouping has been changed.
	 *
	 * @param {Array.<Object>} [opts.dontSendEventTo]
	 * Don't send events to these subscribers.
	 *
	 * @param {boolean} [opts.updateData=true]
	 * If true, automatically update data to match new grouping.
	 */

	View.prototype.clearGroup = function (opts) {
		return this.setGroup(null, opts);
	};

	// #group {{{2

	/**
	 * @typedef {metadataNode} groupMetadata
	 *
	 * @property {object} lookup
	 *
	 * @property {Object.<number,metadataNode>} lookup.byId
	 * Used by grid table group details selection.
	 *
	 * @property {Object.<number,metadataNode>} lookup.byRowValIndex
	 * Used by grid table group details selection.
	 *
	 * @property {Object.<number,metadataNode>} lookup.byRowNum
	 * Used by grid table group details selection to find out what rowVal a selected row belongs to (and
	 * thus to determine status of checkboxes in grouping hierarchy).
	 */

	/**
	 * @typedef {object} metadataNode
	 * Node within the tree used to store grouping metadata for detailed group output.  This structure
	 * drives the display and expand/collapse behavior of the UI.  The root is a fake metadataNode (does
	 * not correspond to anything actually in the data) with `id = 0` and all toplevel groups are
	 * children of the root.  Every path through the tree represents a rowVal.
	 *
	 * @property {number} id
	 * A unique identifier for this node.
	 *
	 * @property {number} numRows
	 * Number of descendant rows (either directly in this rowVal leaf, or in all children).
	 *
	 * @property {metadataNode} parent
	 * Parent node of this one.  Only in non-root nodes.
	 *
	 * @property {number} numChildren
	 * Number of direct child nodes.  Only in non-leaf nodes.
	 *
	 * @property {Object.<string,metadataNode>} children
	 * Children mapped by the natrep of their rowValElt.  Only in non-leaf nodes.
	 *
	 * @property {Array} rows
	 * All the rows in the rowVal this rowValElt completes.  Only in leaf nodes.
	 *
	 * @property {string} rowValElt
	 * The part of the current rowVal represented by the node at the current depth in the tree.
	 *
	 * ```
	 * rowVals = [[A1,B1],[A1,B2],[A2,B1],[A2,B2]]
	 * tree = <ORIGIN>
	 *       /        \
	 *      A1        A2 <- rowValElt = A2
	 *     /  \      /  \
	 *    B1  B2    B1  B2 <- rowValElt = B2
	 * ```
	 *
	 * @property {number} rowValIndex
	 * What rowVal this rowValElt completes. Only in leaf nodes.  Example:
	 *
	 * ```
	 * rowVals = [[A1,B1],[A1,B2],[A2,B1],[A2,B2]]
	 * tree = <ORIGIN>
	 *       /        \
	 *      A1        A2
	 *     /  \      /  \
	 *    B1  B2    B1  B2
	 *    0   1     2   3   <- rowValIndex
	 * ```
	 *
	 * @property {object} rowValCell
	 *
	 * @property {string} groupField
	 * Name of the field that we're grouping by at this level.
	 *
	 * @property {View~GroupSpecElt} groupSpec
	 * The full group spec for the grouping done at this level.
	 */

	/**
	 * Perform grouping on the data.  This modifies the data in place; it's not asynchronous and there's
	 * no return value.
	 */

	View.prototype.group = function () {
		var self = this
			, finalGroupSpec = []
			, newData
			, rowVals;

		// Make sure that grouping has been asked for.

		if (self.groupSpec == null) {
			return false;
		}

		// We need `typeInfo` to verify that the group fields requested actually exist in the source data.
		// It's not possible to just use the data, because there may be no rows.

		if (self.typeInfo == null) {
			log.error('Source type information is missing');
			return false;
		}

		// Go through every group field and make sure it exists in the source.  If it doesn't, we use an
		// event to notify the user interface about it so a warning can be shown.

		underscore.each(self.groupSpec.fieldNames, function (fieldObj) {
			var fti = self.typeInfo.get(fieldObj.field);
			if (fti == null) {
				log.error('Group field does not exist in the source: ' + fieldObj.field);
				self.fire('invalidGroupField', null, fieldObj.field);
			}
			else if (fti.type == null) {
				log.error('Unable to group by field "%s": type is undefined');
			}
			else {
				self._maybeDecode('GROUP', fti);
				finalGroupSpec.push(fieldObj);
			}
		});

		// It's possible now that we've eliminated *all* the group fields because they're invalid; if
		// that's the case, we just abort as if no grouping was requested at all.

		if (finalGroupSpec.length === 0) {
			return false;
		}

		// natRep --
		//
		//   Short for "native representation."  A string version of the value that is safe to use as the
		//   key in an object, and which also sorts the same as the value it represents.
		//
		//     sort(values) = map(natRep->val, sort(map(val->natRep, values)))

		var origKeys = []; // groupFieldIndex[] → natRep → value

		// buildRowVals {{{3
		//
		//   Create the list of the native representations of all combinations of the values of the group
		//   fields.  Here's a simple example with strings, where the natrep transform is identity.
		//
		//   buildRowVals(['Last Name', 'First Name'])
		//     => [['Roosevelt', 'Franklin'], ['Roosevelt', 'Theodore'], ['Kennedy', 'John'], ...]
		//
		//   Here's an example with dates, where the natrep transform is to convert to UNIX time.
		//
		//   buildRowVals(['Create Date'])
		//     => [[1526346077 /* 2018-05-14 21:01:17 GMT-4 */, ...]]
		//
		//   As a side effect, the `origKeys[groupFieldIndex]` object is updated with how to reverse the
		//   natrep transform.  This will be used later.

		var buildRowVals = function (addRowVals) {
			var rowVals = []
				, rowVal
				, row
				, rowIndex
				, groupSpecElt
				, groupFieldIndex
				, cell
				, value
				, natRep
				, groupFun
				, groupFunResult;

			for (rowIndex = 0; rowIndex < self.data.data.length; rowIndex += 1) {
				row = self.data.data[rowIndex];
				rowVal = [];
				for (groupFieldIndex = 0; groupFieldIndex < finalGroupSpec.length; groupFieldIndex += 1) {
					groupSpecElt = finalGroupSpec[groupFieldIndex];
					cell = row.rowData[groupSpecElt.field];
					value = cell.value;
					if (groupSpecElt.fun == null) {
						natRep = getNatRep(value);
						origKeys[groupFieldIndex][natRep] = value;
					}
					else {
						groupFun = GROUP_FUNCTION_REGISTRY.get(groupSpecElt.fun);
						groupFunResult = groupFun.applyValueFun(value);
						natRep = getNatRep(groupFunResult);
						origKeys[groupFieldIndex][natRep] = groupFunResult;
					}
					rowVal[groupFieldIndex] = natRep;
					// Cache the natRep in the cell for improved performance in buildData().
					setProp(natRep, cell, 'natRep', 'group', groupFieldIndex);
				}
				if (underscore.findIndex(rowVals, function (x) {
					return arrayEqual(rowVal, x);
				}) === -1) {
					rowVals.push(rowVal);
				}
			}

			if (addRowVals != null) {
				for (var arvIndex = 0; arvIndex < addRowVals.length; arvIndex += 1) {
					rowVal = addRowVals[arvIndex];

					if (rowVal.length != finalGroupSpec.length) {
						log.error('Unable to add rowVal %s when grouping by %s: the lengths must be the same',
							JSON.stringify(rowVal), JSON.stringify(finalGroupSpec));
						continue;
					}

					for (groupFieldIndex = 0; groupFieldIndex < rowVal.length; groupFieldIndex += 1) {
						value = rowVal[groupFieldIndex];
						natRep = getNatRep(value);
						origKeys[groupFieldIndex][natRep] = value;
						rowVal[groupFieldIndex] = natRep;
					}

					if (underscore.findIndex(rowVals, function (x) {
						return arrayEqual(rowVal, x);
					}) === -1) {
						rowVals.push(rowVal);
					}
				}
			}

			rowVals.sort(function (a, b) {
				return arrayCompare(a, b);
			});

			return rowVals;
		};

		// buildData {{{3

		var buildData = function (data, rowVals) {
			var rowVal
				, rowValIndex
				, metadataLeaf
				, row
				, rowIndex
				, groupSpecElt
				, groupFieldIndex
				;

			var result = new Array(rowVals.length);
			var metadataTree = {
				lookup: {
					byRowNum: new Array(data.length),
					byRowValIndex: new Array(rowVals.length),
					byId: [],
				}
			};

			// Build the metadata tree leaves.  Each path through the metadata tree from root to leaf
			// represents a group, with each step along the way being an element of the rowval.

			for (rowValIndex = 0; rowValIndex < rowVals.length; rowValIndex += 1) {
				rowVal = rowVals[rowValIndex];
				metadataLeaf = {
					rowValIndex: rowValIndex,
					rowValElt: rowVal[rowVal.length - 1],
					parent: null,
					numRows: 0,
					rows: []
				};

				result[rowValIndex] = metadataLeaf.rows;

				setProp(metadataLeaf, metadataTree, 'children', interleaveWith(rowVal, 'children'));
				metadataTree.lookup.byRowValIndex[rowValIndex] = metadataLeaf;
			}

			// Build the `rows` property of each metadata tree leaf.  These are the rows that belong in each
			// group.  Here's how it works:
			//
			//   1. Construct the rowval from the data in the row.
			//   2. Use the rowval as a path to walk the tree to the leaf.
			//   3. Append the row to the leaf's collection.

			for (rowIndex = 0; rowIndex < data.length; rowIndex += 1) {
				row = data[rowIndex];
				rowVal = new Array(finalGroupSpec.length);

				for (groupFieldIndex = 0; groupFieldIndex < finalGroupSpec.length; groupFieldIndex += 1) {
					groupSpecElt = finalGroupSpec[groupFieldIndex];
					// Use the cached natRep from the cell to quickly build the path to the metadata node.
					rowVal[groupFieldIndex] = row.rowData[groupSpecElt.field].natRep.group[groupFieldIndex];
				}

				metadataLeaf = getProp(metadataTree, 'children', interleaveWith(rowVal, 'children'));
				metadataTree.lookup.byRowNum[row.rowNum] = metadataLeaf;

				metadataLeaf.rows.push(row);
			}

			// A post-order traversal is used to build the info in the metadata tree from the leaves up.

			var metadataId = 0;
			var postorder = function (node, depth) {
				node.id = metadataId++;
				node.numRows = 0;

				metadataTree.lookup.byId[node.id] = node;

				// NOTE When there are no rows in the data, the root of the tree has no children, but also no
				// rows (because it's not a rowVal leaf).  This case is handled by setting numRows = 0 above.

				if (node.children == null) {
					if (node.rows != null) {
						node.numRows = node.rows.length;
					}
				}
				else {
					node.numChildren = underscore.keys(node.children).length;
					node.rows = [];
					underscore.each(node.children, function (child) {
						child.parent = node;
						postorder(child, depth + 1);
						node.numRows += child.numRows;
						node.rows = node.rows.concat(child.rows);
					});
					if (depth > 0) {
						// FIXME Assumes that node.children.length > 0.
						node.rowValIndex = node.children[underscore.keys(node.children)[0]].rowValIndex;
						node.rowValElt = rowVals[node.rowValIndex][depth - 1];
					}
				}

				if (depth > 0) {
					node.groupFieldIndex = depth - 1;
					node.groupField = finalGroupSpec[node.groupFieldIndex].field;
					node.groupSpec = finalGroupSpec[node.groupFieldIndex];
					if (node.rows != null && node.rows.length > 0) {
						node.rowValCell = node.rows[0].rowData[node.groupField];
					}
				}
			};

			postorder(metadataTree, 0);

			return {
				data: result,
				metadata: metadataTree
			};
		};

		// convertRowVals {{{3

		var convertRowVals = function (rowVals) {
			var result = [];

			for (var rowValIndex = 0; rowValIndex < rowVals.length; rowValIndex += 1) {
				var rowVal = rowVals[rowValIndex];
				result[rowValIndex] = [];
				for (var groupFieldIndex = 0; groupFieldIndex < finalGroupSpec.length; groupFieldIndex += 1) {
					result[rowValIndex][groupFieldIndex] = origKeys[groupFieldIndex][rowVal[groupFieldIndex]];
				}
			}

			return result;
		};

		// }}}3

		for (var groupFieldIndex = 0; groupFieldIndex < finalGroupSpec.length; groupFieldIndex += 1) {
			origKeys[groupFieldIndex] = {};
		}

		rowVals = buildRowVals(self.groupSpec.addRowVals);
		newData = buildData(self.data.data, rowVals);
		rowVals = convertRowVals(rowVals);

		self.debug('GROUP', 'Group Spec: %O', finalGroupSpec);
		self.debug('GROUP', 'Row Vals: %O', rowVals);
		self.debug('GROUP', 'New Data: %O', newData.data);

		self.data.isPlain = false;
		self.data.isGroup = true;
		self.data.groupFields = underscore.pluck(finalGroupSpec, 'field');
		self.data.groupSpec = finalGroupSpec;
		self.data.rowVals = rowVals;
		self.data.data = newData.data;
		self.data.groupMetadata = newData.metadata;

		self.debug('GROUP', 'Final Data: %O', self.data);

		return true;
	};

	// #setPivot {{{2

	/**
	 * Set the pivot configuration.
	 *
	 * @param {View~PivotSpec} spec
	 * The pivot configuration.
	 *
	 * @param {object} [opts]
	 *
	 * @param {boolean} [opts.sendEvent=true]
	 * If true, issue an event indicating the pivot config has been changed.
	 *
	 * @param {Array.<Object>} [opts.dontSendEventTo]
	 * Don't send events to these subscribers.
	 *
	 * @param {boolean} [opts.updateData=true]
	 * If true, automatically update data to match new pivot config.
	 */

	View.prototype.setPivot = function (spec, opts) {
		var self = this
			, args = Array.prototype.slice.call(arguments)
			, isDifferent = false;

		if (self.lock.isLocked()) {
			return self.lock.onUnlock(function () {
				self.setPivot.apply(self, args);
			}, 'Waiting to set pivot: ' + JSON.stringify(spec));
		}

		opts = deepDefaults(opts, {
			sendEvent: true,
			dontSendEventTo: [],
			updateData: true,
			savePrefs: true
		});

		self.debug('SET PIVOT', 'spec = %O', spec);

		if (self.groupSpec == null && spec != null) {
			log.warn('VIEW (' + self.name + ') // SET PIVOT', 'Having a pivot without a group is not allowed');
			self.clearPivot(opts);
			return false;
		}

		if (spec != null) {
			if (!underscore.isArray(spec.fieldNames)) {
				log.warn('VIEW (' + self.name + ') // SET PIVOT', '`spec.fieldNames` is not an array');
				spec.fieldNames = [];
			}

			// Convert the `fieldNames` property elements from strings to objects.

			for (var i = 0; i < spec.fieldNames.length; i += 1) {
				if (typeof spec.fieldNames[i] === 'string') {
					spec.fieldNames[i] = { field: spec.fieldNames[i] };
				}
			}
		}

		/*
		if (spec != null) {
			// Make sure we have typeInfo so we can perform the next check.

			if (self.typeInfo == null) {
				return self.getTypeInfo(function () {
					self.setPivot.apply(self, args);
				});
			}

			// Remove any fields that don't exist in the data (according to typeInfo).

			spec.fieldNames = _.filter(spec.fieldNames, function (field) {
				if (self.typeInfo.get(field) == null) {
					log.error('Ignoring pivot on field "' + field + '" because it doesn\'t exist in the data');
					return false;
				}
				return true;
			});

			// Don't do anything if we're not grouping by any fields.

			if (spec.fieldNames.length === 0) {
				return false;
			}
		}
		*/

		isDifferent = !underscore.isEqual(self.pivotSpec, spec);

		self.pivotSpec = spec;

		if (opts.sendEvent) {
			self.fire('pivotSet', {
				notTo: opts.dontSendEventTo
			}, spec);
		}

		if (isDifferent && self.prefs != null && opts.savePrefs) {
			self.prefs.save();
		}

		self.clearCache();

		if (!opts.updateData) {
			return true;
		}

		self.getData();

		return true;
	};

	// #getPivot {{{2

	/**
	 * Get the pivot configuration.
	 *
	 * @returns {View~PivotSpec}
	 * The pivot config currently being used by this view.
	 */

	View.prototype.getPivot = function () {
		var self = this;

		return self.pivotSpec;
	};

	// #clearPivot {{{2

	/**
	 * Reset the pivot config so the data is not pivotted.
	 *
	 * @param {object} [opts]
	 *
	 * @param {boolean} [opts.sendEvent=true]
	 * If true, issue an event indicating the pivot config has been changed.
	 *
	 * @param {Array.<Object>} [opts.dontSendEventTo]
	 * Don't send events to these subscribers.
	 *
	 * @param {boolean} [opts.updateData=true]
	 * If true, automatically update data to match new pivot config.
	 */

	View.prototype.clearPivot = function (opts) {
		return this.setPivot(null, opts);
	};

	// #pivot_orig {{{2

	View.prototype.pivot_orig = function () {
		var self = this
			, pivotFields = [] // Array of field names to pivot by.
			, colValsTree // Tree of all possible column value combinations.
			, colVals     // Array of all possible column value combinations.
		;

		// FIXME Allow pivot without group.

		if (!self.data.isGroup) {
			return false;
		}

		// Make sure that pivotting has been asked for.

		if (self.pivotSpec == null) {
			return false;
		}

		// We need `typeInfo` to verify that the pivot fields requested actually exist in the source data.
		// It's not possible to just use the data, because there may be no rows.

		if (self.typeInfo == null) {
			log.error('Source type information is missing');
			return false;
		}

		// Go through every pivot field and make sure it exists in the source.

		underscore.each(self.pivotSpec.fieldNames, function (field, fieldIdx) {
			if (!self.typeInfo.isSet(field)) {
				log.error('Pivot field does not exist in the source: ' + field);
				self.fire('invalidPivotField', null, field);
			}
			else {
				pivotFields.push(field);
			}
		});

		// It's possible now that we've eliminated *all* the pivot fields because they're invalid; if
		// that's the case, we just abort as if no pivotting was requested at all.

		if (pivotFields.length === 0) {
			return false;
		}

		var buildColValsTree = function (pivotFields) {
			var colValsTree = {};

			underscore.each(self.data.data, function (groupedRows) {
				(function RECUR(fieldNames, data, tree) {
					var field = car(fieldNames)
						, tmp = {};

					underscore.each(data, function (row) {
						var value = row.rowData[field].orig || row.rowData[field].value;

						if (tree[value] === undefined) {
							tree[value] = fieldNames.length > 1 ? {} : true;
						}

						if (tmp[value] === undefined) {
							tmp[value] = [];
						}

						tmp[value].push(row);
					});

					if (fieldNames.length > 1) {
						underscore.each(tmp, function (pivottedRows, value) {
							RECUR(cdr(fieldNames), pivottedRows, tree[value]);
						});
					}
				})(pivotFields, groupedRows, colValsTree);
			});

			return colValsTree;
		};

		var buildColVals = function (colValsTree) {
			var colVals = [];

			(function RECUR(tree, level, path) {
				if (level === self.pivotSpec.fieldNames.length) {
					underscore.each(underscore.keys(tree).sort(), function (value) {
						colVals.push(path.concat([value]));
					});
				}
				else {
					underscore.each(tree, function (subtree, value) {
						RECUR(subtree, level + 1, path.concat([value]));
					});
				}
			})(colValsTree, 1, []);

			return colVals;
		};

		var buildData = function (data) {
			var result = [];

			underscore.each(data, function (groupedRows, groupNum) {
				var newData = [];
				underscore.each(colVals, function (colVal) {
					var tmp = [];
					underscore.each(groupedRows, function (row) {
						if (underscore.every(colVal, function (colValElt, colValNum) {
							var pivotField = pivotFields[colValNum];
							var value = row.rowData[pivotField].value;
							var natRep = getNatRep(value);
							return colValElt === natRep;
						})) {
							tmp.push(row);
						}
					});
					newData.push(tmp);
				});
				result.push(newData);
			});

			return result;
		};

		colValsTree = buildColValsTree(pivotFields);
		colVals = buildColVals(colValsTree);
		self.data.data = buildData(self.data.data);

		self.debug('PIVOT', 'Pivot Fields: %O', pivotFields);
		self.debug('PIVOT', 'Col Vals Tree: %O', colValsTree);
		self.debug('PIVOT', 'Col Vals: %O', colVals);
		self.debug('PIVOT', 'New Data: %O', self.data);

		self.data.isPlain = false;
		self.data.isGroup = false;
		self.data.isPivot = true;
		self.data.pivotFields = pivotFields;
		self.data.colVals = colVals;

		return true;
	};

	// #pivot_new {{{2

	View.prototype.pivot = function () {
		var self = this
			, finalPivotSpec = [] // Array of field names to pivot by.
			, colVals     // Array of all possible column value combinations.
			, newData
		;

		// FIXME Allow pivot without group.

		if (!self.data.isGroup) {
			return false;
		}

		// Make sure that pivotting has been asked for.

		if (self.pivotSpec == null) {
			return false;
		}

		// We need `typeInfo` to verify that the pivot fields requested actually exist in the source data.
		// It's not possible to just use the data, because there may be no rows.

		if (self.typeInfo == null) {
			log.error('Source type information is missing');
			return false;
		}

		// Go through every group field and make sure it exists in the source.  If it doesn't, we use an
		// event to notify the user interface about it so a warning can be shown.

		underscore.each(self.pivotSpec.fieldNames, function (fieldObj) {
			var fti = self.typeInfo.get(fieldObj.field);
			if (fti == null) {
				log.error('Pivot field does not exist in the source: ' + fieldObj.field);
				self.fire('invalidPivotField', null, fieldObj.field);
			}
			else if (fti.type == null) {
				log.error('Unable to pivot by field "%s": type is undefined');
			}
			else {
				self._maybeDecode('PIVOT', fti);
				finalPivotSpec.push(fieldObj);
			}
		});

		// It's possible now that we've eliminated *all* the pivot fields because they're invalid; if
		// that's the case, we just abort as if no pivotting was requested at all.

		if (finalPivotSpec.length === 0) {
			return false;
		}

		var origKeys = [];

		// buildColVals {{{3

		var buildColVals = function (addColVals) {
			var colVal
				, pivotFieldIndex
				, pivotSpecElt
				, value
				, natRep
				, groupFun
				, groupIndex
				, group
				, row
				, rowIndex
				, acvIndex
				, colVals = [];

			for (groupIndex = 0; groupIndex < self.data.data.length; groupIndex += 1) {
				group = self.data.data[groupIndex];
				for (rowIndex = 0; rowIndex < group.length; rowIndex += 1) {
					row = group[rowIndex];
					colVal = [];
					for (pivotFieldIndex = 0; pivotFieldIndex < finalPivotSpec.length; pivotFieldIndex += 1) {
						pivotSpecElt = finalPivotSpec[pivotFieldIndex];
						value = row.rowData[pivotSpecElt.field].value;
						if (pivotSpecElt.fun == null) {
							natRep = getNatRep(value);
							origKeys[pivotFieldIndex][natRep] = value;
						}
						else {
							groupFun = GROUP_FUNCTION_REGISTRY.get(pivotSpecElt.fun);
							natRep = groupFun.applyValueFun(value);
							origKeys[pivotFieldIndex][natRep] = natRep;
						}
						setProp(natRep, row.rowData[pivotSpecElt.field], 'natRep', 'pivot', pivotFieldIndex);
						colVal[pivotFieldIndex] = natRep;
					}
					if (underscore.findIndex(colVals, function (x) {
						return arrayEqual(colVal, x);
					}) === -1) {
						colVals.push(colVal);
					}
				}
			}

			if (addColVals != null) {
				for (acvIndex = 0; acvIndex < addColVals.length; acvIndex += 1) {
					colVal = addColVals[acvIndex];

					if (colVal.length != finalPivotSpec.length) {
						log.error('Unable to add colVal %s when pivotting by %s: the lengths must be the same',
							JSON.stringify(colVal), JSON.stringify(finalPivotSpec));
						continue;
					}

					for (pivotFieldIndex = 0; pivotFieldIndex < colVal.length; pivotFieldIndex += 1) {
						value = colVal[pivotFieldIndex];
						natRep = getNatRep(value);
						origKeys[pivotFieldIndex][natRep] = value;
						colVal[pivotFieldIndex] = natRep;
					}

					if (underscore.findIndex(colVals, function (x) {
						return arrayEqual(colVal, x);
					}) === -1) {
						colVals.push(colVal);
					}
				}
			}

			colVals.sort(function (a, b) {
				return arrayCompare(a, b);
			});

			return colVals;

		};

		// buildData {{{3

		var buildData = function (data) {
			var result = [];

			underscore.each(data, function (groupedRows, groupNum) {
				var newData = [];
				underscore.each(colVals, function (colVal) {
					var tmp = [];
					underscore.each(groupedRows, function (row) {
						if (underscore.every(colVal, function (colValElt, colValIndex) {
							var pivotSpecElt = finalPivotSpec[colValIndex];
							return colValElt === row.rowData[pivotSpecElt.field].natRep.pivot[colValIndex];
						})) {
							tmp.push(row);
						}
					});
					newData.push(tmp);
				});
				result.push(newData);
			});

			return result;
		};

		// convertColVals {{{3

		var convertColVals = function (colVals) {
			var result = [];

			for (var colValIndex = 0; colValIndex < colVals.length; colValIndex += 1) {
				var colVal = colVals[colValIndex];
				result[colValIndex] = [];
				for (var pivotFieldIndex = 0; pivotFieldIndex < finalPivotSpec.length; pivotFieldIndex += 1) {
					result[colValIndex][pivotFieldIndex] = origKeys[pivotFieldIndex][colVal[pivotFieldIndex]];
				}
			}

			return result;
		};

		// }}}3

		for (var pivotFieldIndex = 0; pivotFieldIndex < finalPivotSpec.length; pivotFieldIndex += 1) {
			origKeys[pivotFieldIndex] = {};
		}

		colVals = buildColVals(self.pivotSpec.addColVals);
		newData = buildData(self.data.data);
		colVals = convertColVals(colVals);

		self.debug('PIVOT', 'Pivot Spec: %O', finalPivotSpec);
		self.debug('PIVOT', 'Orig Keys: %O', origKeys);
		self.debug('PIVOT', 'Col Vals: %O', colVals);
		self.debug('PIVOT', 'New Data: %O', newData);

		self.data.isPlain = false;
		self.data.isGroup = false;
		self.data.isPivot = true;
		self.data.pivotFields = underscore.pluck(finalPivotSpec, 'field');
		self.data.pivotSpec = finalPivotSpec;
		self.data.colVals = colVals;
		self.data.data = newData;

		self.debug('GROUP', 'Final Data: %O', self.data);

		return true;
	};

	// #setAggregate {{{2

	/**
	 * Set the aggregate configuration.
	 *
	 * @param {View~AggregateSpecs} spec
	 * The aggregate configuration.
	 *
	 * @param {object} [opts]
	 *
	 * @param {boolean} [opts.sendEvent=true]
	 * If true, issue an event indicating the pivot config has been changed.
	 *
	 * @param {Array.<Object>} [opts.dontSendEventTo]
	 * Don't send events to these subscribers.
	 *
	 * @param {boolean} [opts.updateData=true]
	 * If true, automatically update data to match new pivot config.
	 */

	View.prototype.setAggregate = function (spec, opts) {
		var self = this
			, args = Array.prototype.slice.call(arguments)
			, isDifferent = false;

		var shouldGraph = {
			group: [],
			pivot: []
		};

		if (self.lock.isLocked()) {
			return self.lock.onUnlock(function () {
				self.setAggregate.apply(self, args);
			}, 'Waiting to set aggregate: ' + JSON.stringify(spec));
		}

		opts = deepDefaults(opts, {
			sendEvent: true,
			dontSendEventTo: [],
			updateData: true,
			savePrefs: true
		});

		self.debug('SET AGGREGATE', 'spec = %O ; options = %O', spec, opts);

		/*
		if (spec == null || self.aggregateSpec == null) {
			self.aggregateSpec = objFromArray(['group', 'pivot', 'cell', 'all'], [[{
				fun: 'count'
			}]]);
		}
		*/

		isDifferent = !underscore.isEqual(self.aggregateSpec, spec);

		if (spec == null) {
			self.aggregateSpec = null;
		}
		else {
			// Make sure we have typeInfo so we can perform the next check.

			/*
			if (self.typeInfo == null) {
				return self.getTypeInfo(function () {
					self.setFilter.apply(self, args);
				});
			}
			*/

			// Remove any fields that don't exist in the data (according to typeInfo).

			underscore.each(spec, function (aggSpec, aggType) {
				aggSpec = underscore.filter(aggSpec, function(agg) {
					var a = AGGREGATE_REGISTRY.get(agg.fun);
					if (a == null) {
						log.error('Ignoring aggregate "' + agg.fun + '" because no such aggregate function exists');
						return false;
					}
					/*
					if (a.prototype.fieldCount > 0) {
						if (agg.fields == null) {
							log.error('Ignoring aggregate "' + agg.fun + '" because no fields have been specified');
							return false;
						}
						if (agg.fields.length < a.prototype.fieldCount) {
							log.error('Ignoring aggregate "' + agg.fun + '" because there aren\'t enough fields');
							return false;
						}
						for (var i = 0; i < agg.fields.length; i += 1) {
							if (self.typeInfo.get(agg.fields[i]) == null) {
								log.error('Ignoring aggregate "' + agg.fun + '" because field "' + agg.fields[i] + '" doesn\'t exist in the data');
								return false;
							}
						}
					}
					*/
					if ((aggType === 'group' || aggType === 'pivot') && agg.shouldGraph) {
						shouldGraph[aggType].push(agg);
					}
					return true;
				});
				spec[aggType] = aggSpec;
			});

			self.aggregateSpec = deepCopy(spec);
		}

		if (opts.sendEvent) {
			self.fire('aggregateSet', {
				notTo: opts.dontSendEventTo
			}, spec, shouldGraph);
		}

		if (isDifferent && self.prefs != null && opts.savePrefs) {
			self.prefs.save();
		}

		self.clearCache();

		if (!opts.updateData) {
			return true;
		}

		self.getData();

		return true;
	};

	// #getAggregate {{{2

	View.prototype.getAggregate = function () {
		var self = this;

		return self.aggregateSpec;
	};

	// #clearAggregate {{{2

	View.prototype.clearAggregate = function (opts) {
		var self = this;

		return self.setAggregate(objFromArray(['group', 'pivot', 'cell', 'all'], [[{fun: 'count'}]]), opts);
	};

	// #aggregate {{{2

	View.prototype.aggregate = function (cont) {
		var self = this;

		if (typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be a function');
		}

		if (!(self.aggregateSpec && (self.data.isGroup || self.data.isPivot))) {
			return cont(false);
		}

		underscore.each(['group', 'pivot', 'cell', 'all'], function (what) {
			self.debug('AGGREGATE', 'Computing %s aggregate functions: %s',
				what, underscore.pluck(getProp(self, 'aggregateSpec', what), 'fun').join(', '));
		});

		// Data structures for storing aggregate function results.

		var groupResults = []; // groupResults[i][n] -> agg over rows w/ rowval[n]
		var pivotResults = []; // pivotResults[i][m] -> agg over columns w/ colval[m]
		var cellResults = []; // cellResults[i][n][m] -> agg over cells w/ rowval[n] -AND- colval[m]
		var allResults = []; // allResults[i] -> agg over all cells

		var info = {
			group: [],
			pivot: [],
			cell: [],
			all: []
		};

		// Initialize the informational data structures.

		underscore.each(['group', 'pivot', 'cell', 'all'], function (what) {
			underscore.each(self.aggregateSpec[what], function (spec, aggNum) {
				try {
					info[what][aggNum] = new AggregateInfo(what, spec, aggNum, self.colConfig, self.typeInfo, underscore.bind(self._maybeDecode, self));
				}
				catch (e) {
					log.error('Invalid Aggregate: ' + what + '[' + aggNum + '] - ' + e.message);

					// Set the aggregate to null so it can be removed later.
					info[what][aggNum] = null;

					// Let the UI know there was a problem with this aggregate, so the user can fix it or
					// remove the aggregate from the output entirely.
					self.fire('invalidAggregate', null, aggNum, e.message);
				}
			});

			// Strip out any aggregates which resulted in errors earlier.
			info[what] = underscore.without(info[what], null);
		});

		underscore.each(self.data.rowVals, function (rowVal, rowValIdx) {
			underscore.each(info.group, function (aggInfo, aggNum) {
				if (groupResults[aggNum] === undefined) {
					groupResults[aggNum] = [];
				}
				var aggResult = aggInfo.instance.calculate(underscore.flatten(self.data.data[rowValIdx]));
				groupResults[aggNum][rowValIdx] = aggResult;
				if (aggInfo.debug) {
					self.debug('AGGREGATE', 'Group aggregate [%d] (%s) : Group [%s] = %s',
						aggNum,
						info.group[aggNum].instance.name + (info.group[aggNum].name ? ' -> ' + info.group[aggNum].name : ''),
						rowVal.join(', '),
						isElement(aggResult) ? getElement(aggResult).innerText : JSON.stringify(aggResult));
				}
			});

			if (self.data.isPivot) {
				underscore.each(info.cell, function (aggInfo, aggNum) {
					if (cellResults[aggNum] === undefined) {
						cellResults[aggNum] = [];
					}
					cellResults[aggNum][rowValIdx] = [];

					underscore.each(self.data.colVals, function (colVal, colValIdx) {
						var aggResult = aggInfo.instance.calculate(self.data.data[rowValIdx][colValIdx]);
						cellResults[aggNum][rowValIdx][colValIdx] = aggResult;
						if (aggInfo.debug) {
							self.debug('AGGREGATE', 'Cell aggregate [%d] (%s) : Cell [%s ; %s] = %s',
								aggNum,
								info.cell[aggNum].instance.name + (info.cell[aggNum].name ? ' -> ' + info.cell[aggNum].name : ''),
								rowVal.join(', '),
								colVal.join(', '),
								isElement(aggResult) ? getElement(aggResult).innerText : JSON.stringify(aggResult));
						}
					});
				});
			}
		});

		if (self.data.isPivot && info.pivot) {
			underscore.each(info.pivot, function (aggInfo, aggNum) {
				pivotResults[aggNum] = [];

				underscore.each(self.data.colVals, function (colVal, colValIdx) {
					var aggResult = aggInfo.instance.calculate(underscore.flatten(underscore.pluck(self.data.data, colValIdx)));
					pivotResults[aggNum][colValIdx] = aggResult;
					if (aggInfo.debug) {
						self.debug('AGGREGATE', 'Pivot aggregate [%d] (%s) : Col Val [%s] = %s',
							aggNum,
							info.pivot[aggNum].instance.name + (info.pivot[aggNum].name ? ' -> ' + info.pivot[aggNum].name : ''),
							colVal.join(', '),
							isElement(aggResult) ? getElement(aggResult).innerText : JSON.stringify(aggResult));
					}
				});
			});
		}

		if (info.all && (self.data.isGroup || self.data.isPivot)) {
			underscore.each(info.all, function (aggInfo, aggNum) {
				var aggResult = aggInfo.instance.calculate(underscore.flatten(self.data.data));
				allResults[aggNum] = aggResult;
				if (aggInfo.debug) {
					self.debug('AGGREGATE', 'All aggregate [%d] (%s) = %s',
						aggNum,
						info.all[aggNum].instance.name + (info.all[aggNum].name ? ' -> ' + info.all[aggNum].name : ''),
						JSON.stringify(aggResult));
				}
			});
		}

		self.data.agg = {
			info: info,
			results: {
				group: groupResults,
				pivot: pivotResults,
				cell: cellResults,
				all: allResults
			}
		};

		cont(true);
	};

	// #getData {{{2

	/**
	 * Retrieves a fresh copy of the data for this view from the data source.
	 *
	 * @param {function} cont What to do next.
	 *
	 * @param {string} reason
	 * Why are you calling this function?  (Used to save debugging information for onUnlock handlers.)
	 */

	View.prototype.getData = function (cont, reason) {
		var self = this;

		if (cont != null && typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be null or a function');
		}

		cont = cont || I;

		if (self.lock.isLocked()) {
			var lockMsg = 'Waiting to get data';
			if (reason != null) {
				lockMsg += ': ' + reason;
			}
			return self.lock.onUnlock(function () {
				self.getData(cont);
			}, lockMsg);
		}
		else {
			var lockMsg = 'Getting data';
			if (reason != null) {
				lockMsg += ': ' + reason;
			}
			self.debug(lockMsg);
		}

		if (self.data !== undefined) {
			self.debug(null, 'Got cached data: %O', self.data);
			if (typeof cont === 'function') {
				return cont(true, self.data);
			}
		}

		var fail = function () {
			self.lock.unlock();
			return cont(false);
		};

		self.lock.lock();

		return self.source.getData(function (ok, data) {
			if (!ok) {
				return fail();
			}

			return self.getTypeInfo(function (ok, typeInfo) {
				if (!ok) {
					return fail();
				}

				self.fire('workBegin');

				var ops = {
					filter: false,
					group: false,
					pivot: false,
					sort: false
				};

				self.data = {
					isPlain: true,
					isGroup: false,
					isPivot: false,
					data: [],
					dataByRowId: []
				};

				underscore.each(data, function (rowData, rowNum) {
					self.data.data.push({
						rowNum: rowNum,
						rowData: rowData
					});
					self.data.dataByRowId[rowNum] = rowData;
				});

				return self.filter(function (didFilter, filteredData) {
					ops.filter = didFilter;
					if (didFilter) {
						self.data.data = filteredData;
					}
					ops.group = self.group();
					ops.pivot = self.pivot();
					return self.aggregate(function () {
						return self.sort(function (didSort) {
							ops.sort = didSort;

							var workEndObj = {
								isPlain: self.data.isPlain,
								isGroup: self.data.isGroup,
								isPivot: self.data.isPivot
							};

							workEndObj.numRows = self.getRowCount();
							if (self.isFiltered()) {
								workEndObj.totalRows = self.getTotalRowCount();
							}

							if (self.data.isGroup) {
								workEndObj.numGroups = self.data.rowVals.length;
							}

							if (self.data.isPivot) {
								workEndObj.numGroups = self.data.rowVals.length;
								workEndObj.numPivots = self.data.colVals.length;
							}

							// FIXME Why does this need to save prefs?  They should be saved when the configuration
							// changes, not when we retrieve data.
							//
							// if (self.prefs != null) {
							// 	self.prefs.save();
							// }

							self.lastOps = ops;
							self.fire('workEnd', null, workEndObj, ops);

							self.lock.unlock();
							self.debug(null, 'Got new data: %O', self.data);
							if (typeof cont === 'function') {
								return cont(true, self.data);
							}
						}); // -- self.sort()
					}); // -- self.aggregate()
				}); // -- self.filter()
			}); // -- self.getTypeInfo()
		}); // -- self.getData()
	};

	// #getTypeInfo {{{2

	/**
	 *
	 */

	View.prototype.getTypeInfo = function (cont) {
		var self = this;

		if (typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be a function');
		}

		if (self.typeInfo != null) {
			return cont(true, self.typeInfo);
		}

		return self.source.getTypeInfo(function (ok, typeInfo) {
			if (!ok) {
				return cont(false);
			}

			self.typeInfo = typeInfo;
			self.fire('getTypeInfo', null, self.typeInfo, self.colConfig);
			return cont(true, self.typeInfo);
		});
	};

	// #clearCache {{{2

	View.prototype.clearCache = function () {
		var self = this;

		self.data = undefined;
		self.typeInfo = undefined;

		self.debug(null, 'Cleared cache');
	};

	// #clearSourceData {{{2

	View.prototype.clearSourceData = function () {
		var self = this;

		if (self.source instanceof Source) {
			self.source.clearCachedData();
		}
		else if (self.source instanceof View) {
			self.source.clearSourceData();
		}

		self.debug(null, 'Cleared source data');
	};

	// #refresh {{{2

	View.prototype.refresh = function () {
		var self = this;

		self.debug(null, 'Refreshing...');
		self.source.refresh();
	};

	// #reset {{{2

	/**
	 * Reset the view to reflect the data with no transformations.  This calls all the individual
	 * "clear" functions, but doesn't notify consumers that there's been work done until the end.
	 */

	View.prototype.reset = function (opts) {
		var self = this;

		opts = deepDefaults(opts, {
			sendEvent: true,
			dontSendEventTo: [],
			updateData: true,
			savePrefs: true
		});

		var clearOpts = jQuery.extend({}, opts, {
			updateData: false
		});

		self.debug(null, 'RESET!');

		self.clearSort(clearOpts);
		self.clearFilter(clearOpts);
		self.clearAggregate(clearOpts);
		self.clearPivot(clearOpts);
		self.clearGroup(clearOpts);

		if (!opts.updateData) {
			delete self.lastOps;
			return;
		}

		self.getData();
	};

	// #getUniqueVals {{{2

	View.prototype.getUniqueVals = function (cont) {
		var self = this;

		return self.source.getUniqueVals(cont);
	};

	// #getLastOps {{{2

	View.prototype.getLastOps = function () {
		var self = this;

		return self.lastOps;
	};

	// #setColConfig {{{2

	/**
	 * Set the column config on the view.  In particular here, we need access to how the user wants the
	 * data to be formatted.  You'd think that the view shouldn't have to know anything about the
	 * display of the data, and ideally you'd be right.  However, the view runs aggregate functions such
	 * as "group concat" which *do* need to know how values should be formatted.
	 *
	 * @param {OrdMap} colConfig
	 * The column configuration.
	 */

	View.prototype.setColConfig = function (colConfig) {
		var self = this;

		if (!(colConfig instanceof OrdMap)) {
			throw new Error('Call Error: `colConfig` must be an instance of OrdMap');
		}

		self.debug(null, 'Setting column configuration');

		self.colConfig = colConfig;
	};

	// #prime {{{2

	View.prototype.prime = function (cont) {
		var self = this
			, args = Array.prototype.slice.call(arguments);

		if (typeof cont !== 'function') {
			throw new Error('Call Error: `cont` must be a function');
		}

		if (self.isPrimed) {
			return cont(false);
		}

		if (self.lock.isLocked()) {
			return self.lock.onUnlock(function () {
				self.prime.apply(self, args);
			}, 'Waiting to prime');
		}

		self.lock.lock('Priming!');

		self.prefs.prime(function () {
			self.source.getData(function () {
				self.prefs.bind('view', self);
				self.isPrimed = true;
				self.lock.unlock();
				cont(true);
			});
		});
	};

	// GroupFunction {{{1

	/**
	 * Represents a function that can be applied to the value of a field when grouping or pivotting.
	 *
	 * @param {object} spec
	 * A specification for the group function.
	 *
	 * @param {string} spec.displayName
	 * What should be shown in the user interface for this function's name.
	 *
	 * @param {Array.<string>} [spec.allowedTypes]
	 * If present, this function will only be presented as an option for fields in the specified set of
	 * data types (e.g. using `['datetime']` will restrict it to datetime fields only).  By default, the
	 * group function will be shown for fields of all types on which DataVis supports group functions.
	 *
	 * @param {function} [spec.valueFun]
	 * If present, this function will be used to transform the original data value into one used for
	 * grouping.  If not provided, the default is the identity function.
	 *
	 * @param {string} [spec.resultType="string"]
	 * The DataVis field type of the result of calling `valueFun`.
	 *
	 * @param {string} [spec.sortType=spec.resultType]
	 * If present, overrides the algorithm for sorting group values, e.g. "month" to sort month names by
	 * chronological (rather than alphabetical) order.
	 *
	 * @param {boolean} [canFilter=true]
	 * If true, a filter can be applied to the data based on the result of this group function.  Used to
	 * determine when drilldown is available, since drilling down means applying a filter that produces
	 * exactly the population of the group.
	 *
	 * @param {function} [spec.valueToFilter]
	 * If present, this function will be used to transform a value into a filter object that matches the
	 * value.  Used for things like date buckets (e.g. a value "2010 October" becomes a filter for dates
	 * from 10/1/2010 to 10/31/2010).
	 *
	 * @class
	 */

	var GroupFunction = makeSubclass('GroupFunction', Object, function (spec) {
		var self = this;

		spec = deepDefaults(spec, {});

		if (spec.displayName == null || typeof spec.displayName !== 'string') {
			throw new Error('Call Error: `displayName` must be a string');
		}

		if (spec.allowedTypes != null && !underscore.isArray(spec.allowedTypes)) {
			throw new Error('Call Error: `allowedTypes` must be null or an array');
		}

		if (spec.valueFun != null && typeof spec.valueFun !== 'function') {
			throw new Error('Call Error: `valueFun` must be null or a function');
		}

		if (spec.resultType != null && typeof spec.resultType !== 'string') {
			throw new Error('Call Error: `resultType` must be null or a string');
		}

		if (spec.sortType != null && typeof spec.sortType !== 'string') {
			throw new Error('Call Error: `sortType` must be null or a string');
		}

		if (spec.valueToFilter != null && typeof spec.valueToFilter !== 'function') {
			throw new Error('Call Error: `valueToFilter` must be null or a function');
		}

		spec = deepDefaults(spec, {
			resultType: 'string',
			canFilter: true,
			valueToFilter: function (s) {
				return {'$eq': s};
			}
		});

		if (spec.sortType == null) {
			spec.sortType = spec.resultType;
		}

		copyProps(spec, self, ['displayName', 'allowedTypes', 'valueFun', 'resultType', 'sortType', 'canFilter', 'valueToFilter']);
	});

	// #applyValueFun {{{2

	/**
	 * Apply the function to get the value used for grouping.
	 *
	 * @param {any} x
	 * The original value from the data.
	 *
	 * @returns {any}
	 * The value that should be used for grouping purposes.
	 */

	GroupFunction.prototype.applyValueFun = function (x) {
		return this.valueFun ? this.valueFun(x) : x;
	};

	// Group Function Registry {{{1

	var GROUP_FUNCTION_REGISTRY = new OrdMap();

	GROUP_FUNCTION_REGISTRY.set('year', new GroupFunction({
		displayName: 'Year',
		allowedTypes: ['date', 'datetime'],
		valueFun: function (d) {
			if (typeof d === 'string') {
				d = moment(d);
			}
			if (!moment.isMoment(d) || !d.isValid()) {
				return 'Invalid Date';
			}
			return d.format('YYYY');
		},
		valueToFilter: function (s) {
			return {
				'$gte': moment(s, 'YYYY').format('YYYY-MM-DD HH:mm:ss'),
				'$lte': moment(s, 'YYYY').add(1, 'years').subtract(1, 'seconds').format('YYYY-MM-DD HH:mm:ss')
			};
		}
	}));

	GROUP_FUNCTION_REGISTRY.set('quarter', new GroupFunction({
		displayName: 'Quarter',
		allowedTypes: ['date', 'datetime'],
		valueFun: function (d) {
			if (typeof d === 'string') {
				d = moment(d);
			}
			if (!moment.isMoment(d) || !d.isValid()) {
				return 'Invalid Date';
			}
			return d.format('[Q]Q');
		},
		// The View does not currently offer a filter that matches a date within a specific quarter
		// regardless of year (e.g. all dates in Q1 in any year).
		canFilter: false
	}));

	GROUP_FUNCTION_REGISTRY.set('month', new GroupFunction({
		displayName: 'Month',
		allowedTypes: ['date', 'datetime'],
		valueFun: function (d) {
			if (typeof d === 'string') {
				d = moment(d);
			}
			if (!moment.isMoment(d) || !d.isValid()) {
				return 'Invalid Date';
			}
			return d.format('MMM');
		},
		sortType: 'month',
		// The View does not currently offer a filter that matches a date within a specific month
		// regardless of year (e.g. all dates in October in any year).
		canFilter: false
	}));

	GROUP_FUNCTION_REGISTRY.set('week_iso', new GroupFunction({
		displayName: 'Week (ISO)',
		allowedTypes: ['date', 'datetime'],
		valueFun: function (d) {
			if (typeof d === 'string') {
				d = moment(d);
			}
			if (!moment.isMoment(d) || !d.isValid()) {
				return 'Invalid Date';
			}
			return d.format('[W]WW');
		},
		// The View does not currently offer a filter that matches a date within a specific week
		// regardless of year.
		canFilter: false
	}));

	GROUP_FUNCTION_REGISTRY.set('day', new GroupFunction({
		displayName: 'Day Only (No Time)',
		allowedTypes: ['datetime'],
		valueFun: function (d) {
			if (typeof d === 'string') {
				d = moment(d);
			}
			if (!moment.isMoment(d) || !d.isValid()) {
				return 'Invalid Date';
			}
			return d.format('YYYY-MM-DD');
		},
		resultType: 'date',
		valueToFilter: function (s) {
			return {
				'$gte': moment(s).format('YYYY-MM-DD HH:mm:ss'),
				'$lte': moment(s).add(1, 'days').subtract(1, 'seconds').format('YYYY-MM-DD HH:mm:ss')
			};
		}
	}));

	GROUP_FUNCTION_REGISTRY.set('day_of_week', new GroupFunction({
		displayName: 'Day of Week',
		allowedTypes: ['date', 'datetime'],
		valueFun: function (d) {
			if (typeof d === 'string') {
				d = moment(d);
			}
			if (!moment.isMoment(d) || !d.isValid()) {
				return 'Invalid Date';
			}
			return d.format('ddd');
		},
		sortType: 'day_of_week',
		// The View does not currently offer a filter that matches a date for a specific day of the week
		// (e.g. find all dates that fall on Tuesday).
		canFilter: false
	}));

	GROUP_FUNCTION_REGISTRY.set('year_and_quarter', new GroupFunction({
		displayName: 'Year & Quarter',
		allowedTypes: ['date', 'datetime'],
		valueFun: function (d) {
			if (typeof d === 'string') {
				d = moment(d);
			}
			if (!moment.isMoment(d) || !d.isValid()) {
				return 'Invalid Date';
			}
			return d.format('YYYY [Q]Q');
		},
		valueToFilter: function (s) {
			return {
				'$gte': moment(s, 'YYYY [Q]Q').format('YYYY-MM-DD HH:mm:ss'),
				'$lte': moment(s, 'YYYY [Q]Q').add(1, 'quarters').subtract(1, 'seconds').format('YYYY-MM-DD HH:mm:ss')
			};
		}
	}));

	GROUP_FUNCTION_REGISTRY.set('year_and_month', new GroupFunction({
		displayName: 'Year & Month',
		allowedTypes: ['date', 'datetime'],
		valueFun: function (d) {
			if (typeof d === 'string') {
				d = moment(d);
			}
			if (!moment.isMoment(d) || !d.isValid()) {
				return 'Invalid Date';
			}
			return d.format('YYYY MMM');
		},
		sortType: 'year_and_month',
		valueToFilter: function (s) {
			return {
				'$gte': moment(s, 'YYYY MMM').format('YYYY-MM-DD HH:mm:ss'),
				'$lte': moment(s, 'YYYY MMM').add(1, 'months').subtract(1, 'seconds').format('YYYY-MM-DD HH:mm:ss')
			};
		}
	}));

	GROUP_FUNCTION_REGISTRY.set('year_and_week_iso', new GroupFunction({
		displayName: 'Year & Week (ISO)',
		allowedTypes: ['date', 'datetime'],
		valueFun: function (d) {
			if (typeof d === 'string') {
				d = moment(d);
			}
			if (!moment.isMoment(d) || !d.isValid()) {
				return 'Invalid Date';
			}
			return d.format('YYYY [W]WW');
		},
		valueToFilter: function (s) {
			return {
				'$gte': moment(s, 'YYYY [W]WW').format('YYYY-MM-DD HH:mm:ss'),
				'$lte': moment(s, 'YYYY [W]WW').add(1, 'weeks').subtract(1, 'seconds').format('YYYY-MM-DD HH:mm:ss')
			};
		}
	}));

	window.MIE              = window.MIE || {};
	window.MIE.log          = log;
	window.MIE.debug        = debug;
	window.MIE.OrdMap       = OrdMap;
	window.MIE.Lock         = Lock;
	window.MIE.trans        = trans;
	window.MIE.makeSubclass = makeSubclass;

	window.MIE.WC_DataVis                 = window.MIE.WC_DataVis || {};
	window.MIE.WC_DataVis.Aggregate       = Aggregate;
	window.MIE.WC_DataVis.ParamInput      = ParamInput;
	window.MIE.WC_DataVis.Source          = Source;
	window.MIE.WC_DataVis.GroupFunction   = GroupFunction;
	window.MIE.WC_DataVis.View            = View;
	window.MIE.WC_DataVis.Grid            = Grid;
	window.MIE.WC_DataVis.grids           = {};
	window.MIE.WC_DataVis.Graph           = Graph;
	window.MIE.WC_DataVis.graphs          = {};
	window.MIE.WC_DataVis.Perspective     = Perspective;
	window.MIE.WC_DataVis.Prefs           = Prefs;
	window.MIE.WC_DataVis.PrefsBackend    = PrefsBackend;
	window.MIE.WC_DataVis.PrefsModule     = PrefsModule;
	window.MIE.WC_DataVis.PrefsModuleGrid = PrefsModuleGrid;
	window.MIE.WC_DataVis.EXPORT_URL      = 'export.php';

	// Expose "registry" extension points

	window.MIE.WC_DataVis.AGGREGATE_REGISTRY      = AGGREGATE_REGISTRY;
	window.MIE.WC_DataVis.GROUP_FUNCTION_REGISTRY = GROUP_FUNCTION_REGISTRY;
	window.MIE.WC_DataVis.PREFS_BACKEND_REGISTRY  = PREFS_BACKEND_REGISTRY;
	window.MIE.WC_DataVis.PREFS_MODULE_REGISTRY   = PREFS_MODULE_REGISTRY;

	window.MIE.WC_DataVis.Util                    = Util;

}(jQuery, undefined, undefined));
